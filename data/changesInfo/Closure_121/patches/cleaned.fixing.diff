diff -u -r tmp/changesInfo/Closure_121/properties/modified_classes/inducing/src/com/google/javascript/jscomp/InlineVariables.java tmp/changesInfo/Closure_121/cleaned/fixing/src/com/google/javascript/jscomp/InlineVariables.java
--- tmp/changesInfo/Closure_121/properties/modified_classes/inducing/src/com/google/javascript/jscomp/InlineVariables.java	2023-06-12 11:40:31.910465509 +0800
+++ tmp/changesInfo/Closure_121/cleaned/fixing/src/com/google/javascript/jscomp/InlineVariables.java	2023-06-15 20:34:15.015657916 +0800
@@ -233,7 +233,9 @@
       // reference data is out of sync. We're better off just waiting for
       // the next pass.)
       if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&
-          referenceInfo.isAssignedOnce()) {
+          referenceInfo.isAssignedOnce() &&
+          (isInlineableDeclaredConstant(v, referenceInfo) ||
+            referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNameNode();
diff -u -r tmp/changesInfo/Closure_121/properties/modified_classes/inducing/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java tmp/changesInfo/Closure_121/cleaned/fixing/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
--- tmp/changesInfo/Closure_121/properties/modified_classes/inducing/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java	2023-08-02 19:18:28.201596387 +0800
+++ tmp/changesInfo/Closure_121/cleaned/fixing/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java	2023-06-15 20:56:49.878745209 +0800
@@ -333,6 +333,49 @@
     }
 
     /**
+     * @return Whether the variable is only assigned a value once for its
+     *     lifetime.
+     */
+    boolean isOnlyAssignmentSameScopeAsDeclaration() {
+      Reference ref = getOneAndOnlyAssignment();
+      Preconditions.checkNotNull(ref);
+
+      // Make sure the declaration is the same scope as the assignment.
+      // Otherwise, the variable can be assigned multiple times and possibly
+      // with a different variable.
+      for (BasicBlock block = ref.getBasicBlock();
+           block != null; block = block.getParent()) {
+        if (block.isFunction) {
+          if (ref.getSymbol().scope != ref.scope) {
+            return false;
+          }
+        }
+      }
+
+      return true;
+    }
+
+    /**
+     * @return The one and only assignment. Returns if there are 0 or 2+
+     *    assignments.
+     */
+    private Reference getOneAndOnlyAssignment() {
+      Reference assignment = null;
+      int size = references.size();
+      for (int i = 0; i < size; i++) {
+        Reference ref = references.get(i);
+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {
+          if (assignment == null) {
+            assignment = ref;
+          } else {
+            return null;
+          }
+        }
+      }
+      return assignment;
+    }
+
+    /**
      * @return Whether the variable is only assigned a value once.
      */
     boolean isAssignedOnce() {
@@ -358,6 +401,7 @@
       }
       return false;
     }
+
   }
 
   /**
@@ -399,6 +443,10 @@
       this.sourceName = sourceName;
     }
 
+    public Var getSymbol() {
+      return scope.getVar(nameNode.getString());
+    }
+
     boolean isDeclaration() {
       return DECLARATION_PARENTS.contains(parent.getType()) ||
           parent.getType() == Token.LP &&
@@ -425,7 +473,7 @@
           (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);
     }
 
-   /**
+    /**
     * @return For an assignment or variable declaration return the assigned
     * value, otherwise null.
     */
@@ -500,6 +548,11 @@
     private final boolean mayBeHoisted;
 
     /**
+     * Whether this block denotes a function scope.
+     */
+    private final boolean isFunction;
+
+    /**
      * Creates a new block.
      * @param parent The containing block.
      * @param root The root node of the block.
@@ -510,6 +563,8 @@
       // only named functions may be hoisted.
       this.mayBeHoisted = (root.getType() == Token.FUNCTION) &&
           !NodeUtil.isFunctionAnonymous(root);
+
+      this.isFunction = root.getType() == Token.FUNCTION;
     }
 
     BasicBlock getParent() {
Only in tmp/changesInfo/Closure_121/properties/modified_classes/inducing: test
