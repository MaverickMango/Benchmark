diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java
index 30215f4..0789e86 100644
--- a/src/com/google/javascript/jscomp/Compiler.java
+++ b/src/com/google/javascript/jscomp/Compiler.java
@@ -253,6 +253,22 @@
       guards.add(new DiagnosticGroupWarningsGuard(
           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
     }
+
+    // DiagnosticGroups override the plain checkTypes option.
+    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
+      options.checkTypes = true;
+    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
+      options.checkTypes = false;
+    } else if (!options.checkTypes) {
+      // If DiagnosticGroups did not override the plain checkTypes
+      // option, and checkTypes is enabled, then turn off the
+      // parser type warnings.
+      guards.add(
+          new DiagnosticGroupWarningsGuard(
+              DiagnosticGroup.forType(
+                  RhinoErrorReporter.TYPE_PARSE_ERROR),
+              CheckLevel.OFF));
+    }
     this.warningsGuard = new ComposeWarningsGuard(guards);
   }
 
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 3d065d4..ab09265 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -238,13 +238,6 @@
       checks.add(objectPropertyStringPreprocess);
     }
 
-    // DiagnosticGroups override the plain checkTypes option.
-    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
-      options.checkTypes = true;
-    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
-      options.checkTypes = false;
-    }
-
     if (options.checkTypes) {
       checks.add(resolveTypes.makeOneTimePass());
       checks.add(inferTypes.makeOneTimePass());
diff --git a/src/com/google/javascript/jscomp/RhinoErrorReporter.java b/src/com/google/javascript/jscomp/RhinoErrorReporter.java
index cdcd2da..321cdd5 100644
--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java
+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java
@@ -35,6 +35,9 @@
   static final DiagnosticType PARSE_ERROR =
       DiagnosticType.error("JSC_PARSE_ERROR", "Parse error. {0}");
 
+  static final DiagnosticType TYPE_PARSE_ERROR =
+      DiagnosticType.warning("JSC_TYPE_PARSE_ERROR", "{0}");
+
   // A special-cased error, so that it can be configured via the
   // warnings API.
   static final DiagnosticType EXTRA_FILEOVERVIEW =
@@ -53,7 +56,7 @@
     DiagnosticType.warning("JSC_BAD_JSDOC_ANNOTATION", "Parse error. {0}");
 
   // A map of Rhino messages to their DiagnosticType.
-  private final Map<String, DiagnosticType> typeMap;
+  private final Map<Pattern, DiagnosticType> typeMap;
 
   private final AbstractCompiler compiler;
 
@@ -62,9 +65,9 @@
    * holder {0} with a wild card that matches all possible strings.
    * Also put the any non-place-holder in quotes for regex matching later.
    */
-  private String replacePlaceHolders(String s) {
+  private Pattern replacePlaceHolders(String s) {
     s = Pattern.quote(s);
-    return s.replaceAll("\\{\\d+\\}", "\\\\E.*\\\\Q");
+    return Pattern.compile(s.replaceAll("\\{\\d+\\}", "\\\\E.*\\\\Q"));
   }
 
   private RhinoErrorReporter(AbstractCompiler compiler) {
@@ -90,7 +93,11 @@
 
         // Unknown @annotations.
         replacePlaceHolders(ScriptRuntime.getMessage0("msg.bad.jsdoc.tag")),
-        BAD_JSDOC_ANNOTATION);
+        BAD_JSDOC_ANNOTATION,
+
+        // Type annotation errors.
+        Pattern.compile("^Bad type annotation.*"),
+        TYPE_PARSE_ERROR);
   }
 
   public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter
@@ -119,8 +126,8 @@
 
     // Try to see if the message is one of the rhino errors we want to
     // expose as DiagnosticType by matching it with the regex key.
-    for (Entry<String, DiagnosticType> entry : typeMap.entrySet()) {
-      if (message.matches(entry.getKey())) {
+    for (Entry<Pattern, DiagnosticType> entry : typeMap.entrySet()) {
+      if (entry.getKey().matcher(message).matches()) {
         return JSError.make(
             sourceName, line, lineOffset, entry.getValue(), message);
       }
diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java
index 41b94e0..fb0167f 100644
--- a/src/com/google/javascript/jscomp/TypeCheck.java
+++ b/src/com/google/javascript/jscomp/TypeCheck.java
@@ -238,6 +238,7 @@
       UNRESOLVED_TYPE,
       WRONG_ARGUMENT_COUNT,
       ILLEGAL_IMPLICIT_CAST,
+      RhinoErrorReporter.TYPE_PARSE_ERROR,
       TypedScopeCreator.UNKNOWN_LENDS,
       TypedScopeCreator.LENDS_ON_NON_OBJECT,
       TypedScopeCreator.CTOR_INITIALIZER,
diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
index e295abd..5fd99d5 100644
--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
@@ -53,15 +53,31 @@
   private final Node templateNode;
 
   private class ErrorReporterParser {
-    void addWarning(String messageId, String messageArg, int lineno,
-                    int charno) {
+    void addParserWarning(String messageId, String messageArg, int lineno,
+        int charno) {
       errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),
           sourceName, lineno, null, charno);
     }
-    void addWarning(String messageId, int lineno, int charno) {
+
+    void addParserWarning(String messageId, int lineno, int charno) {
       errorReporter.warning(ScriptRuntime.getMessage0(messageId),
           sourceName, lineno, null, charno);
     }
+
+    void addTypeWarning(String messageId, String messageArg, int lineno,
+                    int charno) {
+      errorReporter.warning(
+          "Bad type annotation. " +
+          ScriptRuntime.getMessage1(messageId, messageArg),
+          sourceName, lineno, null, charno);
+    }
+
+    void addTypeWarning(String messageId, int lineno, int charno) {
+      errorReporter.warning(
+          "Bad type annotation. " +
+          ScriptRuntime.getMessage0(messageId),
+          sourceName, lineno, null, charno);
+    }
   }
 
   // The DocInfo with the fileoverview tag for the whole file.
@@ -188,7 +204,7 @@
             String annotationName = stream.getString();
             Annotation annotation = annotationNames.get(annotationName);
             if (annotation == null) {
-              parser.addWarning("msg.bad.jsdoc.tag", annotationName,
+              parser.addParserWarning("msg.bad.jsdoc.tag", annotationName,
                   stream.getLineno(), stream.getCharno());
             } else {
               // Mark the beginning of the annotation.
@@ -201,7 +217,7 @@
                     String author = authorInfo.string;
 
                     if (author.length() == 0) {
-                      parser.addWarning("msg.jsdoc.authormissing",
+                      parser.addParserWarning("msg.jsdoc.authormissing",
                           stream.getLineno(), stream.getCharno());
                     } else {
                       jsdocBuilder.addAuthor(author);
@@ -214,7 +230,7 @@
 
                 case CONSTANT:
                   if (!jsdocBuilder.recordConstancy()) {
-                    parser.addWarning("msg.jsdoc.const",
+                    parser.addParserWarning("msg.jsdoc.const",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -223,10 +239,10 @@
                 case CONSTRUCTOR:
                   if (!jsdocBuilder.recordConstructor()) {
                     if (jsdocBuilder.isInterfaceRecorded()) {
-                      parser.addWarning("msg.jsdoc.interface.constructor",
+                      parser.addTypeWarning("msg.jsdoc.interface.constructor",
                           stream.getLineno(), stream.getCharno());
                     } else {
-                      parser.addWarning("msg.jsdoc.incompat.type",
+                      parser.addTypeWarning("msg.jsdoc.incompat.type",
                           stream.getLineno(), stream.getCharno());
                     }
                   }
@@ -235,7 +251,7 @@
 
                 case DEPRECATED:
                   if (!jsdocBuilder.recordDeprecated()) {
-                    parser.addWarning("msg.jsdoc.deprecated",
+                    parser.addParserWarning("msg.jsdoc.deprecated",
                         stream.getLineno(), stream.getCharno());
                   }
 
@@ -255,10 +271,10 @@
                 case INTERFACE:
                   if (!jsdocBuilder.recordInterface()) {
                     if (jsdocBuilder.isConstructorRecorded()) {
-                      parser.addWarning("msg.jsdoc.interface.constructor",
+                      parser.addTypeWarning("msg.jsdoc.interface.constructor",
                           stream.getLineno(), stream.getCharno());
                     } else {
-                      parser.addWarning("msg.jsdoc.incompat.type",
+                      parser.addTypeWarning("msg.jsdoc.incompat.type",
                           stream.getLineno(), stream.getCharno());
                     }
                   }
@@ -267,7 +283,7 @@
 
                 case DESC:
                   if (jsdocBuilder.isDescriptionRecorded()) {
-                    parser.addWarning("msg.jsdoc.desc.extra",
+                    parser.addParserWarning("msg.jsdoc.desc.extra",
                         stream.getLineno(), stream.getCharno());
                     token = eatTokensUntilEOL();
                     continue retry;
@@ -298,7 +314,7 @@
 
                   if (!jsdocBuilder.recordFileOverview(fileOverview) ||
                       fileOverviewJSDocInfo != null) {
-                    parser.addWarning("msg.jsdoc.fileoverview.extra",
+                    parser.addParserWarning("msg.jsdoc.fileoverview.extra",
                         stream.getLineno(), stream.getCharno());
                   }
                   continue retry;
@@ -335,7 +351,7 @@
                     type = createJSTypeExpression(newStringNode("number"));
                   }
                   if (!jsdocBuilder.recordEnumParameterType(type)) {
-                    parser.addWarning(
+                    parser.addTypeWarning(
                         "msg.jsdoc.incompat.type", lineno, charno);
                   }
                   token = eatTokensUntilEOL(token);
@@ -343,7 +359,7 @@
 
                 case EXPORT:
                   if (!jsdocBuilder.recordExport()) {
-                    parser.addWarning("msg.jsdoc.export",
+                    parser.addParserWarning("msg.jsdoc.export",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -351,7 +367,7 @@
 
                 case EXTERNS:
                   if (!jsdocBuilder.recordExterns()) {
-                    parser.addWarning("msg.jsdoc.externs",
+                    parser.addParserWarning("msg.jsdoc.externs",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -359,7 +375,7 @@
 
                 case JAVA_DISPATCH:
                   if (!jsdocBuilder.recordJavaDispatch()) {
-                    parser.addWarning("msg.jsdoc.javadispatch",
+                    parser.addParserWarning("msg.jsdoc.javadispatch",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -393,37 +409,37 @@
 
                     if (annotation == Annotation.EXTENDS) {
                       if (!jsdocBuilder.recordBaseType(type)) {
-                        parser.addWarning(
+                        parser.addTypeWarning(
                             "msg.jsdoc.incompat.type", lineno, charno);
                       }
                     } else {
                       Preconditions.checkState(
                           annotation == Annotation.IMPLEMENTS);
                       if (!jsdocBuilder.recordImplementedInterface(type)) {
-                        parser.addWarning("msg.jsdoc.implements.duplicate",
+                        parser.addTypeWarning("msg.jsdoc.implements.duplicate",
                             lineno, charno);
                       }
                     }
                     token = next();
                     if (matchingRc) {
                       if (token != JsDocToken.RC) {
-                        parser.addWarning("msg.jsdoc.missing.rc",
+                        parser.addTypeWarning("msg.jsdoc.missing.rc",
                             stream.getLineno(), stream.getCharno());
                       }
                     } else if (token != JsDocToken.EOL &&
                         token != JsDocToken.EOF && token != JsDocToken.EOC) {
-                      parser.addWarning("msg.end.annotation.expected",
+                      parser.addTypeWarning("msg.end.annotation.expected",
                           stream.getLineno(), stream.getCharno());
                     }
                   } else {
-                    parser.addWarning("msg.no.type.name", lineno, charno);
+                    parser.addTypeWarning("msg.no.type.name", lineno, charno);
                   }
                   token = eatTokensUntilEOL(token);
                   continue retry;
 
                 case HIDDEN:
                   if (!jsdocBuilder.recordHiddenness()) {
-                    parser.addWarning("msg.jsdoc.hidden",
+                    parser.addParserWarning("msg.jsdoc.hidden",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -441,16 +457,16 @@
                   if (match(JsDocToken.STRING)) {
                     token = next();
                     if (!jsdocBuilder.recordLends(stream.getString())) {
-                      parser.addWarning("msg.jsdoc.lends.incompatible",
+                      parser.addTypeWarning("msg.jsdoc.lends.incompatible",
                           stream.getLineno(), stream.getCharno());
                     }
                   } else {
-                    parser.addWarning("msg.jsdoc.lends.missing",
+                    parser.addTypeWarning("msg.jsdoc.lends.missing",
                         stream.getLineno(), stream.getCharno());
                   }
 
                   if (matchingRc && !match(JsDocToken.RC)) {
-                    parser.addWarning("msg.jsdoc.missing.rc",
+                    parser.addTypeWarning("msg.jsdoc.missing.rc",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -462,14 +478,14 @@
                   String meaning = meaningInfo.string;
                   token = meaningInfo.token;
                   if (!jsdocBuilder.recordMeaning(meaning)) {
-                    parser.addWarning("msg.jsdoc.meaning.extra",
+                    parser.addParserWarning("msg.jsdoc.meaning.extra",
                         stream.getLineno(), stream.getCharno());
                   }
                   continue retry;
 
                 case NO_ALIAS:
                   if (!jsdocBuilder.recordNoAlias()) {
-                    parser.addWarning("msg.jsdoc.noalias",
+                    parser.addParserWarning("msg.jsdoc.noalias",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -477,7 +493,7 @@
 
                 case NO_COMPILE:
                   if (!jsdocBuilder.recordNoCompile()) {
-                    parser.addWarning("msg.jsdoc.nocompile",
+                    parser.addParserWarning("msg.jsdoc.nocompile",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -485,7 +501,7 @@
 
                 case NO_TYPE_CHECK:
                   if (!jsdocBuilder.recordNoTypeCheck()) {
-                    parser.addWarning("msg.jsdoc.nocheck",
+                    parser.addParserWarning("msg.jsdoc.nocheck",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -498,7 +514,7 @@
                 case INHERIT_DOC:
                 case OVERRIDE:
                   if (!jsdocBuilder.recordOverride()) {
-                    parser.addWarning("msg.jsdoc.override",
+                    parser.addTypeWarning("msg.jsdoc.override",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -576,7 +592,7 @@
                   }
 
                   if (JsDocToken.STRING != token) {
-                    parser.addWarning("msg.missing.variable.name",
+                    parser.addTypeWarning("msg.missing.variable.name",
                         lineno, charno);
                   } else {
                     name = stream.getString();
@@ -610,10 +626,10 @@
                       name = null;
                     } else if (!jsdocBuilder.recordParameter(name, type)) {
                       if (jsdocBuilder.hasParameter(name)) {
-                        parser.addWarning("msg.dup.variable.name", name,
+                        parser.addTypeWarning("msg.dup.variable.name", name,
                             lineno, charno);
                       } else {
-                        parser.addWarning("msg.jsdoc.incompat.type", name,
+                        parser.addTypeWarning("msg.jsdoc.incompat.type", name,
                             lineno, charno);
                       }
                     }
@@ -646,7 +662,7 @@
 
                 case PRESERVE_TRY:
                   if (!jsdocBuilder.recordPreserveTry()) {
-                    parser.addWarning("msg.jsdoc.preservertry",
+                    parser.addParserWarning("msg.jsdoc.preservertry",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -654,7 +670,7 @@
 
                 case PRIVATE:
                   if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
-                    parser.addWarning("msg.jsdoc.visibility.private",
+                    parser.addParserWarning("msg.jsdoc.visibility.private",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -662,7 +678,7 @@
 
                 case PROTECTED:
                   if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
-                    parser.addWarning("msg.jsdoc.visibility.protected",
+                    parser.addParserWarning("msg.jsdoc.visibility.protected",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -670,7 +686,7 @@
 
                 case PUBLIC:
                   if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
-                    parser.addWarning("msg.jsdoc.visibility.public",
+                    parser.addParserWarning("msg.jsdoc.visibility.public",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -678,7 +694,7 @@
 
                 case NO_SHADOW:
                   if (!jsdocBuilder.recordNoShadow()) {
-                    parser.addWarning("msg.jsdoc.noshadow",
+                    parser.addParserWarning("msg.jsdoc.noshadow",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -686,7 +702,7 @@
 
                 case NO_SIDE_EFFECTS:
                   if (!jsdocBuilder.recordNoSideEffects()) {
-                    parser.addWarning("msg.jsdoc.nosideeffects",
+                    parser.addParserWarning("msg.jsdoc.nosideeffects",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -698,7 +714,7 @@
 
                 case IMPLICIT_CAST:
                   if (!jsdocBuilder.recordImplicitCast()) {
-                    parser.addWarning("msg.jsdoc.implicitcast",
+                    parser.addTypeWarning("msg.jsdoc.implicitcast",
                         stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
@@ -710,7 +726,7 @@
                     String reference = referenceInfo.string;
 
                     if (reference.length() == 0) {
-                      parser.addWarning("msg.jsdoc.seemissing",
+                      parser.addParserWarning("msg.jsdoc.seemissing",
                           stream.getLineno(), stream.getCharno());
                     } else {
                       jsdocBuilder.addReference(reference);
@@ -731,11 +747,11 @@
                   String templateTypeName = templateInfo.string;
 
                   if (templateTypeName.length() == 0) {
-                    parser.addWarning("msg.jsdoc.templatemissing",
+                    parser.addTypeWarning("msg.jsdoc.templatemissing",
                           stream.getLineno(), stream.getCharno());
                   } else if (!jsdocBuilder.recordTemplateTypeName(
                       templateTypeName)) {
-                    parser.addWarning("msg.jsdoc.template.at.most.once",
+                    parser.addTypeWarning("msg.jsdoc.template.at.most.once",
                         stream.getLineno(), stream.getCharno());
                   }
 
@@ -747,11 +763,11 @@
                   String version = versionInfo.string;
 
                   if (version.length() == 0) {
-                    parser.addWarning("msg.jsdoc.versionmissing",
+                    parser.addParserWarning("msg.jsdoc.versionmissing",
                           stream.getLineno(), stream.getCharno());
                   } else {
                     if (!jsdocBuilder.recordVersion(version)) {
-                       parser.addWarning("msg.jsdoc.extraversion",
+                       parser.addParserWarning("msg.jsdoc.extraversion",
                           stream.getLineno(), stream.getCharno());
                     }
                   }
@@ -787,14 +803,14 @@
                     switch (annotation) {
                       case DEFINE:
                         if (!jsdocBuilder.recordDefineType(type)) {
-                          parser.addWarning("msg.jsdoc.define",
+                          parser.addParserWarning("msg.jsdoc.define",
                               lineno, charno);
                         }
                         break;
 
                       case RETURN:
                         if (!jsdocBuilder.recordReturnType(type)) {
-                          parser.addWarning(
+                          parser.addTypeWarning(
                               "msg.jsdoc.incompat.type", lineno, charno);
                           break;
                         }
@@ -823,21 +839,21 @@
 
                       case THIS:
                         if (!jsdocBuilder.recordThisType(type)) {
-                          parser.addWarning(
+                          parser.addTypeWarning(
                               "msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
 
                       case TYPE:
                         if (!jsdocBuilder.recordType(type)) {
-                          parser.addWarning(
+                          parser.addTypeWarning(
                               "msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
 
                       case TYPEDEF:
                         if (!jsdocBuilder.recordTypedef(type)) {
-                          parser.addWarning(
+                          parser.addTypeWarning(
                               "msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
@@ -861,7 +877,7 @@
         case EOF:
           // discard any accumulated information
           jsdocBuilder.build(null);
-          parser.addWarning("msg.unexpected.eof",
+          parser.addParserWarning("msg.unexpected.eof",
               stream.getLineno(), stream.getCharno());
           return false;
 
@@ -901,14 +917,14 @@
         if (match(JsDocToken.STRING)) {
           String name = stream.getString();
           if (!suppressionNames.contains(name)) {
-            parser.addWarning("msg.jsdoc.suppress.unknown", name,
+            parser.addParserWarning("msg.jsdoc.suppress.unknown", name,
                 stream.getLineno(), stream.getCharno());
           }
 
           suppressions.add(stream.getString());
           token = next();
         } else {
-          parser.addWarning("msg.jsdoc.suppress",
+          parser.addParserWarning("msg.jsdoc.suppress",
               stream.getLineno(), stream.getCharno());
           return token;
         }
@@ -921,12 +937,12 @@
       }
 
       if (!match(JsDocToken.RC)) {
-        parser.addWarning("msg.jsdoc.suppress",
+        parser.addParserWarning("msg.jsdoc.suppress",
             stream.getLineno(), stream.getCharno());
       } else {
         token = next();
         if (!jsdocBuilder.recordSuppressions(suppressions)) {
-          parser.addWarning("msg.jsdoc.suppress.duplicate",
+          parser.addParserWarning("msg.jsdoc.suppress.duplicate",
               stream.getLineno(), stream.getCharno());
         }
       }
@@ -948,14 +964,14 @@
           String name = stream.getString();
           if (!modifiesAnnotationKeywords.contains(name)
               && !jsdocBuilder.hasParameter(name)) {
-              parser.addWarning("msg.jsdoc.modifies.unknown", name,
+              parser.addParserWarning("msg.jsdoc.modifies.unknown", name,
                   stream.getLineno(), stream.getCharno());
           }
 
           modifies.add(stream.getString());
           token = next();
         } else {
-          parser.addWarning("msg.jsdoc.modifies",
+          parser.addParserWarning("msg.jsdoc.modifies",
               stream.getLineno(), stream.getCharno());
           return token;
         }
@@ -968,12 +984,12 @@
       }
 
       if (!match(JsDocToken.RC)) {
-        parser.addWarning("msg.jsdoc.modifies",
+        parser.addParserWarning("msg.jsdoc.modifies",
             stream.getLineno(), stream.getCharno());
       } else {
         token = next();
         if (!jsdocBuilder.recordModifies(modifies)) {
-          parser.addWarning("msg.jsdoc.modifies.duplicate",
+          parser.addParserWarning("msg.jsdoc.modifies.duplicate",
               stream.getLineno(), stream.getCharno());
         }
       }
@@ -2100,7 +2116,7 @@
   }
 
   private Node reportTypeSyntaxWarning(String warning) {
-    parser.addWarning(warning, stream.getLineno(), stream.getCharno());
+    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());
     return null;
   }
 
diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java
index 9775653..ba8421a 100644
--- a/src/com/google/javascript/rhino/jstype/NamedType.java
+++ b/src/com/google/javascript/rhino/jstype/NamedType.java
@@ -372,8 +372,8 @@
           registry.isForwardDeclaredType(reference);
       boolean beForgiving = forgiving || isForwardDeclared;
       if (!beForgiving && registry.isLastGeneration()) {
-        t.warning("Unknown type " + reference, sourceName, lineno, null,
-            charno);
+        t.warning("Bad type annotation. Unknown type " + reference,
+            sourceName, lineno, null, charno);
       } else {
         if (isForwardDeclared) {
           setReferencedType(
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index f145200..2d2dbca 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -124,6 +124,18 @@
     test("function f(x) { return x; } f();", TypeCheck.WRONG_ARGUMENT_COUNT);
   }
 
+  public void testTypeParsingOffByDefault() {
+    testSame("/** @return {number */ function f(a) { return a; }");
+  }
+
+  public void testTypeParsingOnWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @return {number */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+    test("/** @return {n} */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+  }
+
   public void testTypeCheckOverride1() {
     args.add("--warning_level=VERBOSE");
     args.add("--jscomp_off=checkTypes");
@@ -216,10 +228,10 @@
 
   public void testQuietMode() {
     args.add("--warning_level=DEFAULT");
-    test("/** @type { not a type name } */ var x;",
+    test("/** @const \n * @const */ var x;",
          RhinoErrorReporter.PARSE_ERROR);
     args.add("--warning_level=QUIET");
-    testSame("/** @type { not a type name } */ var x;");
+    testSame("/** @const \n * @const */ var x;");
   }
 
   public void testProcessClosurePrimitives() {
@@ -508,7 +520,7 @@
            "var beer = {}; function f() {}",
            ""
          },
-         RhinoErrorReporter.PARSE_ERROR);
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
   }
 
   public void testSourceMapExpansion1() {
diff --git a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
index caaafbc..19d2c5b 100644
--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
@@ -382,8 +382,8 @@
   }
 
   public void testOptionalArgFunctionParamError() throws Exception {
-    String expectedWarning = "Parse error. variable length argument must be " +
-        "last";
+    String expectedWarning =
+        "Bad type annotation. variable length argument must be last";
     testTypes("/** @param {function(...[number], number=)} a */" +
               "function f(a) {};", expectedWarning, false);
   }
@@ -2734,7 +2734,7 @@
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
-        "Parse error. Unknown type not_base");
+        "Bad type annotation. Unknown type not_base");
   }
 
   public void testBadExtends2() throws Exception {
@@ -2872,7 +2872,7 @@
         " * @implements {nonExistent}\n" +
         " * @implements {Base2}\n" +
         " */ function derived() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadImplements2() throws Exception {
@@ -2891,7 +2891,7 @@
 
   public void testBadInterfaceExtends1() throws Exception {
     testTypes("/** @interface \n * @extends {nonExistent} */function A() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadInterfaceExtends2() throws Exception {
@@ -4779,7 +4779,7 @@
         "/** @type {some.unknown.type} */var f1;" +
         "var f2 = opt_f || f1;" +
         "f2();",
-        "Parse error. Unknown type some.unknown.type");
+        "Bad type annotation. Unknown type some.unknown.type");
   }
 
   public void testCall4() throws Exception {
@@ -4949,36 +4949,36 @@
 
   public void testCast7() throws Exception {
     testTypes("var x = /** @type {foo} */ (new Object());",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast8() throws Exception {
     testTypes("function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast9() throws Exception {
     testTypes("var foo = {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast10() throws Exception {
     testTypes("var foo = function() {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast11() throws Exception {
     testTypes("var goog = {}; goog.foo = {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast12() throws Exception {
     testTypes("var goog = {}; goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast13() throws Exception {
@@ -4988,7 +4988,7 @@
         "goog.addDependency('zzz.js', ['goog.foo'], []);" +
         "goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast14() throws Exception {
@@ -5686,7 +5686,7 @@
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   public void testInheritanceCheck14() throws Exception {
@@ -5696,7 +5696,7 @@
         "goog.Super = function() {};\n" +
         "/** @constructor\n @extends {goog.Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   // TODO(user): We should support this way of declaring properties as it is
@@ -5813,7 +5813,7 @@
         "/** @constructor\n @implements {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
         new String[] {
-          "Parse error. Unknown type Super",
+          "Bad type annotation. Unknown type Super",
           "property foo not defined on any superclass of Sub"
         });
   }
@@ -6393,7 +6393,7 @@
   public void testNoForwardTypeDeclaration() throws Exception {
     testTypes(
         "/** @param {MyType} x */ function f(x) {}",
-        "Parse error. Unknown type MyType");
+        "Bad type annotation. Unknown type MyType");
   }
 
   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index 44d3ad5..97c5139 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -372,8 +372,8 @@
   }
 
   public void testOptionalArgFunctionParamError() throws Exception {
-    String expectedWarning = "Parse error. variable length argument must be " +
-        "last";
+    String expectedWarning =
+        "Bad type annotation. variable length argument must be last";
     testTypes("/** @param {function(...[number], number=)} a */" +
               "function f(a) {};", expectedWarning, false);
   }
@@ -3112,7 +3112,7 @@
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
-        "Parse error. Unknown type not_base");
+        "Bad type annotation. Unknown type not_base");
   }
 
   public void testBadExtends2() throws Exception {
@@ -3144,7 +3144,7 @@
         "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
         "/** @param {Sub} x */ function foo(x) {}" +
         "foo(new Sub2());",
-        "Parse error. Unknown type bad");
+        "Bad type annotation. Unknown type bad");
   }
 
   public void testLateExtends() throws Exception {
@@ -3288,7 +3288,7 @@
         " * @implements {nonExistent}\n" +
         " * @implements {Base2}\n" +
         " */ function derived() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadImplements2() throws Exception {
@@ -3317,7 +3317,7 @@
 
   public void testBadInterfaceExtends1() throws Exception {
     testTypes("/** @interface \n * @extends {nonExistent} */function A() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadInterfaceExtends2() throws Exception {
@@ -5337,7 +5337,7 @@
         "})();" +
         "/** @param {ns.Foo} x */ function f(x) {}" +
         "f(new ns.Foo(true));",
-        "Parse error. Unknown type ns.Foo");
+        "Bad type annotation. Unknown type ns.Foo");
   }
 
   public void testQualifiedNameInference9() throws Exception {
@@ -5630,7 +5630,7 @@
         "/** @type {some.unknown.type} */var f1;" +
         "var f2 = opt_f || f1;" +
         "f2();",
-        "Parse error. Unknown type some.unknown.type");
+        "Bad type annotation. Unknown type some.unknown.type");
   }
 
   public void testCall4() throws Exception {
@@ -5800,36 +5800,36 @@
 
   public void testCast7() throws Exception {
     testTypes("var x = /** @type {foo} */ (new Object());",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast8() throws Exception {
     testTypes("function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast9() throws Exception {
     testTypes("var foo = {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast10() throws Exception {
     testTypes("var foo = function() {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast11() throws Exception {
     testTypes("var goog = {}; goog.foo = {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast12() throws Exception {
     testTypes("var goog = {}; goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast13() throws Exception {
@@ -5839,7 +5839,7 @@
         "goog.addDependency('zzz.js', ['goog.foo'], []);" +
         "goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast14() throws Exception {
@@ -6583,7 +6583,7 @@
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   public void testInheritanceCheck14() throws Exception {
@@ -6593,7 +6593,7 @@
         "goog.Super = function() {};\n" +
         "/** @constructor\n @extends {goog.Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   // TODO(user): We should support this way of declaring properties as it is
@@ -6710,7 +6710,7 @@
         "/** @constructor\n @implements {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
         new String[] {
-          "Parse error. Unknown type Super",
+          "Bad type annotation. Unknown type Super",
           "property foo not defined on any superclass of Sub"
         });
   }
@@ -7381,7 +7381,7 @@
   public void testNoForwardTypeDeclaration() throws Exception {
     testTypes(
         "/** @param {MyType} x */ function f(x) {}",
-        "Parse error. Unknown type MyType");
+        "Bad type annotation. Unknown type MyType");
   }
 
   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {
@@ -8037,7 +8037,7 @@
         "function extend(x, y) {}" +
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends */ ({bar: 1}));",
-        "Parse error. missing object name in @lends tag");
+        "Bad type annotation. missing object name in @lends tag");
   }
 
   public void testLends2() throws Exception {
@@ -8087,7 +8087,7 @@
         "function extend(x, y) {}" +
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));",
-        "Parse error. expected closing }");
+        "Bad type annotation. expected closing }");
   }
 
   public void testLends8() throws Exception {
@@ -8104,8 +8104,8 @@
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
         Lists.newArrayList(
-            "Parse error. expected closing }",
-            "Parse error. missing object name in @lends tag"));
+            "Bad type annotation. expected closing }",
+            "Bad type annotation. missing object name in @lends tag"));
   }
 
   public void testDeclaredNativeTypeEquality() throws Exception {
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index f7dafa8..ae7cd38 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -352,7 +352,7 @@
         "function Foo() {}" +
         "Foo.prototype.bar = 1;" +
         "var x = new Foo();",
-        RhinoErrorReporter.PARSE_ERROR);
+        RhinoErrorReporter.TYPE_PARSE_ERROR);
     ObjectType x = (ObjectType) findNameType("x", globalScope);
     assertEquals("Foo", x.toString());
     assertTrue(x.getImplicitPrototype().hasOwnProperty("bar"));
@@ -367,7 +367,7 @@
         "function Foo() {}" +
         "Foo.prototype = {bar: 1};" +
         "var x = new Foo();",
-        RhinoErrorReporter.PARSE_ERROR);
+        RhinoErrorReporter.TYPE_PARSE_ERROR);
     ObjectType x = (ObjectType) findNameType("x", globalScope);
     assertEquals("Foo", x.toString());
     // Should be true
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index a8b7431..4e541c3 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -127,11 +127,13 @@
   public void testParseNamedTypeError1() throws Exception {
     // To avoid parsing ambiguities, type names must end in a '.' to
     // get the continuation behavior.
-    parse("@type {!goog\n * .Bar} */", "expected closing }");
+    parse("@type {!goog\n * .Bar} */",
+        "Bad type annotation. expected closing }");
   }
 
   public void testParseNamedTypeError2() throws Exception {
-    parse("@type {!goog.\n * Bar\n * .Baz} */", "expected closing }");
+    parse("@type {!goog.\n * Bar\n * .Baz} */",
+        "Bad type annotation. expected closing }");
   }
 
   public void testTypedefType1() throws Exception {
@@ -347,15 +349,18 @@
   }
 
   public void testParseUnionType10() throws Exception {
-    parse("@type {string|}*/", "type not recognized due to syntax error");
+    parse("@type {string|}*/",
+        "Bad type annotation. type not recognized due to syntax error");
   }
 
   public void testParseUnionType11() throws Exception {
-    parse("@type {(string,)}*/", "type not recognized due to syntax error");
+    parse("@type {(string,)}*/",
+        "Bad type annotation. type not recognized due to syntax error");
   }
 
   public void testParseUnionType12() throws Exception {
-    parse("@type {()}*/", "type not recognized due to syntax error");
+    parse("@type {()}*/",
+        "Bad type annotation. type not recognized due to syntax error");
   }
 
   public void testParseUnionType13() throws Exception {
@@ -390,7 +395,7 @@
 
   public void testParseUnionTypeError1() throws Exception {
     parse("@type {(string,|number)} */",
-        "type not recognized due to syntax error");
+        "Bad type annotation. type not recognized due to syntax error");
   }
 
   public void testParseUnknownType1() throws Exception {
@@ -501,25 +506,28 @@
   }
 
   public void testParseFunctionalTypeError1() throws Exception {
-    parse("@type {function number):string}*/", "missing opening (");
+    parse("@type {function number):string}*/",
+        "Bad type annotation. missing opening (");
   }
 
   public void testParseFunctionalTypeError2() throws Exception {
-    parse("@type {function( number}*/", "missing closing )");
+    parse("@type {function( number}*/",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseFunctionalTypeError3() throws Exception {
     parse("@type {function(...[number], string)}*/",
-        "variable length argument must be last");
+        "Bad type annotation. variable length argument must be last");
   }
 
   public void testParseFunctionalTypeError4() throws Exception {
     parse("@type {function(string, ...[number], boolean):string}*/",
-        "variable length argument must be last");
+        "Bad type annotation. variable length argument must be last");
   }
 
   public void testParseFunctionalTypeError5() throws Exception {
-    parse("@type {function (thi:Array)}*/", "missing closing )");
+    parse("@type {function (thi:Array)}*/",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseFunctionalTypeError6() throws Exception {
@@ -528,23 +536,28 @@
   }
 
   public void testParseFunctionalTypeError7() throws Exception {
-    parse("@type {function(...[number)}*/", "missing closing ]");
+    parse("@type {function(...[number)}*/",
+        "Bad type annotation. missing closing ]");
   }
 
   public void testParseFunctionalTypeError8() throws Exception {
-    parse("@type {function(...number])}*/", "missing opening [");
+    parse("@type {function(...number])}*/",
+        "Bad type annotation. missing opening [");
   }
 
   public void testParseFunctionalTypeError9() throws Exception {
-    parse("@type {function (new:Array, this:Object)} */", "missing closing )");
+    parse("@type {function (new:Array, this:Object)} */",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseFunctionalTypeError10() throws Exception {
-    parse("@type {function (this:Array, new:Object)} */", "missing closing )");
+    parse("@type {function (this:Array, new:Object)} */",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseFunctionalTypeError11() throws Exception {
-    parse("@type {function (Array, new:Object)} */", "missing closing )");
+    parse("@type {function (Array, new:Object)} */",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseFunctionalTypeError12() throws Exception {
@@ -565,20 +578,23 @@
   }
 
   public void testParseArrayTypeError1() throws Exception {
-    parse("@type {[number}*/", "missing closing ]");
+    parse("@type {[number}*/",
+        "Bad type annotation. missing closing ]");
   }
 
   public void testParseArrayTypeError2() throws Exception {
-    parse("@type {number]}*/", "expected closing }");
+    parse("@type {number]}*/",
+        "Bad type annotation. expected closing }");
   }
 
   public void testParseArrayTypeError3() throws Exception {
-    parse("@type {[(number,boolean,Object?])]}*/", "missing closing )");
+    parse("@type {[(number,boolean,Object?])]}*/",
+        "Bad type annotation. missing closing )");
   }
 
   public void testParseArrayTypeError4() throws Exception {
     parse("@type {(number,boolean,[Object?)]}*/",
-        "missing closing ]");
+        "Bad type annotation. missing closing ]");
   }
 
   private void testParseType(String type) throws Exception {
@@ -728,7 +744,8 @@
 
   public void testParseThisType3() throws Exception {
     parse("@type {number}\n@this goog.foo.Bar*/",
-        "type annotation incompatible with other annotations");
+        "Bad type annotation. type annotation incompatible " +
+        "with other annotations");
   }
 
   public void testParseThisType4() throws Exception {
@@ -801,15 +818,18 @@
 
   public void testParseParam9() throws Exception {
     parse("@param {...number=} index */",
-        "expected closing }", "expecting a variable name in a @param tag");
+        "Bad type annotation. expected closing }",
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testParseParam10() throws Exception {
-    parse("@param {...number index */", "expected closing }");
+    parse("@param {...number index */",
+        "Bad type annotation. expected closing }");
   }
 
   public void testParseParam11() throws Exception {
-    parse("@param {number= index */", "expected closing }");
+    parse("@param {number= index */",
+        "Bad type annotation. expected closing }");
   }
 
   public void testParseParam12() throws Exception {
@@ -837,7 +857,8 @@
   }
 
   public void testParseParam15() throws Exception {
-    JSDocInfo info = parse("@param {string} [index */", "missing closing ]");
+    JSDocInfo info = parse("@param {string} [index */",
+        "Bad type annotation. missing closing ]");
     assertEquals(1, info.getParameterCount());
     assertTypeEquals(STRING_TYPE, info.getParameterType("index"));
   }
@@ -943,12 +964,12 @@
 
   public void testParseRecordType11() throws Exception {
     parseFull("/** @param {{a : b} n\n*/",
-              "expected closing }");
+              "Bad type annotation. expected closing }");
   }
 
   public void testParseRecordType12() throws Exception {
     parseFull("/** @param {{!hello : hey}} n\n*/",
-              "type not recognized due to syntax error");
+              "Bad type annotation. type not recognized due to syntax error");
   }
 
   public void testParseRecordType13() throws Exception {
@@ -997,27 +1018,27 @@
 
   public void testParseParamError1() throws Exception {
     parseFull("/** @param\n*/",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testParseParamError2() throws Exception {
     parseFull("/** @param {Number}*/",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testParseParamError3() throws Exception {
     parseFull("/** @param {Number}\n*/",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testParseParamError4() throws Exception {
     parseFull("/** @param {Number}\n* * num */",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testParseParamError5() throws Exception {
     parse("@param {number} x \n * @param {string} x */",
-        "duplicate variable name \"x\"");
+        "Bad type annotation. duplicate variable name \"x\"");
   }
 
   public void testParseExtends1() throws Exception {
@@ -1059,7 +1080,8 @@
 
   public void testParseExtends5() throws Exception {
     assertTypeEquals(STRING_OBJECT_TYPE,
-        parse("@extends {String*/", "expected closing }").getBaseType());
+        parse("@extends {String*/",
+              "Bad type annotation. expected closing }").getBaseType());
   }
 
   public void testParseExtends6() throws Exception {
@@ -1079,11 +1101,12 @@
   }
 
   public void testParseExtendsNullable1() throws Exception {
-    parse("@extends {Base?} */", "expected closing }");
+    parse("@extends {Base?} */", "Bad type annotation. expected closing }");
   }
 
   public void testParseExtendsNullable2() throws Exception {
-    parse("@extends Base? */", "expected end of line or comment");
+    parse("@extends Base? */",
+        "Bad type annotation. expected end of line or comment");
   }
 
   public void testParseEnum1() throws Exception {
@@ -1195,25 +1218,27 @@
   }
 
   public void testParseLends3() throws Exception {
-    parse("@lends {name */", "expected closing }");
+    parse("@lends {name */", "Bad type annotation. expected closing }");
   }
 
   public void testParseLends4() throws Exception {
-    parse("@lends {} */", "missing object name in @lends tag");
+    parse("@lends {} */",
+        "Bad type annotation. missing object name in @lends tag");
   }
 
   public void testParseLends5() throws Exception {
-    parse("@lends } */", "missing object name in @lends tag");
+    parse("@lends } */",
+        "Bad type annotation. missing object name in @lends tag");
   }
 
   public void testParseLends6() throws Exception {
     parse("@lends {string} \n * @lends {string} */",
-        "@lends tag incompatible with other annotations");
+        "Bad type annotation. @lends tag incompatible with other annotations");
   }
 
   public void testParseLends7() throws Exception {
     parse("@type {string} \n * @lends {string} */",
-        "@lends tag incompatible with other annotations");
+        "Bad type annotation. @lends tag incompatible with other annotations");
   }
 
   public void testParsePreserve() throws Exception {
@@ -1248,7 +1273,8 @@
 
   public void testParseDefine2() throws Exception {
     assertTypeEquals(STRING_TYPE,
-        parse("@define {string*/", "expected closing }").getType());
+        parse("@define {string*/",
+              "Bad type annotation. expected closing }").getType());
   }
 
   public void testParseDefine3() throws Exception {
@@ -1273,6 +1299,7 @@
 
   public void testParseDefineErrors2() throws Exception {
     parse("@define {string}\n @enum {string} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
@@ -1294,6 +1321,7 @@
 
   public void testParseDefineErrors8() throws Exception {
     parse("@define {string}\n @type string */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
@@ -1310,7 +1338,8 @@
   }
 
   public void testParseOverride2() throws Exception {
-    parse("@override\n@override*/", "extra @override/@inheritDoc tag");
+    parse("@override\n@override*/",
+        "Bad type annotation. extra @override/@inheritDoc tag");
   }
 
   public void testParseInheritDoc1() throws Exception {
@@ -1318,11 +1347,13 @@
   }
 
   public void testParseInheritDoc2() throws Exception {
-    parse("@override\n@inheritDoc*/", "extra @override/@inheritDoc tag");
+    parse("@override\n@inheritDoc*/",
+        "Bad type annotation. extra @override/@inheritDoc tag");
   }
 
   public void testParseInheritDoc3() throws Exception {
-    parse("@inheritDoc\n@inheritDoc*/", "extra @override/@inheritDoc tag");
+    parse("@inheritDoc\n@inheritDoc*/",
+        "Bad type annotation. extra @override/@inheritDoc tag");
   }
 
   public void testParseNoAlias1() throws Exception {
@@ -1650,13 +1681,13 @@
 
   public void testFullRegression1() throws Exception {
     parseFull("/** @param (string,number) foo*/function bar(foo){}",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testFullRegression2() throws Exception {
     parseFull("/** @param {string,number) foo*/function bar(foo){}",
-        "expected closing }",
-        "expecting a variable name in a @param tag");
+        "Bad type annotation. expected closing }",
+        "Bad type annotation. expecting a variable name in a @param tag");
   }
 
   public void testFullRegression3() throws Exception {
@@ -1665,17 +1696,17 @@
 
   public void testBug907488() throws Exception {
     parse("@type {number,null} */",
-        "expected closing }");
+        "Bad type annotation. expected closing }");
   }
 
   public void testBug907494() throws Exception {
     parse("@return {Object,undefined} */",
-        "expected closing }");
+        "Bad type annotation. expected closing }");
   }
 
   public void testBug909468() throws Exception {
     parse("@extends {(x)}*/",
-        "expecting a type name");
+        "Bad type annotation. expecting a type name");
   }
 
   public void testParseInterface() throws Exception {
@@ -1692,7 +1723,7 @@
 
   public void testParseDuplicateImplicitCast() throws Exception {
     parse("@type {string} \n * @implicitCast \n * @implicitCast*/",
-          "extra @implicitCast tag");
+          "Bad type annotation. extra @implicitCast tag");
   }
 
   public void testParseInterfaceDoubled() throws Exception {
@@ -1700,6 +1731,7 @@
         "* @interface\n" +
         "* @interface\n" +
         "*/",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
@@ -1730,25 +1762,26 @@
         "* @implements {Smth}\n" +
         "* @implements {Smth}\n" +
         "*/",
-        "duplicate @implements tag");
+        "Bad type annotation. duplicate @implements tag");
   }
 
   public void testParseImplementsNoName() throws Exception {
     parse("* @implements {} */",
-        "expecting a type name");
+        "Bad type annotation. expecting a type name");
   }
 
   public void testParseImplementsMissingRC() throws Exception {
     parse("* @implements {Smth */",
-        "expected closing }");
+        "Bad type annotation. expected closing }");
   }
 
   public void testParseImplementsNullable1() throws Exception {
-    parse("@implements {Base?} */", "expected closing }");
+    parse("@implements {Base?} */", "Bad type annotation. expected closing }");
   }
 
   public void testParseImplementsNullable2() throws Exception {
-    parse("@implements Base? */", "expected end of line or comment");
+    parse("@implements Base? */",
+        "Bad type annotation. expected end of line or comment");
   }
 
   public void testInterfaceExtends() throws Exception {
@@ -1762,14 +1795,14 @@
 
   public void testBadExtendsWithNullable() throws Exception {
     JSDocInfo jsdoc = parse("@constructor\n * @extends {Object?} */",
-        "expected closing }");
+        "Bad type annotation. expected closing }");
     assertTrue(jsdoc.isConstructor());
     assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType());
   }
 
   public void testBadImplementsWithNullable() throws Exception {
   JSDocInfo jsdoc = parse("@implements {Disposable?}\n * @constructor */",
-      "expected closing }");
+      "Bad type annotation. expected closing }");
     assertTrue(jsdoc.isConstructor());
     assertTypeEquals(registry.createNamedType("Disposable", null, -1, -1),
         jsdoc.getImplementedInterfaces().get(0));
@@ -1777,13 +1810,13 @@
 
   public void testBadTypeDefInterfaceAndConstructor1() throws Exception {
     JSDocInfo jsdoc = parse("@interface\n@constructor*/",
-        "cannot be both an interface and a constructor");
+        "Bad type annotation. cannot be both an interface and a constructor");
     assertTrue(jsdoc.isInterface());
   }
 
   public void testBadTypeDefInterfaceAndConstructor2() throws Exception {
     JSDocInfo jsdoc = parse("@constructor\n@interface*/",
-        "cannot be both an interface and a constructor");
+        "Bad type annotation. cannot be both an interface and a constructor");
     assertTrue(jsdoc.isConstructor());
   }
 
@@ -2181,75 +2214,88 @@
 
   public void testTypeTagConflict1() throws Exception {
     parse("@constructor \n * @constructor */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict2() throws Exception {
     parse("@interface \n * @interface */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict3() throws Exception {
     parse("@constructor \n * @interface */",
-        "cannot be both an interface and a constructor");
+        "Bad type annotation. cannot be both an interface and a constructor");
   }
 
   public void testTypeTagConflict4() throws Exception {
     parse("@interface \n * @constructor */",
-        "cannot be both an interface and a constructor");
+        "Bad type annotation. cannot be both an interface and a constructor");
   }
 
   public void testTypeTagConflict5() throws Exception {
     parse("@interface \n * @type {string} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict6() throws Exception {
     parse("@typedef {string} \n * @type {string} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict7() throws Exception {
     parse("@typedef {string} \n * @constructor */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict8() throws Exception {
     parse("@typedef {string} \n * @return {boolean} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict9() throws Exception {
     parse("@enum {string} \n * @return {boolean} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict10() throws Exception {
     parse("@this {Object} \n * @enum {boolean} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict11() throws Exception {
     parse("@param {Object} x \n * @type {boolean} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict12() throws Exception {
     parse("@typedef {boolean} \n * @param {Object} x */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
   public void testTypeTagConflict13() throws Exception {
     parse("@typedef {boolean} \n * @extends {Object} */",
+        "Bad type annotation. " +
         "type annotation incompatible with other annotations");
   }
 
-  public void testParserWithTemplateTypeNameMisisng() {
-    parse("@template */", "@template tag missing type name");
+  public void testParserWithTemplateTypeNameMissing() {
+    parse("@template */",
+        "Bad type annotation. @template tag missing type name");
   }
 
-  public void testParserWithTemplateTypeNameMissing() {
-    parse("@template T\n@template V */", "@template tag at most once");
+  public void testParserWithTemplateDuplicated() {
+    parse("@template T\n@template V */",
+        "Bad type annotation. @template tag at most once");
   }
 
   public void testWhitelistedNewAnnotations() {
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index 5ec6db7..91b09c4 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -38,6 +38,7 @@
       ScriptRuntime.getMessage0("msg.bad.prop");
 
   private static final String MISSING_GT_MESSAGE =
+      "Bad type annotation. " +
       com.google.javascript.rhino.ScriptRuntime.getMessage0(
           "msg.jsdoc.missing.gt");
 
@@ -503,8 +504,8 @@
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @param {bool!*%E$} */" +
             "C.prototype.say=function(nums) {alert(nums.join(','));};",
-              "expected closing }",
-              "expecting a variable name in a @param tag"));
+            "Bad type annotation. expected closing }",
+            "Bad type annotation. expecting a variable name in a @param tag"));
   }
 
   public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
