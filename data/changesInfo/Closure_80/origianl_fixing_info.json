{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "data/changesInfo/",
  "properties": {
    "trigger.tests": "com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,com.google.javascript.jscomp.NodeUtilTest::testLocalValue1",
    "test.dir": "test",
    "clz.modified": "com.google.javascript.jscomp.NodeUtil",
    "src.dir": "src"
  },
  "timeoutSecond": 300,
  "proj": "Closure",
  "id": "80",
  "workingDir": "../bugs/Closure_80_buggy",
  "buggyCommit": "a2153e7405e09c8fa413a01874c949b8b2bcd32b",
  "inducingCommit": "6a2378d43d1f06344f6418388d45c66fe3466a07",
  "originalCommit": "f95797059bdc7b6c4cfc4960081f0773ec85bbf8",
  "bug_name": "Closure_80", 
  "derive": "defects4j",
  "original_fixing_commit": "58786c3f717fa506280127265cd68fedf17de0a9",
  "buildFiles_changed": false,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/NodeUtil.java",
        "src/com/google/javascript/jscomp/NodeUtil.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:isLabelName:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getInfoForNameNode:[Node nameNode]:JSDocInfo",
            "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isStatementBlock:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isObjectCallMethod:[Node callNode, String methodName]:boolean",
            "com.google.javascript.jscomp.NodeUtil:precedence:[int type]:int",
            "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode, @Nullable AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isStatement:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getStringValue:[Node n]:String"
          ],
          "num": 9
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:isAssociative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getFunctionName:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:getNumberValue:[Node n]:Double",
            "com.google.javascript.jscomp.NodeUtil:isUndefined:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isNumericResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isNull:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:maybeAddFinally:[Node tryNode]:void",
            "com.google.javascript.jscomp.NodeUtil:newHasLocalResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getStringValue:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:isObjectLitKey:[Node node, Node parent]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isBooleanResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void",
            "com.google.javascript.jscomp.NodeUtil:isCommutative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isGetOrSetKey:[Node node]:boolean",
            "com.google.javascript.jscomp.NodeUtil:mayBeString:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isTryCatchNodeContainer:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean",
            "com.google.javascript.jscomp.NodeUtil:tryMergeBlock:[Node block]:boolean"
          ],
          "num": 20
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "152",
            "178",
            "679",
            "680",
            "757",
            "934",
            "1325",
            "1326",
            "1327",
            "1328",
            "1340",
            "1341",
            "1342",
            "1343",
            "1362",
            "1586",
            "1587",
            "1588",
            "2398"
          ],
          "num": 19
        },
        {
          "qualified_names": [
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "757",
            "835",
            "836",
            "837",
            "838",
            "839",
            "840",
            "841",
            "842",
            "1020",
            "1021",
            "1022",
            "1023",
            "1024",
            "1025",
            "1026",
            "1027",
            "1028",
            "1029",
            "1030",
            "1031",
            "1032",
            "1033",
            "1034",
            "1035",
            "1036",
            "1037",
            "1038",
            "1039",
            "1040",
            "1041",
            "1042",
            "1043",
            "1044",
            "1045",
            "1046",
            "1047",
            "1048",
            "1049",
            "1050",
            "1051",
            "1052",
            "1053",
            "1054",
            "1055",
            "1056",
            "1057",
            "1058",
            "1059",
            "1060",
            "1061",
            "1062",
            "1063",
            "1064",
            "1065",
            "1066",
            "1067",
            "1068",
            "1069",
            "1070",
            "1071",
            "1072",
            "1073",
            "1074",
            "1075",
            "1076",
            "1077",
            "1078",
            "1079",
            "1080",
            "1081",
            "1082",
            "1083",
            "1084",
            "1085",
            "1086",
            "1087",
            "1088",
            "1089",
            "1090",
            "1091",
            "1092",
            "1093",
            "1094",
            "1095",
            "1096",
            "1097",
            "1098",
            "1099",
            "1100",
            "1101",
            "1102",
            "1103",
            "1104",
            "1105",
            "1106",
            "1107",
            "1108",
            "1109",
            "1136",
            "1498",
            "1499",
            "1500",
            "1501",
            "1502",
            "1503",
            "1504",
            "1507",
            "1508",
            "1509",
            "1510",
            "1511",
            "1512",
            "1513",
            "1514",
            "1515",
            "1516",
            "1517",
            "1518",
            "1519",
            "1520",
            "1521",
            "1522",
            "1523",
            "1524",
            "1525",
            "1526",
            "1527",
            "1528",
            "1529",
            "1530",
            "1531",
            "1562",
            "1563",
            "1564",
            "1565",
            "1566",
            "1567",
            "1568",
            "1569",
            "1570",
            "1571",
            "1572",
            "1796",
            "1797",
            "1798",
            "1799",
            "1800",
            "1801",
            "1802",
            "1803",
            "1804",
            "1805",
            "1806",
            "1807",
            "1808",
            "1809",
            "1810",
            "1811",
            "1812",
            "1813",
            "1814",
            "1815",
            "1816",
            "1817",
            "1818",
            "1819",
            "2629",
            "2630"
          ],
          "num": 248
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 0ab40b3..1e7a924 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -149,10 +149,18 @@\n   static String getStringValue(Node n) {\n     // TODO(user): Convert constant array, object, and regex literals as well.\n     switch (n.getType()) {\n-      case Token.NAME:\n       case Token.STRING:\n         return n.getString();\n \n+      case Token.NAME:\n+        String name \u003d n.getString();\n+        if (\"undefined\".equals(name)\n+            || \"Infinity\".equals(name)\n+            || \"NaN\".equals(name)) {\n+          return name;\n+        }\n+        break;\n+\n       case Token.NUMBER:\n         double value \u003d n.getDouble();\n         long longValue \u003d (long) value;\n@@ -176,6 +184,76 @@\n   }\n \n   /**\n+   * Gets the value of a node as a Number, or null if it cannot be converted.\n+   * When it returns a non-null Double, this method effectively emulates the\n+   * \u003ccode\u003eNumber()\u003c/code\u003e JavaScript cast function.\n+   */\n+  static Double getNumberValue(Node n) {\n+    switch (n.getType()) {\n+      case Token.TRUE:\n+        return 1.0;\n+\n+      case Token.FALSE:\n+      case Token.NULL:\n+        return 0.0;\n+\n+      case Token.NUMBER:\n+        return n.getDouble();\n+\n+      case Token.VOID:\n+        return Double.NaN;\n+\n+      case Token.NAME:\n+        String name \u003d n.getString();\n+        if (name.equals(\"undefined\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"NaN\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return Double.POSITIVE_INFINITY;\n+        }\n+        return null;\n+\n+      case Token.NEG:\n+        if (n.getChildCount() \u003d\u003d 1 \u0026\u0026 n.getFirstChild().getType() \u003d\u003d Token.NAME\n+            \u0026\u0026 n.getFirstChild().getString().equals(\"Infinity\")) {\n+          return Double.NEGATIVE_INFINITY;\n+        }\n+        return null;\n+\n+      case Token.STRING:\n+        // TODO(johnlenz): handle less common string conversion cases:\n+        // \u0027-infinity\u0027, etc.\n+        String s \u003d n.getString();\n+\n+        if (s.length() \u003d\u003d 0) {\n+          return 0.0;\n+        }\n+\n+        if (s.length() \u003e 2\n+            \u0026\u0026 s.charAt(0) \u003d\u003d \u00270\u0027\n+            \u0026\u0026 (s.charAt(1) \u003d\u003d \u0027x\u0027 || s.charAt(1) \u003d\u003d \u0027X\u0027)) {\n+            // Attempt to convert hex numbers.\n+          try {\n+            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n+          } catch (NumberFormatException e) {\n+            return null;\n+          }\n+        }\n+\n+        try {\n+          return Double.parseDouble(s);\n+        } catch (NumberFormatException e) {\n+          return null;\n+        }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n    * Gets the function\u0027s name. This method recognizes five forms:\n    * \u003cul\u003e\n    * \u003cli\u003e{@code function name() ...}\u003c/li\u003e\n@@ -676,8 +754,7 @@\n    *\n    * @param callNode - function call node\n    */\n-  static boolean functionCallHasSideEffects(\n-      Node callNode) {\n+  static boolean functionCallHasSideEffects(Node callNode) {\n     return functionCallHasSideEffects(callNode, null);\n   }\n \n@@ -755,6 +832,14 @@\n   }\n \n   /**\n+   * @return Whether the new has a local result.\n+   */\n+  static boolean newHasLocalResult(Node n) {\n+    Preconditions.checkState(n.getType() \u003d\u003d Token.NEW);\n+    return n.isOnlyModifiesThisCall();\n+  }\n+\n+  /**\n    * Returns true if the current node\u0027s type implies side effects.\n    *\n    * This is a non-recursive version of the may have side effects\n@@ -932,6 +1017,96 @@\n   }\n \n   /**\n+   * Returns true if the result of node evaluation is always a number\n+   */\n+  static boolean isNumericResult(Node n) {\n+    switch (n.getType()) {\n+      // NOTE: ADD is deliberately excluded as it may produce\n+      // a string.\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.POS:\n+      case Token.NEG:\n+      case Token.NUMBER:\n+        return true;\n+      case Token.NAME:\n+        String name \u003d n.getString();\n+        if (name.equals(\"NaN\")) {\n+          return true;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return true;\n+        }\n+        return false;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the result of node evaluation is always a boolean\n+   */\n+  static boolean isBooleanResult(Node n) {\n+    // TODO(johnlenz): Add a recursive option to recurse into\n+    // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n+    switch (n.getType()) {\n+      // Primitives\n+      case Token.TRUE:\n+      case Token.FALSE:\n+      // Comparisons\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.LT:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.GE:\n+      // Queryies\n+      case Token.IN:\n+      case Token.INSTANCEOF:\n+      // Inversion\n+      case Token.NOT:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  static boolean isUndefined(Node n) {\n+    switch (n.getType()) {\n+      case Token.VOID:\n+        return true;\n+      case Token.NAME:\n+        return n.getString().equals(\"undefined\");\n+    }\n+    return false;\n+  }\n+\n+  static boolean isNull(Node n) {\n+    return n.getType() \u003d\u003d Token.NULL;\n+  }\n+\n+  /**\n+   * @returns Whether the results is possibly a string.\n+   */\n+  static boolean mayBeString(Node n) {\n+    return !isNumericResult(n) \u0026\u0026 !isBooleanResult(n)\n+        \u0026\u0026 !isUndefined(n) \u0026\u0026 !isNull(n);\n+  }\n+\n+  /**\n    * Returns true if the operator is associative.\n    * e.g. (a * b) * c \u003d a * (b * c)\n    * Note: \"+\" is not associative because it is also the concatenation\n@@ -1320,12 +1495,40 @@\n         \u0026\u0026 child \u003d\u003d parent.getLastChild();\n   }\n \n+  /** Whether the node is a CATCH container BLOCK. */\n+  static boolean isTryCatchNodeContainer(Node n) {\n+    Node parent \u003d n.getParent();\n+    return parent.getType() \u003d\u003d Token.TRY\n+        \u0026\u0026 parent.getFirstChild().getNext() \u003d\u003d n;\n+  }\n+\n   /** Safely remove children while maintaining a valid node structure. */\n   static void removeChild(Node parent, Node node) {\n-    // Node parent \u003d node.getParent();\n-    if (isStatementBlock(parent)\n-        || isSwitchCase(node)\n-        || isTryFinallyNode(parent, node)) {\n+    if (isTryFinallyNode(parent, node)) {\n+      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n+        // A finally can only be removed if there is a catch.\n+        parent.removeChild(node);\n+      } else {\n+        // Otherwise only its children can be removed.\n+        node.detachChildren();\n+      }\n+    } else if (node.getType() \u003d\u003d Token.CATCH) {\n+      // The CATCH can can only be removed if there is a finally clause.\n+      Node tryNode \u003d node.getParent().getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachFromParent();\n+    } else if (isTryCatchNodeContainer(node)) {\n+      // The container node itself can\u0027t be removed, but the contained CATCH\n+      // can if there is a \u0027finally\u0027 clause\n+      Node tryNode \u003d node.getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachChildren();\n+    } else if (node.getType() \u003d\u003d Token.BLOCK) {\n+      // Simply empty the block.  This maintains source location and\n+      // \"synthetic\"-ness.\n+      node.detachChildren();\n+    } else if (isStatementBlock(parent)\n+        || isSwitchCase(node)) {\n       // A statement in a block can simply be removed.\n       parent.removeChild(node);\n     } else if (parent.getType() \u003d\u003d Token.VAR) {\n@@ -1337,10 +1540,6 @@\n         // This would leave an empty VAR, remove the VAR itself.\n         removeChild(parent.getParent(), parent);\n       }\n-    } else if (node.getType() \u003d\u003d Token.BLOCK) {\n-      // Simply empty the block.  This maintains source location and\n-      // \"synthetic\"-ness.\n-      node.detachChildren();\n     } else if (parent.getType() \u003d\u003d Token.LABEL\n         \u0026\u0026 node \u003d\u003d parent.getLastChild()) {\n       // Remove the node from the parent, so it can be reused.\n@@ -1360,6 +1559,17 @@\n   }\n \n   /**\n+   * Add a finally block if one does not exist.\n+   */\n+  static void maybeAddFinally(Node tryNode) {\n+    Preconditions.checkState(tryNode.getType() \u003d\u003d Token.TRY);\n+    if (!NodeUtil.hasFinally(tryNode)) {\n+      tryNode.addChildrenToBack(new Node(Token.BLOCK)\n+          .copyInformationFrom(tryNode));\n+    }\n+  }\n+\n+  /**\n    * Merge a block with its parent block.\n    * @return Whether the block was removed.\n    */\n@@ -1583,9 +1793,30 @@\n    * @param parent The node\u0027s parent\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n-    // TODO(nicksantos): What about NUMBER?\n-    return node.getType() \u003d\u003d Token.STRING \u0026\u0026\n-        parent.getType() \u003d\u003d Token.OBJECTLIT;\n+    switch (node.getType()) {\n+      case Token.NUMBER:\n+      case Token.STRING:\n+        return parent.getType() \u003d\u003d Token.OBJECTLIT;\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Determines whether a node represents an object literal get or set key\n+   * (e.g. key1 in {get key1() {}, set key2(a){}).\n+   *\n+   * @param node A node\n+   */\n+  static boolean isGetOrSetKey(Node node) {\n+    switch (node.getType()) {\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n+    return false;\n   }\n \n   /**\n@@ -2395,7 +2626,8 @@\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        return true;\n+        return newHasLocalResult(value)\n+               || locals.apply(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [30550,31436]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [31440,32163]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [32167,32375]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [32379,32452]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [32456,32660]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [6608,6623]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [6632,6823]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [6832,6844]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [6852,6870]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [6979,7004]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [7014,7068]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [7078,7420]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TryStatement [7430,7552]"
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "src/com/google/javascript/jscomp/InlineSimpleMethods.java",
        "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "src/com/google/javascript/jscomp/deps/JsFunctionParser.java"
      ],
      "num": 3
    },
    "delete_classes": {
      "qualified_names": [
        "src/com/google/javascript/jscomp/InlineGetters.java"
      ],
      "num": 1
    },
    "add_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.NodeUtil:isNull:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getFunctionName:[Node n]:String",
        "com.google.javascript.jscomp.NodeUtil:isBooleanResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isNumericResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void",
        "com.google.javascript.jscomp.NodeUtil:isTryCatchNodeContainer:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:tryMergeBlock:[Node block]:boolean",
        "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isCommutative:[int type]:boolean",
        "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode]:boolean",
        "com.google.javascript.jscomp.NodeUtil:newHasLocalResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isObjectLitKey:[Node node, Node parent]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isUndefined:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:mayBeString:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getNumberValue:[Node n]:Double",
        "com.google.javascript.jscomp.NodeUtil:maybeAddFinally:[Node tryNode]:void",
        "com.google.javascript.jscomp.NodeUtil:isGetOrSetKey:[Node node]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isAssociative:[int type]:boolean"
      ],
      "num": 19
    },
    "delete_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.NodeUtil:isObjectCallMethod:[Node callNode, String methodName]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isLabelName:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isStatementBlock:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isStatement:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode, @Nullable AbstractCompiler compiler]:boolean",
        "com.google.javascript.jscomp.NodeUtil:precedence:[int type]:int",
        "com.google.javascript.jscomp.NodeUtil:getInfoForNameNode:[Node nameNode]:JSDocInfo"
      ],
      "num": 8
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.NodeUtilTest",
      "test_function": "testIsBooleanResult",
      "assertion_line": "1504",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    },
    {
      "test_class": "com.google.javascript.jscomp.NodeUtilTest",
      "test_function": "testLocalValue1",
      "assertion_line": "1169",
      "exception": "java.lang.IllegalStateException",
      "message": "Unexpected expression nodeDELPROP 1 [sourcename:  [testcode] ] [parenthesized: true]"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/NodeUtil.java",
        "src/com/google/javascript/jscomp/NodeUtil.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:isBooleanResultHelper:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:isBooleanResultHelper:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1260",
            "2908"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "1261",
            "1262",
            "2911"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 477d444..dfcd3eb 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1258,6 +1258,8 @@\n       case Token.INSTANCEOF:\n       // Inversion\n       case Token.NOT:\n+      // delete operator returns a boolean.\n+      case Token.DELPROP:\n         return true;\n       default:\n         return false;\n@@ -2906,6 +2908,7 @@\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n         return true;\n+      case Token.DELPROP:\n       case Token.IN:\n         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n         return true;\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [37267,37286]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [86078,86097]"
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue(Lcom/google/javascript/rhino/Node;Lcom/google/common/base/Predicate;)Z:regression"
    ],
    "num": 1
  }
}