diff --git a/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java b/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java
new file mode 100644
index 0000000..90af581
--- /dev/null
+++ b/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math.exception;
+
+import java.util.Locale;
+
+import org.apache.commons.math.exception.util.ArgUtils;
+import org.apache.commons.math.exception.util.MessageFactory;
+import org.apache.commons.math.exception.util.Localizable;
+import org.apache.commons.math.exception.util.LocalizedFormats;
+
+/**
+ * Base class for arithmetic exceptions.
+ * It is used for all the exceptions that share the semantics of the standard
+ * {@link ArithmeticException}, but must also provide a localized
+ * message.
+ *
+ * @since 3.0
+ * @version $Revision$ $Date$
+ */
+public class MathArithmeticException extends ArithmeticException {
+
+    /** Serializable version Id. */
+    private static final long serialVersionUID = -6024911025449780478L;
+
+    /**
+     * Pattern used to build the message (specific context).
+     */
+    private final Localizable specific;
+    /**
+     * Arguments used to build the message.
+     */
+    private final Object[] arguments;
+
+    /**
+     * @param args Arguments.
+     */
+    public MathArithmeticException(Object ... args) {
+        this(null, args);
+    }
+    /**
+     * @param specific Message pattern providing the specific context of
+     * the error.
+     * @param args Arguments.
+     */
+    public MathArithmeticException(Localizable specific,
+                                   Object ... args) {
+        this.specific = specific;
+        arguments = ArgUtils.flatten(args);
+    }
+
+    /**
+     * Get the message in a specified locale.
+     *
+     * @param locale Locale in which the message should be translated.
+     *
+     * @return the localized message.
+     */
+    public String getMessage(final Locale locale) {
+        return MessageFactory.buildMessage(locale,
+                                           specific,
+                                           LocalizedFormats.UNSUPPORTED_OPERATION,
+                                           arguments);
+    }
+
+   /** {@inheritDoc} */
+    @Override
+    public String getMessage() {
+        return getMessage(Locale.US);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public String getLocalizedMessage() {
+        return getMessage(Locale.getDefault());
+    }
+}
diff --git a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
index 53d6fdc..ac7f1a9 100644
--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
@@ -112,11 +112,12 @@
     INDEX_LARGER_THAN_MAX("the index specified: {0} is larger than the current maximal index {1}"),
     INDEX_NOT_POSITIVE("index ({0}) is not positive"),
     INDEX_OUT_OF_RANGE("index {0} out of allowed range [{1}, {2}]"),
+    INDEX("index ({0})"), /* keep */
     INFINITE_ARRAY_ELEMENT("Array contains an infinite element, {0} at index {1}"),
     INFINITE_VALUE_CONVERSION("cannot convert infinite value"),
     INITIAL_CAPACITY_NOT_POSITIVE("initial capacity ({0}) is not positive"),
-    INITIAL_COLUMN_AFTER_FINAL_COLUMN("initial column {0} after final column {1}"),
-    INITIAL_ROW_AFTER_FINAL_ROW("initial row {0} after final row {1}"),
+    INITIAL_COLUMN_AFTER_FINAL_COLUMN("initial column {1} after final column {0}"),
+    INITIAL_ROW_AFTER_FINAL_ROW("initial row {1} after final row {0}"),
     INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE("input data comes from unsupported datasource: {0}, supported sources: {1}, {2}"),
     INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES("instance of class {0} not comparable to existing values"),
     INSUFFICIENT_DATA_FOR_T_STATISTIC("insufficient data for t statistic, needs at least 2, got {0}"),
diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java
index c1472b8..53adb3b 100644
--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java
@@ -74,9 +74,8 @@
     public abstract RealMatrix copy();
 
     /** {@inheritDoc} */
-    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {
-
-        // safety check
+    public RealMatrix add(RealMatrix m) {
+        // Safety check.
         MatrixUtils.checkAdditionCompatible(this, m);
 
         final int rowCount    = getRowDimension();
@@ -92,9 +91,8 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {
-
-        // safety check
+    public RealMatrix subtract(final RealMatrix m) {
+        // Safety check.
         MatrixUtils.checkSubtractionCompatible(this, m);
 
         final int rowCount    = getRowDimension();
@@ -111,7 +109,6 @@
 
     /** {@inheritDoc} */
     public RealMatrix scalarAdd(final double d) {
-
         final int rowCount    = getRowDimension();
         final int columnCount = getColumnDimension();
         final RealMatrix out = createMatrix(rowCount, columnCount);
@@ -126,7 +123,6 @@
 
     /** {@inheritDoc} */
     public RealMatrix scalarMultiply(final double d) {
-
         final int rowCount    = getRowDimension();
         final int columnCount = getColumnDimension();
         final RealMatrix out = createMatrix(rowCount, columnCount);
@@ -140,10 +136,8 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix multiply(final RealMatrix m)
-        throws IllegalArgumentException {
-
-        // safety check
+    public RealMatrix multiply(final RealMatrix m) {
+        // Safety check.
         MatrixUtils.checkMultiplicationCompatible(this, m);
 
         final int nRows = getRowDimension();
@@ -164,14 +158,12 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix preMultiply(final RealMatrix m)
-        throws IllegalArgumentException {
+    public RealMatrix preMultiply(final RealMatrix m) {
         return m.multiply(this);
     }
 
     /** {@inheritDoc} */
     public double[][] getData() {
-
         final double[][] data = new double[getRowDimension()][getColumnDimension()];
 
         for (int i = 0; i < data.length; ++i) {
@@ -250,9 +242,7 @@
 
     /** {@inheritDoc} */
     public RealMatrix getSubMatrix(final int startRow, final int endRow,
-                                   final int startColumn, final int endColumn)
-        throws MatrixIndexException {
-
+                                   final int startColumn, final int endColumn) {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
 
         final RealMatrix subMatrix =
@@ -267,9 +257,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns)
-        throws MatrixIndexException {
-
+    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) {
         // safety checks
         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
 
@@ -292,8 +280,7 @@
     /** {@inheritDoc} */
     public void copySubMatrix(final int startRow, final int endRow,
                               final int startColumn, final int endColumn,
-                              final double[][] destination)
-        throws MatrixIndexException, IllegalArgumentException {
+                              final double[][] destination) {
 
         // safety checks
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
@@ -352,9 +339,7 @@
     }
 
     /** {@inheritDoc} */
-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)
-        throws MatrixIndexException {
-
+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {
         final int nRows = subMatrix.length;
         if (nRows == 0) {
             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);
@@ -386,9 +371,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix getRowMatrix(final int row)
-        throws MatrixIndexException {
-
+    public RealMatrix getRowMatrix(final int row) {
         MatrixUtils.checkRowIndex(this, row);
         final int nCols = getColumnDimension();
         final RealMatrix out = createMatrix(1, nCols);
@@ -415,9 +398,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix getColumnMatrix(final int column)
-        throws MatrixIndexException {
-
+    public RealMatrix getColumnMatrix(final int column) {
         MatrixUtils.checkColumnIndex(this, column);
         final int nRows = getRowDimension();
         final RealMatrix out = createMatrix(nRows, 1);
@@ -444,8 +425,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector getRowVector(final int row)
-        throws MatrixIndexException {
+    public RealVector getRowVector(final int row) {
         return new ArrayRealVector(getRow(row), false);
     }
 
@@ -463,8 +443,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector getColumnVector(final int column)
-        throws MatrixIndexException {
+    public RealVector getColumnVector(final int column) {
         return new ArrayRealVector(getColumn(column), false);
     }
 
@@ -482,9 +461,7 @@
     }
 
     /** {@inheritDoc} */
-    public double[] getRow(final int row)
-        throws MatrixIndexException {
-
+    public double[] getRow(final int row) {
         MatrixUtils.checkRowIndex(this, row);
         final int nCols = getColumnDimension();
         final double[] out = new double[nCols];
@@ -508,9 +485,7 @@
     }
 
     /** {@inheritDoc} */
-    public double[] getColumn(final int column)
-        throws MatrixIndexException {
-
+    public double[] getColumn(final int column) {
         MatrixUtils.checkColumnIndex(this, column);
         final int nRows = getRowDimension();
         final double[] out = new double[nRows];
@@ -534,24 +509,19 @@
     }
 
     /** {@inheritDoc} */
-    public abstract double getEntry(int row, int column)
-        throws MatrixIndexException;
+    public abstract double getEntry(int row, int column);
 
     /** {@inheritDoc} */
-    public abstract void setEntry(int row, int column, double value)
-        throws MatrixIndexException;
+    public abstract void setEntry(int row, int column, double value);
 
     /** {@inheritDoc} */
-    public abstract void addToEntry(int row, int column, double increment)
-        throws MatrixIndexException;
+    public abstract void addToEntry(int row, int column, double increment);
 
     /** {@inheritDoc} */
-    public abstract void multiplyEntry(int row, int column, double factor)
-        throws MatrixIndexException;
+    public abstract void multiplyEntry(int row, int column, double factor);
 
     /** {@inheritDoc} */
     public RealMatrix transpose() {
-
         final int nRows = getRowDimension();
         final int nCols = getColumnDimension();
         final RealMatrix out = createMatrix(nCols, nRows);
@@ -750,7 +720,7 @@
     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -769,7 +739,7 @@
     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -816,7 +786,7 @@
     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,
                                     final int startRow, final int endRow,
                                     final int startColumn, final int endColumn)
-    throws MatrixIndexException, MatrixVisitorException {
+    throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -835,7 +805,7 @@
     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,
                                     final int startRow, final int endRow,
                                     final int startColumn, final int endColumn)
-    throws MatrixIndexException, MatrixVisitorException {
+    throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -863,7 +833,7 @@
     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,
                                        final int startRow, final int endRow,
                                        final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
     }
 
@@ -871,7 +841,7 @@
     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,
                                        final int startRow, final int endRow,
                                        final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
     }
 
diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java
index ff6252a..386e2f1 100644
--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java
+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java
@@ -23,6 +23,7 @@
 import org.apache.commons.math.FunctionEvaluationException;
 import org.apache.commons.math.exception.MathUnsupportedOperationException;
 import org.apache.commons.math.exception.DimensionMismatchException;
+import org.apache.commons.math.exception.OutOfRangeException;
 import org.apache.commons.math.analysis.BinaryFunction;
 import org.apache.commons.math.analysis.ComposableFunction;
 import org.apache.commons.math.analysis.UnivariateRealFunction;
@@ -64,26 +65,27 @@
 
     /**
      * Check if an index is valid.
-     * @param index index to check
-     * @exception MatrixIndexException if index is not valid
+     *
+     * @param index Index to check.
+     * @exception OutOfRangeException if {@code index} is not valid.
      */
-    protected void checkIndex(final int index)
-        throws MatrixIndexException {
-        if (index < 0 || index >= getDimension()) {
-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,
-                                           index, 0, getDimension() - 1);
+    protected void checkIndex(final int index) {
+        if (index < 0 ||
+            index >= getDimension()) {
+            throw new OutOfRangeException(LocalizedFormats.INDEX,
+                                          index, 0, getDimension() - 1);
         }
     }
 
     /** {@inheritDoc} */
-    public void setSubVector(int index, RealVector v) throws MatrixIndexException {
+    public void setSubVector(int index, RealVector v) {
         checkIndex(index);
         checkIndex(index + v.getDimension() - 1);
         setSubVector(index, v.getData());
     }
 
     /** {@inheritDoc} */
-    public void setSubVector(int index, double[] v) throws MatrixIndexException {
+    public void setSubVector(int index, double[] v) {
         checkIndex(index);
         checkIndex(index + v.length - 1);
         for (int i = 0; i < v.length; i++) {
@@ -92,7 +94,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector add(double[] v) throws IllegalArgumentException {
+    public RealVector add(double[] v) {
         double[] result = v.clone();
         Iterator<Entry> it = sparseIterator();
         Entry e;
@@ -103,7 +105,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector add(RealVector v) throws IllegalArgumentException {
+    public RealVector add(RealVector v) {
         if (v instanceof ArrayRealVector) {
             double[] values = ((ArrayRealVector)v).getDataRef();
             return add(values);
@@ -119,7 +121,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector subtract(double[] v) throws IllegalArgumentException {
+    public RealVector subtract(double[] v) {
         double[] result = v.clone();
         Iterator<Entry> it = sparseIterator();
         Entry e;
@@ -131,7 +133,7 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector subtract(RealVector v) throws IllegalArgumentException {
+    public RealVector subtract(RealVector v) {
         if (v instanceof ArrayRealVector) {
             double[] values = ((ArrayRealVector)v).getDataRef();
             return add(values);
@@ -167,12 +169,12 @@
     public abstract AbstractRealVector copy();
 
     /** {@inheritDoc} */
-    public double dotProduct(double[] v) throws IllegalArgumentException {
+    public double dotProduct(double[] v) {
         return dotProduct(new ArrayRealVector(v, false));
     }
 
     /** {@inheritDoc} */
-    public double dotProduct(RealVector v) throws IllegalArgumentException {
+    public double dotProduct(RealVector v) {
         checkVectorDimensions(v);
         double d = 0;
         Iterator<Entry> it = sparseIterator();
@@ -184,17 +186,17 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {
+    public RealVector ebeDivide(double[] v) {
         return ebeDivide(new ArrayRealVector(v, false));
     }
 
     /** {@inheritDoc} */
-    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {
+    public RealVector ebeMultiply(double[] v) {
         return ebeMultiply(new ArrayRealVector(v, false));
     }
 
     /** {@inheritDoc} */
-    public double getDistance(RealVector v) throws IllegalArgumentException {
+    public double getDistance(RealVector v) {
         checkVectorDimensions(v);
         double d = 0;
         Iterator<Entry> it = iterator();
@@ -241,12 +243,12 @@
     }
 
     /** {@inheritDoc} */
-    public double getDistance(double[] v) throws IllegalArgumentException {
+    public double getDistance(double[] v) {
         return getDistance(new ArrayRealVector(v,false));
     }
 
     /** {@inheritDoc} */
-    public double getL1Distance(RealVector v) throws IllegalArgumentException {
+    public double getL1Distance(RealVector v) {
         checkVectorDimensions(v);
         double d = 0;
         Iterator<Entry> it = iterator();
@@ -258,7 +260,7 @@
     }
 
     /** {@inheritDoc} */
-    public double getL1Distance(double[] v) throws IllegalArgumentException {
+    public double getL1Distance(double[] v) {
         checkVectorDimensions(v.length);
         double d = 0;
         Iterator<Entry> it = iterator();
@@ -270,7 +272,7 @@
     }
 
     /** {@inheritDoc} */
-    public double getLInfDistance(RealVector v) throws IllegalArgumentException {
+    public double getLInfDistance(RealVector v) {
         checkVectorDimensions(v);
         double d = 0;
         Iterator<Entry> it = iterator();
@@ -282,7 +284,7 @@
     }
 
     /** {@inheritDoc} */
-    public double getLInfDistance(double[] v) throws IllegalArgumentException {
+    public double getLInfDistance(double[] v) {
         checkVectorDimensions(v.length);
         double d = 0;
         Iterator<Entry> it = iterator();
@@ -720,12 +722,14 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {
+    public RealMatrix outerProduct(RealVector v) {
         RealMatrix product;
         if (v instanceof SparseRealVector || this instanceof SparseRealVector) {
-            product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());
+            product = new OpenMapRealMatrix(this.getDimension(),
+                                            v.getDimension());
         } else {
-            product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());
+            product = new Array2DRowRealMatrix(this.getDimension(),
+                                               v.getDimension());
         }
         Iterator<Entry> thisIt = sparseIterator();
         Entry thisE = null;
@@ -743,12 +747,12 @@
     }
 
     /** {@inheritDoc} */
-    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
+    public RealMatrix outerProduct(double[] v) {
         return outerProduct(new ArrayRealVector(v, false));
     }
 
     /** {@inheritDoc} */
-    public RealVector projection(double[] v) throws IllegalArgumentException {
+    public RealVector projection(double[] v) {
         return projection(new ArrayRealVector(v, false));
     }
 
diff --git a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java
index 4ce49e8..c605acc 100644
--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java
@@ -19,7 +19,10 @@
 
 import java.io.Serializable;
 
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.DimensionMismatchException;
+import org.apache.commons.math.exception.NullArgumentException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.MathIllegalStateException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 
 /**
@@ -51,18 +54,15 @@
  * @version $Revision$ $Date$
  */
 public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {
-
-    /** Serializable version identifier */
+    /** Serializable version identifier. */
     private static final long serialVersionUID = -1067294169172445528L;
-
-    /** Entries of the matrix */
+    /** Entries of the matrix. */
     protected double data[][];
 
     /**
      * Creates a matrix with no data
      */
-    public Array2DRowRealMatrix() {
-    }
+    public Array2DRowRealMatrix() {}
 
     /**
      * Create a new RealMatrix with the supplied row and column dimensions.
@@ -99,40 +99,38 @@
     /**
      * Create a new RealMatrix using the input array as the underlying
      * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * RealMatrix and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param d data for new matrix
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
+     * If an array is built specially in order to be embedded in a
+     * RealMatrix and not used directly, the {@code copyArray} may be
+     * set to {@code false}. This will prevent the copying and improve
+     * performance as no new array will be built and no data will be copied.
+     *
+     * @param d Data for new matrix.
+     * @param copyArray if {@code true}, the input array will be copied,
+     * otherwise it will be referenced.
+     * @throws DimensionMismatchException if {@code d} is not rectangular
+     * (not all rows have the same length) or empty.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws ZeroException if there are not at least one row and one column.
      * @see #Array2DRowRealMatrix(double[][])
      */
-    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)
-        throws IllegalArgumentException, NullPointerException {
+    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray) {
         if (copyArray) {
             copyIn(d);
         } else {
             if (d == null) {
-                throw new NullPointerException();
+                throw new NullArgumentException();
             }
             final int nRows = d.length;
             if (nRows == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.AT_LEAST_ONE_ROW);
+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);
             }
             final int nCols = d[0].length;
             if (nCols == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);
+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
             }
             for (int r = 1; r < nRows; r++) {
                 if (d[r].length != nCols) {
-                    throw MathRuntimeException.createIllegalArgumentException(
-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);
+                    throw new DimensionMismatchException(d[r].length, nCols);
                 }
             }
             data = d;
@@ -140,12 +138,12 @@
     }
 
     /**
-     * Create a new (column) RealMatrix using <code>v</code> as the
-     * data for the unique column of the <code>v.length x 1</code> matrix
+     * Create a new (column) RealMatrix using {@code v} as the
+     * data for the unique column of the {@code v.length x 1} matrix
      * created.
-     * <p>The input array is copied, not referenced.</p>
+     * The input array is copied, not referenced.
      *
-     * @param v column vector holding data for new matrix
+     * @param v Column vector holding data for new matrix.
      */
     public Array2DRowRealMatrix(final double[] v) {
         final int nRows = v.length;
@@ -157,8 +155,8 @@
 
     /** {@inheritDoc} */
     @Override
-    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)
-        throws IllegalArgumentException {
+    public RealMatrix createMatrix(final int rowDimension,
+                                   final int columnDimension) {
         return new Array2DRowRealMatrix(rowDimension, columnDimension);
     }
 
@@ -168,28 +166,16 @@
         return new Array2DRowRealMatrix(copyOut(), false);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix add(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return add((Array2DRowRealMatrix) m);
-        } catch (ClassCastException cce) {
-            return super.add(m);
-        }
-    }
-
     /**
-     * Compute the sum of this and <code>m</code>.
+     * Compute the sum of this matrix with {@code m}.
      *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be added.
+     * @return {@code this} + m.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
-    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)
-        throws IllegalArgumentException {
-
-        // safety check
+    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m) {
+        // Safety check.
         MatrixUtils.checkAdditionCompatible(this, m);
 
         final int rowCount    = getRowDimension();
@@ -205,31 +191,18 @@
         }
 
         return new Array2DRowRealMatrix(outData, false);
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix subtract(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return subtract((Array2DRowRealMatrix) m);
-        } catch (ClassCastException cce) {
-            return super.subtract(m);
-        }
     }
 
     /**
-     * Compute  this minus <code>m</code>.
+     * Subtract {@code m} from this matrix.
      *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be subtracted.
+     * @return {@code this} - m.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
-    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)
-        throws IllegalArgumentException {
-
-        // safety check
+    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m) {
+        // Safety check.
         MatrixUtils.checkSubtractionCompatible(this, m);
 
         final int rowCount    = getRowDimension();
@@ -245,31 +218,19 @@
         }
 
         return new Array2DRowRealMatrix(outData, false);
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix multiply(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return multiply((Array2DRowRealMatrix) m);
-        } catch (ClassCastException cce) {
-            return super.multiply(m);
-        }
     }
 
     /**
-     * Returns the result of postmultiplying this by <code>m</code>.
-     * @param m    matrix to postmultiply by
-     * @return     this*m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
+     * Returns the result of postmultiplying this matrix with {@code m}.
+     *
+     * @param m Matrix to postmultiply by.
+     * @return {@code this} * m.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if the column dimension of this matrix is different from the row
+     * dimension of {@code m}.
      */
-    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)
-        throws IllegalArgumentException {
-
-        // safety check
+    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m) {
+        // Safety check.
         MatrixUtils.checkMultiplicationCompatible(this, m);
 
         final int nRows = this.getRowDimension();
@@ -299,11 +260,9 @@
     }
 
     /**
-     * Returns a reference to the underlying data array.
-     * <p>
-     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>
+     * Return a reference to the underlying data array.
      *
-     * @return 2-dimensional array of entries
+     * @return 2-dimensional array of entries.
      */
     public double[][] getDataRef() {
         return data;
@@ -311,33 +270,28 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)
-    throws MatrixIndexException {
+    public void setSubMatrix(final double[][] subMatrix,
+                             final int row, final int column) {
         if (data == null) {
             if (row > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);
+                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);
             }
             if (column > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);
+                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);
             }
             final int nRows = subMatrix.length;
             if (nRows == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.AT_LEAST_ONE_ROW);
+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);
             }
 
             final int nCols = subMatrix[0].length;
             if (nCols == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);
+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
             }
             data = new double[subMatrix.length][nCols];
             for (int i = 0; i < data.length; ++i) {
                 if (subMatrix[i].length != nCols) {
-                    throw MathRuntimeException.createIllegalArgumentException(
-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);
+                    throw new DimensionMismatchException(subMatrix[i].length, nCols);
                 }
                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);
             }
@@ -349,55 +303,35 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getEntry(final int row, final int column)
-        throws MatrixIndexException {
-        try {
-            return data[row][column];
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());
-        }
+    public double getEntry(final int row, final int column) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        return data[row][column];
     }
 
     /** {@inheritDoc} */
     @Override
-    public void setEntry(final int row, final int column, final double value)
-        throws MatrixIndexException {
-        try {
-            data[row][column] = value;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());
-        }
+    public void setEntry(final int row, final int column, final double value) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        data[row][column] = value;
     }
 
     /** {@inheritDoc} */
     @Override
-    public void addToEntry(final int row, final int column, final double increment)
-        throws MatrixIndexException {
-        try {
-            data[row][column] += increment;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());
-        }
+    public void addToEntry(final int row, final int column, final double increment) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        data[row][column] += increment;
     }
 
     /** {@inheritDoc} */
     @Override
-    public void multiplyEntry(final int row, final int column, final double factor)
-        throws MatrixIndexException {
-        try {
-            data[row][column] *= factor;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());
-        }
+    public void multiplyEntry(final int row, final int column, final double factor) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        data[row][column] *= factor;
     }
 
     /** {@inheritDoc} */
     @Override
-    public int getRowDimension() {
+        public int getRowDimension() {
         return (data == null) ? 0 : data.length;
     }
 
@@ -409,13 +343,11 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] operate(final double[] v)
-        throws IllegalArgumentException {
+    public double[] operate(final double[] v) {
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
         if (v.length != nCols) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nCols);
+            throw new DimensionMismatchException(v.length, nCols);
         }
         final double[] out = new double[nRows];
         for (int row = 0; row < nRows; row++) {
@@ -431,14 +363,11 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] preMultiply(final double[] v)
-        throws IllegalArgumentException {
-
+    public double[] preMultiply(final double[] v) {
         final int nRows = getRowDimension();
         final int nCols = getColumnDimension();
         if (v.length != nRows) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nRows);
+            throw new DimensionMismatchException(v.length, nRows);
         }
 
         final double[] out = new double[nCols];
@@ -491,7 +420,7 @@
     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -509,7 +438,7 @@
     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -558,7 +487,7 @@
     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,
                                     final int startRow, final int endRow,
                                     final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
@@ -576,7 +505,7 @@
     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,
                                     final int startRow, final int endRow,
                                     final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(getRowDimension(), getColumnDimension(),
                       startRow, endRow, startColumn, endColumn);
diff --git a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
index 69cf176..e081931 100644
--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
@@ -22,7 +22,11 @@
 
 import org.apache.commons.math.Field;
 import org.apache.commons.math.FieldElement;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.NullArgumentException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.DimensionMismatchException;
+import org.apache.commons.math.exception.NumberIsTooLargeException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 
 /**
@@ -32,24 +36,22 @@
  * @since 2.0
  */
 public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {
-
     /** Serializable version identifier. */
     private static final long serialVersionUID = 7648186910365927050L;
-
     /** Entries of the vector. */
     protected T[] data;
-
     /** Field to which the elements belong. */
     private final Field<T> field;
 
     /**
      * Build a 0-length vector.
-     * <p>Zero-length vectors may be used to initialized construction of vectors
+     * Zero-length vectors may be used to initialized construction of vectors
      * by data gathering. We start with zero-length and use either the {@link
      * #ArrayFieldVector(ArrayFieldVector, ArrayFieldVector)} constructor
-     * or one of the <code>append</code> methods ({@link #append(FieldElement[])},
+     * or one of the {@code append} methods ({@link #append(FieldElement[])},
      * {@link #add(FieldVector)}, {@link #append(ArrayFieldVector)}) to gather data
-     * into this vector.</p>
+     * into this vector.
+     *
      * @param field field to which the elements belong
      */
     public ArrayFieldVector(final Field<T> field) {
@@ -57,9 +59,10 @@
     }
 
     /**
-     * Construct a (size)-length vector of zeros.
-     * @param field field to which the elements belong
-     * @param size size of the vector
+     * Construct a vector of zeroes.
+     *
+     * @param field Field to which the elements belong.
+     * @param size Size of the vector.
      */
     public ArrayFieldVector(Field<T> field, int size) {
         this.field = field;
@@ -68,9 +71,10 @@
     }
 
     /**
-     * Construct an (size)-length vector with preset values.
-     * @param size size of the vector
-     * @param preset fill the vector with this scalar value
+     * Construct a vector with preset values.
+     *
+     * @param size Size of the vector.
+     * @param preset All entries will be set with this value.
      */
     public ArrayFieldVector(int size, T preset) {
         this(preset.getField(), size);
@@ -79,34 +83,40 @@
 
     /**
      * Construct a vector from an array, copying the input array.
-     * <p>
      * This constructor needs a non-empty {@code d} array to retrieve
      * the field from its first element. This implies it cannot build
      * 0 length vectors. To build vectors from any size, one should
      * use the {@link #ArrayFieldVector(Field, FieldElement[])} constructor.
-     * </p>
-     * @param d array of Ts.
-     * @throws IllegalArgumentException if <code>d</code> is empty
+     *
+     * @param d Array.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws ZeroException if {@code d} is empty.
      * @see #ArrayFieldVector(Field, FieldElement[])
      */
-    public ArrayFieldVector(T[] d)
-        throws IllegalArgumentException {
+    public ArrayFieldVector(T[] d) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         try {
             field = d[0].getField();
             data = d.clone();
         } catch (ArrayIndexOutOfBoundsException e) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
         }
     }
 
     /**
      * Construct a vector from an array, copying the input array.
-     * @param field field to which the elements belong
-     * @param d array of Ts.
+     *
+     * @param field Field to which the elements belong.
+     * @param d Array.
+     * @throws NullArgumentException if {@code d} is {@code null}.
      * @see #ArrayFieldVector(FieldElement[])
      */
     public ArrayFieldVector(Field<T> field, T[] d) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         this.field = field;
         data = d.clone();
     }
@@ -114,29 +124,30 @@
     /**
      * Create a new ArrayFieldVector using the input array as the underlying
      * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * <p>
+     * If an array is built specially in order to be embedded in a
+     * ArrayFieldVector and not used directly, the {@code copyArray} may be
+     * set to {@code false}. This will prevent the copying and improve
+     * performance as no new array will be built and no data will be copied.
      * This constructor needs a non-empty {@code d} array to retrieve
      * the field from its first element. This implies it cannot build
      * 0 length vectors. To build vectors from any size, one should
-     * use the {@link #ArrayFieldVector(Field, FieldElement[], boolean)} constructor.
-     * </p>
-     * @param d data for new vector
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
-     * @throws IllegalArgumentException if <code>d</code> is empty
-     * @throws NullPointerException if <code>d</code> is null
+     * use the {@link #ArrayFieldVector(Field, FieldElement[], boolean)}
+     * constructor.
+     *
+     * @param d Data for the new vector.
+     * @param copyArray If {@code true}, the input array will be copied,
+     * otherwise it will be referenced.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws ZeroException if {@code d} is empty.
      * @see #ArrayFieldVector(FieldElement[])
      * @see #ArrayFieldVector(Field, FieldElement[], boolean)
      */
-    public ArrayFieldVector(T[] d, boolean copyArray)
-        throws NullPointerException, IllegalArgumentException {
+    public ArrayFieldVector(T[] d, boolean copyArray) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         if (d.length == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
         }
         field = d[0].getField();
         data = copyArray ? d.clone() :  d;
@@ -145,32 +156,42 @@
     /**
      * Create a new ArrayFieldVector using the input array as the underlying
      * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param field field to which the elements belong
-     * @param d data for new vector
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
+     * If an array is built specially in order to be embedded in a
+     * ArrayFieldVector and not used directly, the {@code copyArray} may be
+     * set to {@code false}. This will prevent the copying and improve
+     * performance as no new array will be built and no data will be copied.
+     *
+     * @param field Field to which the elements belong.
+     * @param d Data for the new vector.
+     * @param copyArray If {@code true}, the input array will be copied,
+     * otherwise it will be referenced.
+     * @throws NullArgumentException if {@code d} is {@code null}.
      * @see #ArrayFieldVector(FieldElement[], boolean)
      */
     public ArrayFieldVector(Field<T> field, T[] d, boolean copyArray) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         this.field = field;
         data = copyArray ? d.clone() :  d;
     }
 
     /**
      * Construct a vector from part of a array.
-     * @param d array of Ts.
-     * @param pos position of first entry
-     * @param size number of entries to copy
+     *
+     * @param d Array.
+     * @param pos Position of the first entry.
+     * @param size Number of entries to copy.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws NumberIsTooLargeException if the size of {@code d} is less
+     * than {@code pos + size}.
      */
     public ArrayFieldVector(T[] d, int pos, int size) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         if (d.length < pos + size) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY,
-                    pos, size, d.length);
+            throw new NumberIsTooLargeException(pos + size, d.length, true);
         }
         field = d[0].getField();
         data = buildArray(size);
@@ -179,9 +200,14 @@
 
     /**
      * Construct a vector from another vector, using a deep copy.
-     * @param v vector to copy
+     *
+     * @param v Vector to copy.
+     * @throws NullArgumentException if {@code v} is {@code null}.
      */
     public ArrayFieldVector(FieldVector<T> v) {
+        if (v == null) {
+            throw new NullArgumentException();
+        }
         field = v.getField();
         data = buildArray(v.getDimension());
         for (int i = 0; i < data.length; ++i) {
@@ -191,29 +217,47 @@
 
     /**
      * Construct a vector from another vector, using a deep copy.
-     * @param v vector to copy
+     *
+     * @param v Vector to copy.
+     * @throws NullArgumentException if {@code v} is {@code null}.
      */
     public ArrayFieldVector(ArrayFieldVector<T> v) {
+        if (v == null) {
+            throw new NullArgumentException();
+        }
         field = v.getField();
         data = v.data.clone();
     }
 
     /**
      * Construct a vector from another vector.
-     * @param v vector to copy
-     * @param deep if true perform a deep copy otherwise perform a shallow copy
+     *
+     * @param v Vector to copy.
+     * @param deep If {@code true} perform a deep copy, otherwise perform
+     * a shallow copy
+     * @throws NullArgumentException if {@code v} is {@code null}.
      */
     public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep) {
+        if (v == null) {
+            throw new NullArgumentException();
+        }
         field = v.getField();
         data = deep ? v.data.clone() : v.data;
     }
 
     /**
      * Construct a vector by appending one vector to another vector.
-     * @param v1 first vector (will be put in front of the new vector)
-     * @param v2 second vector (will be put at back of the new vector)
+     *
+     * @param v1 First vector (will be put in front of the new vector).
+     * @param v2 Second vector (will be put at back of the new vector).
+     * @throws NullArgumentException if {@code v1} or {@code v2} is
+     * {@code null}.
      */
     public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2) {
+        if (v1 == null ||
+            v2 == null) {
+            throw new NullArgumentException();
+        }
         field = v1.getField();
         data = buildArray(v1.data.length + v2.data.length);
         System.arraycopy(v1.data, 0, data, 0, v1.data.length);
@@ -222,10 +266,17 @@
 
     /**
      * Construct a vector by appending one vector to another vector.
-     * @param v1 first vector (will be put in front of the new vector)
-     * @param v2 second vector (will be put at back of the new vector)
+     *
+     * @param v1 First vector (will be put in front of the new vector).
+     * @param v2 Second vector (will be put at back of the new vector).
+     * @throws NullArgumentException if {@code v1} or {@code v2} is
+     * {@code null}.
      */
     public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2) {
+        if (v1 == null ||
+            v2 == null) {
+            throw new NullArgumentException();
+        }
         field = v1.getField();
         data = buildArray(v1.data.length + v2.length);
         System.arraycopy(v1.data, 0, data, 0, v1.data.length);
@@ -234,10 +285,17 @@
 
     /**
      * Construct a vector by appending one vector to another vector.
-     * @param v1 first vector (will be put in front of the new vector)
-     * @param v2 second vector (will be put at back of the new vector)
+     *
+     * @param v1 First vector (will be put in front of the new vector).
+     * @param v2 Second vector (will be put at back of the new vector).
+     * @throws NullArgumentException if {@code v1} or {@code v2} is
+     * {@code null}.
      */
     public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2) {
+        if (v1 == null ||
+            v2 == null) {
+            throw new NullArgumentException();
+        }
         field = v2.getField();
         data = buildArray(v1.length + v2.data.length);
         System.arraycopy(v1, 0, data, 0, v1.length);
@@ -246,40 +304,47 @@
 
     /**
      * Construct a vector by appending one vector to another vector.
-     * <p>
      * This constructor needs at least one non-empty array to retrieve
      * the field from its first element. This implies it cannot build
      * 0 length vectors. To build vectors from any size, one should
-     * use the {@link #ArrayFieldVector(Field, FieldElement[], FieldElement[])} constructor.
-     * </p>
-     * @param v1 first vector (will be put in front of the new vector)
-     * @param v2 second vector (will be put at back of the new vector)
-     * @exception IllegalArgumentException if both vectors are empty
+     * use the {@link #ArrayFieldVector(Field, FieldElement[], FieldElement[])}
+     * constructor.
+     *
+     * @param v1 First vector (will be put in front of the new vector).
+     * @param v2 Second vector (will be put at back of the new vector).
+     * @throws NullArgumentException if {@code v1} or {@code v2} is
+     * {@code null}.
+     * @throws ZeroException if both arrays are empty.
      * @see #ArrayFieldVector(Field, FieldElement[], FieldElement[])
      */
     public ArrayFieldVector(T[] v1, T[] v2) {
-        try {
-            data = buildArray(v1.length + v2.length);
-            System.arraycopy(v1, 0, data, 0, v1.length);
-            System.arraycopy(v2, 0, data, v1.length, v2.length);
-            field = data[0].getField();
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+        if (v1 == null ||
+            v2 == null) {
+            throw new NullArgumentException();
         }
+        if (v1.length + v2.length == 0) {
+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+        }
+        data = buildArray(v1.length + v2.length);
+        System.arraycopy(v1, 0, data, 0, v1.length);
+        System.arraycopy(v2, 0, data, v1.length, v2.length);
+        field = data[0].getField();
     }
 
     /**
      * Construct a vector by appending one vector to another vector.
-     * @param field field to which the elements belong
-     * @param v1 first vector (will be put in front of the new vector)
-     * @param v2 second vector (will be put at back of the new vector)
+     *
+     * @param field Field to which the elements belong.
+     * @param v1 First vector (will be put in front of the new vector).
+     * @param v2 Second vector (will be put at back of the new vector).
+     * @throws NullArgumentException if {@code v1} or {@code v2} is
+     * {@code null}.
+     * @throws ZeroException if both arrays are empty.
      * @see #ArrayFieldVector(FieldElement[], FieldElement[])
      */
     public ArrayFieldVector(Field<T> field, T[] v1, T[] v2) {
         if (v1.length + v2.length == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
         }
         data = buildArray(v1.length + v2.length);
         System.arraycopy(v1, 0, data, 0, v1.length);
@@ -287,9 +352,11 @@
         this.field = data[0].getField();
     }
 
-    /** Build an array of elements.
-     * @param length size of the array to build
-     * @return a new array
+    /**
+     * Build an array of elements.
+     *
+     * @param length Size of the array to build.
+     * @return a new array.
      */
     @SuppressWarnings("unchecked") // field is of type T
     private T[] buildArray(final int length) {
@@ -307,7 +374,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {
+    public FieldVector<T> add(FieldVector<T> v) {
         try {
             return add((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -321,7 +388,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> add(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> add(T[] v) {
         checkVectorDimensions(v.length);
         T[] out = buildArray(data.length);
         for (int i = 0; i < data.length; i++) {
@@ -336,13 +403,12 @@
      * @return this + v
      * @throws IllegalArgumentException if v is not the same size as this
      */
-    public ArrayFieldVector<T> add(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public ArrayFieldVector<T> add(ArrayFieldVector<T> v) {
         return (ArrayFieldVector<T>) add(v.data);
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {
+    public FieldVector<T> subtract(FieldVector<T> v) {
         try {
             return subtract((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -356,7 +422,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> subtract(T[] v) {
         checkVectorDimensions(v.length);
         T[] out = buildArray(data.length);
         for (int i = 0; i < data.length; i++) {
@@ -371,8 +437,7 @@
      * @return this + v
      * @throws IllegalArgumentException if v is not the same size as this
      */
-    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v) {
         return (ArrayFieldVector<T>) subtract(v.data);
     }
 
@@ -464,8 +529,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeMultiply(FieldVector<T> v)
-        throws IllegalArgumentException {
+    public FieldVector<T> ebeMultiply(FieldVector<T> v) {
         try {
             return ebeMultiply((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -479,8 +543,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeMultiply(T[] v)
-        throws IllegalArgumentException {
+    public FieldVector<T> ebeMultiply(T[] v) {
         checkVectorDimensions(v.length);
         T[] out = buildArray(data.length);
         for (int i = 0; i < data.length; i++) {
@@ -495,14 +558,12 @@
      * @return a vector containing this[i] * v[i] for all i
      * @exception IllegalArgumentException if v is not the same size as this
      */
-    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v) {
         return (ArrayFieldVector<T>) ebeMultiply(v.data);
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeDivide(FieldVector<T> v)
-        throws IllegalArgumentException {
+    public FieldVector<T> ebeDivide(FieldVector<T> v) {
         try {
             return ebeDivide((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -516,8 +577,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeDivide(T[] v)
-        throws IllegalArgumentException {
+    public FieldVector<T> ebeDivide(T[] v) {
         checkVectorDimensions(v.length);
         T[] out = buildArray(data.length);
         for (int i = 0; i < data.length; i++) {
@@ -532,8 +592,7 @@
      * @return a vector containing this[i] / v[i] for all i
      * @throws IllegalArgumentException if v is not the same size as this
      */
-    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v) {
         return (ArrayFieldVector<T>) ebeDivide(v.data);
     }
 
@@ -552,8 +611,7 @@
     }
 
     /** {@inheritDoc} */
-    public T dotProduct(FieldVector<T> v)
-        throws IllegalArgumentException {
+    public T dotProduct(FieldVector<T> v) {
         try {
             return dotProduct((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -567,8 +625,7 @@
     }
 
     /** {@inheritDoc} */
-    public T dotProduct(T[] v)
-        throws IllegalArgumentException {
+    public T dotProduct(T[] v) {
         checkVectorDimensions(v.length);
         T dot = field.getZero();
         for (int i = 0; i < data.length; i++) {
@@ -583,8 +640,7 @@
      * @return the scalar dot product between instance and v
      * @exception IllegalArgumentException if v is not the same size as this
      */
-    public T dotProduct(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public T dotProduct(ArrayFieldVector<T> v) {
         return dotProduct(v.data);
     }
 
@@ -608,8 +664,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldMatrix<T> outerProduct(FieldVector<T> v)
-        throws IllegalArgumentException {
+    public FieldMatrix<T> outerProduct(FieldVector<T> v) {
         try {
             return outerProduct((ArrayFieldVector<T>) v);
         } catch (ClassCastException cce) {
@@ -631,14 +686,12 @@
      * @return the square matrix outer product between instance and v
      * @exception IllegalArgumentException if v is not the same size as this
      */
-    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)
-        throws IllegalArgumentException {
+    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {
         return outerProduct(v.data);
     }
 
     /** {@inheritDoc} */
-    public FieldMatrix<T> outerProduct(T[] v)
-        throws IllegalArgumentException {
+    public FieldMatrix<T> outerProduct(T[] v) {
         checkVectorDimensions(v.length);
         final int m = data.length;
         final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);
@@ -651,7 +704,7 @@
     }
 
     /** {@inheritDoc} */
-    public T getEntry(int index) throws MatrixIndexException {
+    public T getEntry(int index) {
         return data[index];
     }
 
@@ -743,11 +796,10 @@
      *
      * @param index index of first element to be set.
      * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
+     * @throws OutOfRangeException if the index is
      * inconsistent with vector size
      */
-    public void set(int index, ArrayFieldVector<T> v)
-        throws MatrixIndexException {
+    public void set(int index, ArrayFieldVector<T> v) {
         setSubVector(index, v.data);
     }
 
@@ -767,76 +819,56 @@
      * @exception IllegalArgumentException if the vectors do not
      * have the same dimension
      */
-    protected void checkVectorDimensions(FieldVector<T> v)
-        throws IllegalArgumentException {
+    protected void checkVectorDimensions(FieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
     }
 
     /**
      * Check if instance dimension is equal to some expected value.
      *
-     * @param n expected dimension.
-     * @exception IllegalArgumentException if the dimension is
-     * inconsistent with vector size
+     * @param n Expected dimension.
+     * @throws OutOfRangeException if the dimension is
+     * inconsistent with this vector size.
      */
-    protected void checkVectorDimensions(int n)
-        throws IllegalArgumentException {
+    protected void checkVectorDimensions(int n) {
         if (data.length != n) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    data.length, n);
+            throw new DimensionMismatchException(data.length, n);
         }
     }
 
     /**
-     * Test for the equality of two real vectors.
-     * <p>
-     * If all coordinates of two real vectors are exactly the same, and none are
-     * <code>Double.NaN</code>, the two real vectors are considered to be equal.
-     * </p>
-     * <p>
-     * <code>NaN</code> coordinates are considered to affect globally the vector
-     * and be equals to each other - i.e, if either (or all) coordinates of the
-     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
-     * a vector with all <code>Double.NaN</code> coordinates.
-     * </p>
+     * Test for the equality of two vectors.
      *
-     * @param other Object to test for equality to this
-     * @return true if two 3D vector objects are equal, false if
-     *         object is null, not an instance of Vector3D, or
-     *         not equal to this Vector3D instance
-     *
+     * @param other Object to test for equality.
+     * @return {@code true} if two vector objects are equal, {@code false}
+     * otherwise.
      */
     @Override
     public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (other == null) {
+            return false;
+        }
 
-      if (this == other) {
-        return true;
-      }
+        try {
+            @SuppressWarnings("unchecked") // May fail, but we ignore ClassCastException
+                FieldVector<T> rhs = (FieldVector<T>) other;
+            if (data.length != rhs.getDimension()) {
+                return false;
+            }
 
-      if (other == null) {
-        return false;
-      }
-
-      try {
-          @SuppressWarnings("unchecked") // May fail, but we ignore ClassCastException
-          FieldVector<T> rhs = (FieldVector<T>) other;
-          if (data.length != rhs.getDimension()) {
-              return false;
-          }
-
-          for (int i = 0; i < data.length; ++i) {
-              if (!data[i].equals(rhs.getEntry(i))) {
-                  return false;
-              }
-          }
-          return true;
-
-      } catch (ClassCastException ex) {
-          // ignore exception
-          return false;
-      }
-
+            for (int i = 0; i < data.length; ++i) {
+                if (!data[i].equals(rhs.getEntry(i))) {
+                    return false;
+                }
+            }
+            return true;
+        } catch (ClassCastException ex) {
+            // ignore exception
+            return false;
+        }
     }
 
     /**
@@ -855,15 +887,14 @@
 
     /**
      * Check if an index is valid.
-     * @param index index to check
-     * @exception MatrixIndexException if index is not valid
+     *
+     * @param index Index to check.
+     * @exception OutOfRangeException if the index is not valid.
      */
-    private void checkIndex(final int index)
-        throws MatrixIndexException {
+    private void checkIndex(final int index) {
         if (index < 0 || index >= getDimension()) {
-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,
-                                           index, 0, getDimension() - 1);
+            throw new OutOfRangeException(LocalizedFormats.INDEX,
+                                          index, 0, getDimension() - 1);
         }
     }
-
 }
diff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java
index 903fc42..18f8da0 100644
--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java
+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java
@@ -20,7 +20,10 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NullArgumentException;
+import org.apache.commons.math.exception.DimensionMismatchException;
+import org.apache.commons.math.exception.NumberIsTooLargeException;
+import org.apache.commons.math.exception.MathArithmeticException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
@@ -31,42 +34,41 @@
  * @since 2.0
  */
 public class ArrayRealVector extends AbstractRealVector implements Serializable {
-
     /** Serializable version identifier. */
     private static final long serialVersionUID = -1097961340710804027L;
-
     /** Default format. */
     private static final RealVectorFormat DEFAULT_FORMAT =
         RealVectorFormat.getInstance();
-
     /** Entries of the vector. */
     protected double data[];
 
     /**
      * Build a 0-length vector.
-     * <p>Zero-length vectors may be used to initialized construction of vectors
+     * Zero-length vectors may be used to initialized construction of vectors
      * by data gathering. We start with zero-length and use either the {@link
      * #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor
-     * or one of the <code>append</code> method ({@link #append(double)}, {@link
+     * or one of the {@code append} method ({@link #append(double)}, {@link
      * #append(double[])}, {@link #append(ArrayRealVector)}) to gather data
-     * into this vector.</p>
+     * into this vector.
      */
     public ArrayRealVector() {
         data = new double[0];
     }
 
     /**
-     * Construct a (size)-length vector of zeros.
-     * @param size size of the vector
+     * Construct a vector of zeroes.
+     *
+     * @param size Size of the vector.
      */
     public ArrayRealVector(int size) {
         data = new double[size];
     }
 
     /**
-     * Construct an (size)-length vector with preset values.
-     * @param size size of the vector
-     * @param preset fill the vector with this scalar value
+     * Construct a vector with preset values.
+     *
+     * @param size Size of the vector
+     * @param preset All entries will be set with this value.
      */
     public ArrayRealVector(int size, double preset) {
         data = new double[size];
@@ -75,7 +77,9 @@
 
     /**
      * Construct a vector from an array, copying the input array.
-     * @param d array of doubles.
+     *
+     * @param d Array.
+     * @throws NullArgumentException if {@code d} is {@code null}.
      */
     public ArrayRealVector(double[] d) {
         data = d.clone();
@@ -84,29 +88,40 @@
     /**
      * Create a new ArrayRealVector using the input array as the underlying
      * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * ArrayRealVector and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param d data for new vector
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
+     * If an array is built specially in order to be embedded in a
+     * ArrayRealVector and not used directly, the {@code copyArray} may be
+     * set to {@code false}. This will prevent the copying and improve
+     * performance as no new array will be built and no data will be copied.
+     *
+     * @param d Data for the new vector.
+     * @param copyArray if {@code true}, the input array will be copied,
+     * otherwise it will be referenced.
+     * @throws NullArgumentException if {@code d} is {@code null}.
      * @see #ArrayRealVector(double[])
      */
     public ArrayRealVector(double[] d, boolean copyArray) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         data = copyArray ? d.clone() :  d;
     }
 
     /**
      * Construct a vector from part of a array.
-     * @param d array of doubles.
-     * @param pos position of first entry
-     * @param size number of entries to copy
+     *
+     * @param d Array.
+     * @param pos Position of first entry.
+     * @param size Number of entries to copy.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws NumberIsTooLargeException if the size of {@code d} is less
+     * than {@code pos + size}.
      */
     public ArrayRealVector(double[] d, int pos, int size) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         if (d.length < pos + size) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);
+            throw new NumberIsTooLargeException(pos + size, d.length, true);
         }
         data = new double[size];
         System.arraycopy(d, pos, data, 0, size);
@@ -124,27 +139,38 @@
     }
 
     /**
-     * Construct a vector from part of a Double array
-     * @param d array of Doubles.
-     * @param pos position of first entry
-     * @param size number of entries to copy
+     * Construct a vector from part of an array.
+     *
+     * @param d Array.
+     * @param pos Position of first entry.
+     * @param size Number of entries to copy.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws NumberIsTooLargeException if the size of {@code d} is less
+     * than {@code pos + size}.
      */
     public ArrayRealVector(Double[] d, int pos, int size) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
         if (d.length < pos + size) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);
+            throw new NumberIsTooLargeException(pos + size, d.length, true);
         }
         data = new double[size];
         for (int i = pos; i < pos + size; i++) {
-            data[i-pos] = d[i].doubleValue();
+            data[i - pos] = d[i].doubleValue();
         }
     }
 
     /**
      * Construct a vector from another vector, using a deep copy.
-     * @param v vector to copy
+     *
+     * @param v vector to copy.
+     * @throws NullArgumentException if {@code v} is {@code null}.
      */
     public ArrayRealVector(RealVector v) {
+        if (v == null) {
+            throw new NullArgumentException();
+        }
         data = new double[v.getDimension()];
         for (int i = 0; i < data.length; ++i) {
             data[i] = v.getEntry(i);
@@ -153,7 +179,9 @@
 
     /**
      * Construct a vector from another vector, using a deep copy.
-     * @param v vector to copy
+     *
+     * @param v Vector to copy.
+     * @throws NullArgumentException if {@code v} is {@code null}.
      */
     public ArrayRealVector(ArrayRealVector v) {
         this(v, true);
@@ -161,8 +189,10 @@
 
     /**
      * Construct a vector from another vector.
-     * @param v vector to copy
-     * @param deep if true perform a deep copy otherwise perform a shallow copy
+     *
+     * @param v Vector to copy.
+     * @param deep If {@code true} perform a deep copy, otherwise perform a
+     * shallow copy.
      */
     public ArrayRealVector(ArrayRealVector v, boolean deep) {
         data = deep ? v.data.clone() : v.data;
@@ -711,12 +741,13 @@
 
     /**
      * Compute the dot product.
-     * @param v vector with which dot product should be computed
-     * @return the scalar dot product between instance and v
-     * @exception IllegalArgumentException if v is not the same size as this
+     *
+     * @param v Vector with which dot product should be computed
+     * @return the scalar dot product between instance and {@code v}.
+     * @throws DimensionMismatchException if {@code v} is not the same
+     * size as this vector.
      */
-    public double dotProduct(ArrayRealVector v)
-        throws IllegalArgumentException {
+    public double dotProduct(ArrayRealVector v) {
         return dotProduct(v.data);
     }
 
@@ -782,26 +813,26 @@
 
    /**
      * Distance between two vectors.
-     * <p>This method computes the distance consistent with the
+     * This method computes the distance consistent with the
      * L<sub>2</sub> norm, i.e. the square root of the sum of
-     * elements differences, or euclidian distance.</p>
+     * elements differences, or euclidian distance.
+     *
      * @param v vector to which distance is requested
-     * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @return the distance between two vectors.
+     * @throws DimensionMismatchException if {@code v} is not the same size as
+     * this vector.
      * @see #getDistance(RealVector)
      * @see #getL1Distance(ArrayRealVector)
      * @see #getLInfDistance(ArrayRealVector)
      * @see #getNorm()
      */
-    public double getDistance(ArrayRealVector v)
-        throws IllegalArgumentException {
+    public double getDistance(ArrayRealVector v) {
         return getDistance(v.data);
     }
 
     /** {@inheritDoc} */
     @Override
-    public double getL1Distance(RealVector v)
-        throws IllegalArgumentException {
+    public double getL1Distance(RealVector v) {
         if (v instanceof ArrayRealVector) {
             return getL1Distance((ArrayRealVector) v);
         } else {
@@ -830,26 +861,26 @@
 
     /**
      * Distance between two vectors.
-     * <p>This method computes the distance consistent with
+     * This method computes the distance consistent with
      * L<sub>1</sub> norm, i.e. the sum of the absolute values of
-     * elements differences.</p>
-     * @param v vector to which distance is requested
-     * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * elements differences.
+     *
+     * @param v Vector to which distance is requested.
+     * @return the distance between two vectors.
+     * @throws DimensionMismatchException if {@code v} is not the same size
+     * as this vector.
      * @see #getDistance(RealVector)
      * @see #getL1Distance(ArrayRealVector)
      * @see #getLInfDistance(ArrayRealVector)
      * @see #getNorm()
      */
-    public double getL1Distance(ArrayRealVector v)
-        throws IllegalArgumentException {
+    public double getL1Distance(ArrayRealVector v) {
         return getL1Distance(v.data);
     }
 
     /** {@inheritDoc} */
     @Override
-    public double getLInfDistance(RealVector v)
-        throws IllegalArgumentException {
+    public double getLInfDistance(RealVector v) {
         if (v instanceof ArrayRealVector) {
             return getLInfDistance((ArrayRealVector) v);
         } else {
@@ -878,38 +909,38 @@
 
     /**
      * Distance between two vectors.
-     * <p>This method computes the distance consistent with
+     * This method computes the distance consistent with
      * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of
-     * elements differences.</p>
-     * @param v vector to which distance is requested
-     * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * elements differences.
+     *
+     * @param v Vector to which distance is requested.
+     * @return the distance between two vectors.
+     * @exception IllegalArgumentException if {@code v} is not the same size as this
      * @see #getDistance(RealVector)
      * @see #getL1Distance(ArrayRealVector)
      * @see #getLInfDistance(ArrayRealVector)
      * @see #getNorm()
      */
-    public double getLInfDistance(ArrayRealVector v)
-        throws IllegalArgumentException {
+    public double getLInfDistance(ArrayRealVector v) {
         return getLInfDistance(v.data);
     }
 
     /** {@inheritDoc} */
     @Override
-    public RealVector unitVector() throws ArithmeticException {
+    public RealVector unitVector() {
         final double norm = getNorm();
         if (norm == 0) {
-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM);
+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
         }
         return mapDivide(norm);
     }
 
     /** {@inheritDoc} */
     @Override
-    public void unitize() throws ArithmeticException {
+    public void unitize() {
         final double norm = getNorm();
         if (norm == 0) {
-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
         }
         mapDivideToSelf(norm);
     }
@@ -925,10 +956,13 @@
         return projection(new ArrayRealVector(v, false));
     }
 
-   /** Find the orthogonal projection of this vector onto another vector.
-     * @param v vector onto which instance must be projected
-     * @return projection of the instance onto v
-     * @throws IllegalArgumentException if v is not the same size as this
+    /**
+     * Find the orthogonal projection of this vector onto another vector.
+     *
+     * @param v Vector onto which instance must be projected.
+     * @return Projection of this instance onto {@code v}.
+     * @throws DimensionMismatchException if {@code v} is not the same size as
+     * this vector.
      */
     public ArrayRealVector projection(ArrayRealVector v) {
         return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));
@@ -980,7 +1014,7 @@
     }
 
     /** {@inheritDoc} */
-    public double getEntry(int index) throws MatrixIndexException {
+    public double getEntry(int index) {
         return data[index];
     }
 
@@ -1000,8 +1034,9 @@
 
     /**
      * Construct a vector by appending a vector to this vector.
-     * @param v vector to append to this one.
-     * @return a new vector
+     *
+     * @param v Vector to append to this one.
+     * @return a new vector.
      */
     public ArrayRealVector append(ArrayRealVector v) {
         return new ArrayRealVector(this, v);
@@ -1072,13 +1107,12 @@
     /**
      * Set a set of consecutive elements.
      *
-     * @param index index of first element to be set.
-     * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @param index Index of first element to be set.
+     * @param v Vector containing the values to set.
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is inconsistent with vector size.
      */
-    public void set(int index, ArrayRealVector v)
-        throws MatrixIndexException {
+    public void set(int index, ArrayRealVector v) {
         setSubVector(index, v.data);
     }
 
@@ -1102,36 +1136,35 @@
 
     /**
      * Check if instance and specified vectors have the same dimension.
-     * @param v vector to compare instance with
-     * @exception IllegalArgumentException if the vectors do not
-     * have the same dimension
+     *
+     * @param v Vector to compare instance with.
+     * @throws DimensionMismatchException if the vectors do not
+     * have the same dimension.
      */
     @Override
-    protected void checkVectorDimensions(RealVector v)
-        throws IllegalArgumentException {
+    protected void checkVectorDimensions(RealVector v) {
         checkVectorDimensions(v.getDimension());
     }
 
     /**
      * Check if instance dimension is equal to some expected value.
      *
-     * @param n expected dimension.
-     * @exception IllegalArgumentException if the dimension is
-     * inconsistent with vector size
+     * @param n Expected dimension.
+     * @throws DimensionMismatchException if the dimension is
+     * inconsistent with vector size.
      */
     @Override
-    protected void checkVectorDimensions(int n)
-        throws IllegalArgumentException {
+    protected void checkVectorDimensions(int n) {
         if (data.length != n) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    data.length, n);
+            throw new DimensionMismatchException(data.length, n);
         }
     }
 
     /**
-     * Returns true if any coordinate of this vector is NaN; false otherwise
-     * @return  true if any coordinate of this vector is NaN; false otherwise
+     * Check if any coordinate of this vector is {@code NaN}.
+     *
+     * @return {@code true} if any coordinate of this vector is {@code NaN},
+     * {@code false} otherwise.
      */
     public boolean isNaN() {
         for (double v : data) {
@@ -1143,13 +1176,13 @@
     }
 
     /**
-     * Returns true if any coordinate of this vector is infinite and none are NaN;
-     * false otherwise
-     * @return  true if any coordinate of this vector is infinite and none are NaN;
-     * false otherwise
+     * Check whether any coordinate of this vector is infinite and none
+     * are {@code NaN}.
+     *
+     * @return {@code true} if any coordinate of this vector is infinite and
+     * none are {@code NaN}, {@code false} otherwise.
      */
     public boolean isInfinite() {
-
         if (isNaN()) {
             return false;
         }
@@ -1161,61 +1194,54 @@
         }
 
         return false;
-
     }
 
     /**
      * Test for the equality of two real vectors.
-     * <p>
      * If all coordinates of two real vectors are exactly the same, and none are
-     * <code>Double.NaN</code>, the two real vectors are considered to be equal.
-     * </p>
-     * <p>
-     * <code>NaN</code> coordinates are considered to affect globally the vector
+     * {@code NaN}, the two real vectors are considered to be equal.
+     * {@code NaN} coordinates are considered to affect globally the vector
      * and be equals to each other - i.e, if either (or all) coordinates of the
-     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
-     * a vector with all <code>Double.NaN</code> coordinates.
-     * </p>
+     * real vector are equal to {@code NaN}, the real vector is equal to
+     * a vector with all {@code NaN} coordinates.
      *
-     * @param other Object to test for equality to this
-     * @return true if two vector objects are equal, false if
-     *         object is null, not an instance of RealVector, or
-     *         not equal to this RealVector instance
-     *
+     * @param other Object to test for equality.
+     * @return {@code true} if two vector objects are equal, {@code false} if
+     * {@code other} is null, not an instance of {@code RealVector}, or
+     * not equal to this {@code RealVector} instance.
      */
     @Override
     public boolean equals(Object other) {
-
-      if (this == other) {
-        return true;
-      }
-
-      if (other == null || !(other instanceof RealVector)) {
-        return false;
-      }
-
-
-      RealVector rhs = (RealVector) other;
-      if (data.length != rhs.getDimension()) {
-        return false;
-      }
-
-      if (rhs.isNaN()) {
-        return this.isNaN();
-      }
-
-      for (int i = 0; i < data.length; ++i) {
-        if (data[i] != rhs.getEntry(i)) {
-          return false;
+        if (this == other) {
+            return true;
         }
-      }
-      return true;
+
+        if (other == null || !(other instanceof RealVector)) {
+            return false;
+        }
+
+        RealVector rhs = (RealVector) other;
+        if (data.length != rhs.getDimension()) {
+            return false;
+        }
+
+        if (rhs.isNaN()) {
+            return this.isNaN();
+        }
+
+        for (int i = 0; i < data.length; ++i) {
+            if (data[i] != rhs.getEntry(i)) {
+                return false;
+            }
+        }
+        return true;
     }
 
     /**
      * Get a hashCode for the real vector.
-     * <p>All NaN values have the same hash code.</p>
-     * @return a hash code value for this object
+     * All {@code NaN} values have the same hash code.
+     *
+     * @return a hash code.
      */
     @Override
     public int hashCode() {
@@ -1224,5 +1250,4 @@
         }
         return MathUtils.hash(data);
     }
-
 }
diff --git a/src/main/java/org/apache/commons/math/linear/BigMatrix.java b/src/main/java/org/apache/commons/math/linear/BigMatrix.java
deleted file mode 100644
index ae4740b..0000000
--- a/src/main/java/org/apache/commons/math/linear/BigMatrix.java
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.linear;
-
-import java.math.BigDecimal;
-
-/**
- * Interface defining a real-valued matrix with basic algebraic operations, using
- * BigDecimal representations for the entries.
- * <p>
- * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>
- * returns the element in the first row, first column of the matrix.</p>
- *
- * @version $Revision$ $Date$
- * @deprecated as of 2.0, replaced by {@link FieldMatrix} with a {@link
- * org.apache.commons.math.util.BigReal} parameter
- */
-@Deprecated
-public interface BigMatrix extends AnyMatrix {
-
-    /**
-     * Returns a (deep) copy of this.
-     *
-     * @return matrix copy
-     */
-    BigMatrix copy();
-
-    /**
-     * Compute the sum of this and m.
-     *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @exception  IllegalArgumentException if m is not the same size as this
-     */
-    BigMatrix add(BigMatrix m) throws IllegalArgumentException;
-
-    /**
-     * Compute this minus m.
-     *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @exception  IllegalArgumentException if m is not the same size as this
-     */
-    BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;
-
-     /**
-     * Returns the result of adding d to each entry of this.
-     *
-     * @param d    value to be added to each entry
-     * @return     d + this
-     */
-    BigMatrix scalarAdd(BigDecimal d);
-
-    /**
-     * Returns the result multiplying each entry of this by d.
-     *
-     * @param d    value to multiply all entries by
-     * @return     d * this
-     */
-    BigMatrix scalarMultiply(BigDecimal d);
-
-    /**
-     * Returns the result of postmultiplying this by m.
-     *
-     * @param m    matrix to postmultiply by
-     * @return     this * m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
-     */
-    BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;
-
-    /**
-     * Returns the result premultiplying this by <code>m</code>.
-     * @param m    matrix to premultiply by
-     * @return     m * this
-     * @throws     IllegalArgumentException
-     *             if rowDimension(this) != columnDimension(m)
-     */
-    BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;
-
-    /**
-     * Returns matrix entries as a two-dimensional array.
-     *
-     * @return    2-dimensional array of entries
-     */
-    BigDecimal[][] getData();
-
-    /**
-     * Returns matrix entries as a two-dimensional array.
-     *
-     * @return    2-dimensional array of entries
-     */
-    double [][] getDataAsDoubleArray();
-
-    /***
-     * Gets the rounding mode
-     * @return the rounding mode
-     */
-    int getRoundingMode();
-
-    /**
-     * Returns the <a href="http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html">
-     * maximum absolute row sum norm</a> of the matrix.
-     *
-     * @return norm
-     */
-    BigDecimal getNorm();
-
-    /**
-     * Gets a submatrix. Rows and columns are indicated
-     * counting from 0 to n-1.
-     *
-     * @param startRow Initial row index
-     * @param endRow Final row index
-     * @param startColumn Initial column index
-     * @param endColumn Final column index
-     * @return The subMatrix containing the data of the
-     *         specified rows and columns
-     * @exception MatrixIndexException  if the indices are not valid
-     */
-    BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
-            int endColumn) throws MatrixIndexException;
-
-    /**
-     * Gets a submatrix. Rows and columns are indicated
-     * counting from 0 to n-1.
-     *
-     * @param selectedRows Array of row indices.
-     * @param selectedColumns Array of column indices.
-     * @return The subMatrix containing the data in the
-     *         specified rows and columns
-     * @exception MatrixIndexException if row or column selections are not valid
-     */
-    BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
-    throws MatrixIndexException;
-
-    /**
-     * Returns the entries in row number <code>row</code>
-     * as a row matrix.  Row indices start at 0.
-     *
-     * @param row the row to be fetched
-     * @return row matrix
-     * @throws MatrixIndexException if the specified row index is invalid
-     */
-    BigMatrix getRowMatrix(int row) throws MatrixIndexException;
-
-    /**
-     * Returns the entries in column number <code>column</code>
-     * as a column matrix.  Column indices start at 0.
-     *
-     * @param column the column to be fetched
-     * @return column matrix
-     * @throws MatrixIndexException if the specified column index is invalid
-     */
-    BigMatrix getColumnMatrix(int column) throws MatrixIndexException;
-
-    /**
-     * Returns the entries in row number <code>row</code> as an array.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= row < rowDimension.</code></p>
-     *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
-     */
-    BigDecimal[] getRow(int row) throws MatrixIndexException;
-
-    /**
-     * Returns the entries in row number <code>row</code> as an array
-     * of double values.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= row < rowDimension.</code></p>
-     *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
-     */
-    double [] getRowAsDoubleArray(int row) throws MatrixIndexException;
-
-    /**
-     * Returns the entries in column number <code>col</code> as an array.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= column < columnDimension.</code></p>
-     *
-     * @param col the column to be fetched
-     * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
-     */
-    BigDecimal[] getColumn(int col) throws MatrixIndexException;
-
-    /**
-     * Returns the entries in column number <code>col</code> as an array
-     * of double values.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= column < columnDimension.</code></p>
-     *
-     * @param col the column to be fetched
-     * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
-     */
-    double [] getColumnAsDoubleArray(int col) throws MatrixIndexException;
-
-    /**
-     * Returns the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li><code>0 <= row < rowDimension</code></li>
-     * <li><code> 0 <= column < columnDimension</code></li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
-     *
-     * @param row  row location of entry to be fetched
-     * @param column  column location of entry to be fetched
-     * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
-     */
-    BigDecimal getEntry(int row, int column) throws MatrixIndexException;
-
-    /**
-     * Returns the entry in the specified row and column as a double.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li><code>0 <= row < rowDimension</code></li>
-     * <li><code> 0 <= column < columnDimension</code></li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
-     *
-     * @param row  row location of entry to be fetched
-     * @param column  column location of entry to be fetched
-     * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
-     */
-    double getEntryAsDouble(int row, int column) throws MatrixIndexException;
-
-    /**
-     * Returns the transpose of this matrix.
-     *
-     * @return transpose matrix
-     */
-    BigMatrix transpose();
-
-    /**
-     * Returns the inverse of this matrix.
-     *
-     * @return inverse matrix
-     * @throws org.apache.commons.math.linear.InvalidMatrixException if
-     *     this is not invertible
-     */
-    BigMatrix inverse() throws InvalidMatrixException;
-
-    /**
-     * Returns the determinant of this matrix.
-     *
-     * @return determinant
-      *@throws org.apache.commons.math.linear.InvalidMatrixException if
-      *    matrix is not square
-     */
-    BigDecimal getDeterminant() throws InvalidMatrixException;
-
-    /**
-     * Returns the <a href="http://mathworld.wolfram.com/MatrixTrace.html">
-     * trace</a> of the matrix (the sum of the elements on the main diagonal).
-     *
-     * @return trace
-     */
-    BigDecimal getTrace();
-
-    /**
-     * Returns the result of multiplying this by the vector <code>v</code>.
-     *
-     * @param v the vector to operate on
-     * @return this*v
-     * @throws IllegalArgumentException if columnDimension != v.size()
-     */
-    BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException;
-
-    /**
-     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
-     *
-     * @param v the row vector to premultiply by
-     * @return v*this
-     * @throws IllegalArgumentException if rowDimension != v.size()
-     */
-    BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;
-
-    /**
-     * Returns the solution vector for a linear system with coefficient
-     * matrix = this and constant vector = <code>b</code>.
-     *
-     * @param b  constant vector
-     * @return vector of solution values to AX = b, where A is *this
-     * @throws IllegalArgumentException if this.rowDimension != b.length
-     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular
-     */
-    BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;
-
-    /**
-     * Returns a matrix of (column) solution vectors for linear systems with
-     * coefficient matrix = this and constant vectors = columns of
-     * <code>b</code>.
-     *
-     * @param b  matrix of constant vectors forming RHS of linear systems to
-     * to solve
-     * @return matrix of solution vectors
-     * @throws IllegalArgumentException if this.rowDimension != row dimension
-     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular
-     */
-    BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
-}
-
diff --git a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java
deleted file mode 100644
index 6124d2a..0000000
--- a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java
+++ /dev/null
@@ -1,1505 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.linear;
-import java.io.Serializable;
-import java.math.BigDecimal;
-
-import org.apache.commons.math.MathRuntimeException;
-import org.apache.commons.math.exception.util.LocalizedFormats;
-
-/**
- * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries
- * and <a href="http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf">
- * LU decompostion</a> to support linear system
- * solution and inverse.
- * <p>
- * The LU decompostion is performed as needed, to support the following operations: <ul>
- * <li>solve</li>
- * <li>isSingular</li>
- * <li>getDeterminant</li>
- * <li>inverse</li> </ul></p>
- * <p>
-* <strong>Usage notes</strong>:<br>
- * <ul><li>
- * The LU decomposition is stored and reused on subsequent calls.  If matrix
- * data are modified using any of the public setXxx methods, the saved
- * decomposition is discarded.  If data are modified via references to the
- * underlying array obtained using <code>getDataRef()</code>, then the stored
- * LU decomposition will not be discarded.  In this case, you need to
- * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition
- * before using any of the methods above.</li>
- * <li>
- * As specified in the {@link BigMatrix} interface, matrix element indexing
- * is 0-based -- e.g., <code>getEntry(0, 0)</code>
- * returns the element in the first row, first column of the matrix.</li></ul></p>
- *
- * @deprecated as of 2.0, replaced by {@link Array2DRowFieldMatrix} with a {@link
- * org.apache.commons.math.util.BigReal} parameter
- * @version $Revision$ $Date$
- */
-@Deprecated
-public class BigMatrixImpl implements BigMatrix, Serializable {
-
-    /** BigDecimal 0 */
-    static final BigDecimal ZERO = new BigDecimal(0);
-
-    /** BigDecimal 1 */
-    static final BigDecimal ONE = new BigDecimal(1);
-
-    /** Bound to determine effective singularity in LU decomposition */
-    private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);
-
-    /** Serialization id */
-    private static final long serialVersionUID = -1011428905656140431L;
-
-    /** Entries of the matrix */
-    protected BigDecimal data[][] = null;
-
-    /** Entries of cached LU decomposition.
-     *  All updates to data (other than luDecompose()) *must* set this to null
-     */
-    protected BigDecimal lu[][] = null;
-
-    /** Permutation associated with LU decomposition */
-    protected int[] permutation = null;
-
-    /** Parity of the permutation associated with the LU decomposition */
-    protected int parity = 1;
-
-    /** Rounding mode for divisions **/
-    private int roundingMode = BigDecimal.ROUND_HALF_UP;
-
-    /*** BigDecimal scale ***/
-    private int scale = 64;
-
-    /**
-     * Creates a matrix with no data
-     */
-    public BigMatrixImpl() {
-    }
-
-    /**
-     * Create a new BigMatrix with the supplied row and column dimensions.
-     *
-     * @param rowDimension      the number of rows in the new matrix
-     * @param columnDimension   the number of columns in the new matrix
-     * @throws IllegalArgumentException if row or column dimension is not
-     *  positive
-     */
-    public BigMatrixImpl(int rowDimension, int columnDimension) {
-        if (rowDimension < 1 ) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);
-        }
-        if (columnDimension < 1) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);
-        }
-        data = new BigDecimal[rowDimension][columnDimension];
-        lu = null;
-    }
-
-    /**
-     * Create a new BigMatrix using <code>d</code> as the underlying
-     * data array.
-     * <p>The input array is copied, not referenced. This constructor has
-     * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}
-     * with the second argument set to <code>true</code>.</p>
-     *
-     * @param d data for new matrix
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     */
-    public BigMatrixImpl(BigDecimal[][] d) {
-        this.copyIn(d);
-        lu = null;
-    }
-
-    /**
-     * Create a new BigMatrix using the input array as the underlying
-     * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * BigMatrix and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param d data for new matrix
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     * @see #BigMatrixImpl(BigDecimal[][])
-     */
-    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
-        if (copyArray) {
-            copyIn(d);
-        } else {
-            if (d == null) {
-                throw new NullPointerException();
-            }
-            final int nRows = d.length;
-            if (nRows == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-            }
-
-            final int nCols = d[0].length;
-            if (nCols == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-            }
-            for (int r = 1; r < nRows; r++) {
-                if (d[r].length != nCols) {
-                    throw MathRuntimeException.createIllegalArgumentException(
-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                          nCols, d[r].length);
-                }
-            }
-            data = d;
-        }
-        lu = null;
-    }
-
-    /**
-     * Create a new BigMatrix using <code>d</code> as the underlying
-     * data array.
-     * <p>Since the underlying array will hold <code>BigDecimal</code>
-     * instances, it will be created.</p>
-     *
-     * @param d data for new matrix
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     */
-    public BigMatrixImpl(double[][] d) {
-        final int nRows = d.length;
-        if (nRows == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-        }
-
-        final int nCols = d[0].length;
-        if (nCols == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-        }
-        for (int row = 1; row < nRows; row++) {
-            if (d[row].length != nCols) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                      nCols, d[row].length);
-            }
-        }
-        this.copyIn(d);
-        lu = null;
-    }
-
-    /**
-     * Create a new BigMatrix using the values represented by the strings in
-     * <code>d</code> as the underlying data array.
-     *
-     * @param d data for new matrix
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     */
-    public BigMatrixImpl(String[][] d) {
-        final int nRows = d.length;
-        if (nRows == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-        }
-
-        final int nCols = d[0].length;
-        if (nCols == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-        }
-        for (int row = 1; row < nRows; row++) {
-            if (d[row].length != nCols) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                      nCols, d[row].length);
-            }
-        }
-        this.copyIn(d);
-        lu = null;
-    }
-
-    /**
-     * Create a new (column) BigMatrix using <code>v</code> as the
-     * data for the unique column of the <code>v.length x 1</code> matrix
-     * created.
-     * <p>
-     * The input array is copied, not referenced.</p>
-     *
-     * @param v column vector holding data for new matrix
-     */
-    public BigMatrixImpl(BigDecimal[] v) {
-        final int nRows = v.length;
-        data = new BigDecimal[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            data[row][0] = v[row];
-        }
-    }
-
-    /**
-     * Create a new BigMatrix which is a copy of this.
-     *
-     * @return  the cloned matrix
-     */
-    public BigMatrix copy() {
-        return new BigMatrixImpl(this.copyOut(), false);
-    }
-
-    /**
-     * Compute the sum of this and <code>m</code>.
-     *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
-        try {
-            return add((BigMatrixImpl) m);
-        } catch (ClassCastException cce) {
-
-            // safety check
-            MatrixUtils.checkAdditionCompatible(this, m);
-
-            final int rowCount    = getRowDimension();
-            final int columnCount = getColumnDimension();
-            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-            for (int row = 0; row < rowCount; row++) {
-                final BigDecimal[] dataRow    = data[row];
-                final BigDecimal[] outDataRow = outData[row];
-                for (int col = 0; col < columnCount; col++) {
-                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
-                }
-            }
-            return new BigMatrixImpl(outData, false);
-        }
-    }
-
-    /**
-     * Compute the sum of this and <code>m</code>.
-     *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkAdditionCompatible(this, m);
-
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final BigDecimal[] dataRow    = data[row];
-            final BigDecimal[] mRow       = m.data[row];
-            final BigDecimal[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col].add(mRow[col]);
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Compute  this minus <code>m</code>.
-     *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
-        try {
-            return subtract((BigMatrixImpl) m);
-        } catch (ClassCastException cce) {
-
-            // safety check
-            MatrixUtils.checkSubtractionCompatible(this, m);
-
-            final int rowCount    = getRowDimension();
-            final int columnCount = getColumnDimension();
-            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-            for (int row = 0; row < rowCount; row++) {
-                final BigDecimal[] dataRow    = data[row];
-                final BigDecimal[] outDataRow = outData[row];
-                for (int col = 0; col < columnCount; col++) {
-                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
-                }
-            }
-            return new BigMatrixImpl(outData, false);
-        }
-    }
-
-    /**
-     * Compute  this minus <code>m</code>.
-     *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkSubtractionCompatible(this, m);
-
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final BigDecimal[] dataRow    = data[row];
-            final BigDecimal[] mRow       = m.data[row];
-            final BigDecimal[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col].subtract(mRow[col]);
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Returns the result of adding d to each entry of this.
-     *
-     * @param d    value to be added to each entry
-     * @return     d + this
-     */
-    public BigMatrix scalarAdd(BigDecimal d) {
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final BigDecimal[] dataRow    = data[row];
-            final BigDecimal[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col].add(d);
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Returns the result of multiplying each entry of this by <code>d</code>
-     * @param d  value to multiply all entries by
-     * @return d * this
-     */
-    public BigMatrix scalarMultiply(BigDecimal d) {
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final BigDecimal[] dataRow    = data[row];
-            final BigDecimal[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col].multiply(d);
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Returns the result of postmultiplying this by <code>m</code>.
-     * @param m    matrix to postmultiply by
-     * @return     this*m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
-     */
-    public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
-        try {
-            return multiply((BigMatrixImpl) m);
-        } catch (ClassCastException cce) {
-
-            // safety check
-            MatrixUtils.checkMultiplicationCompatible(this, m);
-
-            final int nRows = this.getRowDimension();
-            final int nCols = m.getColumnDimension();
-            final int nSum = this.getColumnDimension();
-            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
-            for (int row = 0; row < nRows; row++) {
-                final BigDecimal[] dataRow    = data[row];
-                final BigDecimal[] outDataRow = outData[row];
-                for (int col = 0; col < nCols; col++) {
-                    BigDecimal sum = ZERO;
-                    for (int i = 0; i < nSum; i++) {
-                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
-                    }
-                    outDataRow[col] = sum;
-                }
-            }
-            return new BigMatrixImpl(outData, false);
-        }
-    }
-
-    /**
-     * Returns the result of postmultiplying this by <code>m</code>.
-     * @param m    matrix to postmultiply by
-     * @return     this*m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
-     */
-    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkMultiplicationCompatible(this, m);
-
-        final int nRows = this.getRowDimension();
-        final int nCols = m.getColumnDimension();
-        final int nSum = this.getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
-        for (int row = 0; row < nRows; row++) {
-            final BigDecimal[] dataRow    = data[row];
-            final BigDecimal[] outDataRow = outData[row];
-            for (int col = 0; col < nCols; col++) {
-                BigDecimal sum = ZERO;
-                for (int i = 0; i < nSum; i++) {
-                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));
-                }
-                outDataRow[col] = sum;
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Returns the result premultiplying this by <code>m</code>.
-     * @param m    matrix to premultiply by
-     * @return     m * this
-     * @throws     IllegalArgumentException
-     *             if rowDimension(this) != columnDimension(m)
-     */
-    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {
-        return m.multiply(this);
-    }
-
-    /**
-     * Returns matrix entries as a two-dimensional array.
-     * <p>
-     * Makes a fresh copy of the underlying data.</p>
-     *
-     * @return    2-dimensional array of entries
-     */
-    public BigDecimal[][] getData() {
-        return copyOut();
-    }
-
-    /**
-     * Returns matrix entries as a two-dimensional array.
-     * <p>
-     * Makes a fresh copy of the underlying data converted to
-     * <code>double</code> values.</p>
-     *
-     * @return    2-dimensional array of entries
-     */
-    public double[][] getDataAsDoubleArray() {
-        final int nRows = getRowDimension();
-        final int nCols = getColumnDimension();
-        final double d[][] = new double[nRows][nCols];
-        for (int i = 0; i < nRows; i++) {
-            for (int j = 0; j < nCols; j++) {
-                d[i][j] = data[i][j].doubleValue();
-            }
-        }
-        return d;
-    }
-
-    /**
-     * Returns a reference to the underlying data array.
-     * <p>
-     * Does not make a fresh copy of the underlying data.</p>
-     *
-     * @return 2-dimensional array of entries
-     */
-    public BigDecimal[][] getDataRef() {
-        return data;
-    }
-
-    /***
-     * Gets the rounding mode for division operations
-     * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
-     * @see BigDecimal
-     * @return the rounding mode.
-     */
-    public int getRoundingMode() {
-        return roundingMode;
-    }
-
-    /***
-     * Sets the rounding mode for decimal divisions.
-     * @see BigDecimal
-     * @param roundingMode rounding mode for decimal divisions
-     */
-    public void setRoundingMode(int roundingMode) {
-        this.roundingMode = roundingMode;
-    }
-
-    /***
-     * Sets the scale for division operations.
-     * The default is 64
-     * @see BigDecimal
-     * @return the scale
-     */
-    public int getScale() {
-        return scale;
-    }
-
-    /***
-     * Sets the scale for division operations.
-     * @see BigDecimal
-     * @param scale scale for division operations
-     */
-    public void setScale(int scale) {
-        this.scale = scale;
-    }
-
-    /**
-     * Returns the <a href="http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html">
-     * maximum absolute row sum norm</a> of the matrix.
-     *
-     * @return norm
-     */
-    public BigDecimal getNorm() {
-        BigDecimal maxColSum = ZERO;
-        for (int col = 0; col < this.getColumnDimension(); col++) {
-            BigDecimal sum = ZERO;
-            for (int row = 0; row < this.getRowDimension(); row++) {
-                sum = sum.add(data[row][col].abs());
-            }
-            maxColSum = maxColSum.max(sum);
-        }
-        return maxColSum;
-    }
-
-    /**
-     * Gets a submatrix. Rows and columns are indicated
-     * counting from 0 to n-1.
-     *
-     * @param startRow Initial row index
-     * @param endRow Final row index
-     * @param startColumn Initial column index
-     * @param endColumn Final column index
-     * @return The subMatrix containing the data of the
-     *         specified rows and columns
-     * @exception MatrixIndexException if row or column selections are not valid
-     */
-    public BigMatrix getSubMatrix(int startRow, int endRow,
-                                  int startColumn, int endColumn)
-        throws MatrixIndexException {
-
-        MatrixUtils.checkRowIndex(this, startRow);
-        MatrixUtils.checkRowIndex(this, endRow);
-        if (startRow > endRow) {
-            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,
-                                           startRow, endRow);
-        }
-
-        MatrixUtils.checkColumnIndex(this, startColumn);
-        MatrixUtils.checkColumnIndex(this, endColumn);
-        if (startColumn > endColumn) {
-            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,
-                                           startColumn, endColumn);
-        }
-
-        final BigDecimal[][] subMatrixData =
-            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
-        for (int i = startRow; i <= endRow; i++) {
-            System.arraycopy(data[i], startColumn,
-                             subMatrixData[i - startRow], 0,
-                             endColumn - startColumn + 1);
-        }
-
-        return new BigMatrixImpl(subMatrixData, false);
-
-    }
-
-    /**
-     * Gets a submatrix. Rows and columns are indicated
-     * counting from 0 to n-1.
-     *
-     * @param selectedRows Array of row indices must be non-empty
-     * @param selectedColumns Array of column indices must be non-empty
-     * @return The subMatrix containing the data in the
-     *     specified rows and columns
-     * @exception MatrixIndexException  if supplied row or column index arrays
-     *     are not valid
-     */
-    public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
-        throws MatrixIndexException {
-
-        if (selectedRows.length * selectedColumns.length == 0) {
-            if (selectedRows.length == 0) {
-                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);
-            }
-            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);
-        }
-
-        final BigDecimal[][] subMatrixData =
-            new BigDecimal[selectedRows.length][selectedColumns.length];
-        try  {
-            for (int i = 0; i < selectedRows.length; i++) {
-                final BigDecimal[] subI = subMatrixData[i];
-                final BigDecimal[] dataSelectedI = data[selectedRows[i]];
-                for (int j = 0; j < selectedColumns.length; j++) {
-                    subI[j] = dataSelectedI[selectedColumns[j]];
-                }
-            }
-        } catch (ArrayIndexOutOfBoundsException e) {
-            // we redo the loop with checks enabled
-            // in order to generate an appropriate message
-            for (final int row : selectedRows) {
-                MatrixUtils.checkRowIndex(this, row);
-            }
-            for (final int column : selectedColumns) {
-                MatrixUtils.checkColumnIndex(this, column);
-            }
-        }
-        return new BigMatrixImpl(subMatrixData, false);
-    }
-
-    /**
-     * Replace the submatrix starting at <code>row, column</code> using data in
-     * the input <code>subMatrix</code> array. Indexes are 0-based.
-     * <p>
-     * Example:<br>
-     * Starting with <pre>
-     * 1  2  3  4
-     * 5  6  7  8
-     * 9  0  1  2
-     * </pre>
-     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
-     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
-     * 1  2  3  4
-     * 5  3  4  8
-     * 9  5  6  2
-     * </pre></p>
-     *
-     * @param subMatrix  array containing the submatrix replacement data
-     * @param row  row coordinate of the top, left element to be replaced
-     * @param column  column coordinate of the top, left element to be replaced
-     * @throws MatrixIndexException  if subMatrix does not fit into this
-     *    matrix from element in (row, column)
-     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>subMatrix</code> is null
-     * @since 1.1
-     */
-    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column)
-    throws MatrixIndexException {
-
-        final int nRows = subMatrix.length;
-        if (nRows == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-        }
-
-        final int nCols = subMatrix[0].length;
-        if (nCols == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-        }
-
-        for (int r = 1; r < nRows; r++) {
-            if (subMatrix[r].length != nCols) {
-                throw MathRuntimeException.createIllegalArgumentException(
-                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                      nCols, subMatrix[r].length);
-            }
-        }
-
-        if (data == null) {
-            if (row > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                        LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET,
-                        row);
-            }
-            if (column > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                        LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET,
-                        column);
-            }
-            data = new BigDecimal[nRows][nCols];
-            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
-        } else {
-            MatrixUtils.checkRowIndex(this, row);
-            MatrixUtils.checkColumnIndex(this, column);
-            MatrixUtils.checkRowIndex(this, nRows + row - 1);
-            MatrixUtils.checkColumnIndex(this, nCols + column - 1);
-        }
-        for (int i = 0; i < nRows; i++) {
-            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
-        }
-
-        lu = null;
-
-    }
-
-    /**
-     * Returns the entries in row number <code>row</code>
-     * as a row matrix.  Row indices start at 0.
-     *
-     * @param row the row to be fetched
-     * @return row matrix
-     * @throws MatrixIndexException if the specified row index is invalid
-     */
-    public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
-        MatrixUtils.checkRowIndex(this, row);
-        final int ncols = this.getColumnDimension();
-        final BigDecimal[][] out = new BigDecimal[1][ncols];
-        System.arraycopy(data[row], 0, out[0], 0, ncols);
-        return new BigMatrixImpl(out, false);
-    }
-
-    /**
-     * Returns the entries in column number <code>column</code>
-     * as a column matrix.  Column indices start at 0.
-     *
-     * @param column the column to be fetched
-     * @return column matrix
-     * @throws MatrixIndexException if the specified column index is invalid
-     */
-    public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
-        MatrixUtils.checkColumnIndex(this, column);
-        final int nRows = this.getRowDimension();
-        final BigDecimal[][] out = new BigDecimal[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            out[row][0] = data[row][column];
-        }
-        return new BigMatrixImpl(out, false);
-    }
-
-    /**
-     * Returns the entries in row number <code>row</code> as an array.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= row < rowDimension.</code></p>
-     *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
-     */
-    public BigDecimal[] getRow(int row) throws MatrixIndexException {
-        MatrixUtils.checkRowIndex(this, row);
-        final int ncols = this.getColumnDimension();
-        final BigDecimal[] out = new BigDecimal[ncols];
-        System.arraycopy(data[row], 0, out, 0, ncols);
-        return out;
-    }
-
-     /**
-     * Returns the entries in row number <code>row</code> as an array
-     * of double values.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= row < rowDimension.</code></p>
-     *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
-     */
-    public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
-        MatrixUtils.checkRowIndex(this, row);
-        final int ncols = this.getColumnDimension();
-        final double[] out = new double[ncols];
-        for (int i=0;i<ncols;i++) {
-            out[i] = data[row][i].doubleValue();
-        }
-        return out;
-    }
-
-     /**
-     * Returns the entries in column number <code>col</code> as an array.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= column < columnDimension.</code></p>
-     *
-     * @param col the column to be fetched
-     * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
-     */
-    public BigDecimal[] getColumn(int col) throws MatrixIndexException {
-        MatrixUtils.checkColumnIndex(this, col);
-        final int nRows = this.getRowDimension();
-        final BigDecimal[] out = new BigDecimal[nRows];
-        for (int i = 0; i < nRows; i++) {
-            out[i] = data[i][col];
-        }
-        return out;
-    }
-
-    /**
-     * Returns the entries in column number <code>col</code> as an array
-     * of double values.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless <code>0 <= column < columnDimension.</code></p>
-     *
-     * @param col the column to be fetched
-     * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
-     */
-    public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
-        MatrixUtils.checkColumnIndex(this, col);
-        final int nrows = this.getRowDimension();
-        final double[] out = new double[nrows];
-        for (int i=0;i<nrows;i++) {
-            out[i] = data[i][col].doubleValue();
-        }
-        return out;
-    }
-
-     /**
-     * Returns the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li><code>0 <= row < rowDimension</code></li>
-     * <li><code> 0 <= column < columnDimension</code></li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
-     *
-     * @param row  row location of entry to be fetched
-     * @param column  column location of entry to be fetched
-     * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
-     */
-    public BigDecimal getEntry(int row, int column)
-    throws MatrixIndexException {
-        try {
-            return data[row][column];
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
-    }
-
-    /**
-     * Returns the entry in the specified row and column as a double.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li><code>0 <= row < rowDimension</code></li>
-     * <li><code> 0 <= column < columnDimension</code></li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
-     *
-     * @param row  row location of entry to be fetched
-     * @param column  column location of entry to be fetched
-     * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row
-     * or column index is not valid
-     */
-    public double getEntryAsDouble(int row, int column) throws MatrixIndexException {
-        return getEntry(row,column).doubleValue();
-    }
-
-    /**
-     * Returns the transpose matrix.
-     *
-     * @return transpose matrix
-     */
-    public BigMatrix transpose() {
-        final int nRows = this.getRowDimension();
-        final int nCols = this.getColumnDimension();
-        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];
-        for (int row = 0; row < nRows; row++) {
-            final BigDecimal[] dataRow = data[row];
-            for (int col = 0; col < nCols; col++) {
-                outData[col][row] = dataRow[col];
-            }
-        }
-        return new BigMatrixImpl(outData, false);
-    }
-
-    /**
-     * Returns the inverse matrix if this matrix is invertible.
-     *
-     * @return inverse matrix
-     * @throws InvalidMatrixException if this is not invertible
-     */
-    public BigMatrix inverse() throws InvalidMatrixException {
-        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));
-    }
-
-    /**
-     * Returns the determinant of this matrix.
-     *
-     * @return determinant
-     * @throws InvalidMatrixException if matrix is not square
-     */
-    public BigDecimal getDeterminant() throws InvalidMatrixException {
-        if (!isSquare()) {
-            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());
-        }
-        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null
-            return ZERO;
-        } else {
-            BigDecimal det = (parity == 1) ? ONE : ONE.negate();
-            for (int i = 0; i < getRowDimension(); i++) {
-                det = det.multiply(lu[i][i]);
-            }
-            return det;
-        }
-    }
-
-     /**
-     * Is this a square matrix?
-     * @return true if the matrix is square (rowDimension = columnDimension)
-     */
-    public boolean isSquare() {
-        return getColumnDimension() == getRowDimension();
-    }
-
-    /**
-     * Is this a singular matrix?
-     * @return true if the matrix is singular
-     */
-    public boolean isSingular() {
-        if (lu == null) {
-            try {
-                luDecompose();
-                return false;
-            } catch (InvalidMatrixException ex) {
-                return true;
-            }
-        } else { // LU decomp must have been successfully performed
-            return false; // so the matrix is not singular
-        }
-    }
-
-    /**
-     * Returns the number of rows in the matrix.
-     *
-     * @return rowDimension
-     */
-    public int getRowDimension() {
-        return data.length;
-    }
-
-    /**
-     * Returns the number of columns in the matrix.
-     *
-     * @return columnDimension
-     */
-    public int getColumnDimension() {
-        return data[0].length;
-    }
-
-     /**
-     * Returns the <a href="http://mathworld.wolfram.com/MatrixTrace.html">
-     * trace</a> of the matrix (the sum of the elements on the main diagonal).
-     *
-     * @return trace
-     *
-     * @throws IllegalArgumentException if this matrix is not square.
-     */
-    public BigDecimal getTrace() throws IllegalArgumentException {
-        if (!isSquare()) {
-            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());
-        }
-        BigDecimal trace = data[0][0];
-        for (int i = 1; i < this.getRowDimension(); i++) {
-            trace = trace.add(data[i][i]);
-        }
-        return trace;
-    }
-
-    /**
-     * Returns the result of multiplying this by the vector <code>v</code>.
-     *
-     * @param v the vector to operate on
-     * @return this*v
-     * @throws IllegalArgumentException if columnDimension != v.size()
-     */
-    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
-        if (v.length != getColumnDimension()) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    v.length, getColumnDimension() );
-        }
-        final int nRows = this.getRowDimension();
-        final int nCols = this.getColumnDimension();
-        final BigDecimal[] out = new BigDecimal[nRows];
-        for (int row = 0; row < nRows; row++) {
-            BigDecimal sum = ZERO;
-            for (int i = 0; i < nCols; i++) {
-                sum = sum.add(data[row][i].multiply(v[i]));
-            }
-            out[row] = sum;
-        }
-        return out;
-    }
-
-    /**
-     * Returns the result of multiplying this by the vector <code>v</code>.
-     *
-     * @param v the vector to operate on
-     * @return this*v
-     * @throws IllegalArgumentException if columnDimension != v.size()
-     */
-    public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
-        final BigDecimal bd[] = new BigDecimal[v.length];
-        for (int i = 0; i < bd.length; i++) {
-            bd[i] = new BigDecimal(v[i]);
-        }
-        return operate(bd);
-    }
-
-    /**
-     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
-     *
-     * @param v the row vector to premultiply by
-     * @return v*this
-     * @throws IllegalArgumentException if rowDimension != v.size()
-     */
-    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
-        final int nRows = this.getRowDimension();
-        if (v.length != nRows) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    v.length, nRows );
-        }
-        final int nCols = this.getColumnDimension();
-        final BigDecimal[] out = new BigDecimal[nCols];
-        for (int col = 0; col < nCols; col++) {
-            BigDecimal sum = ZERO;
-            for (int i = 0; i < nRows; i++) {
-                sum = sum.add(data[i][col].multiply(v[i]));
-            }
-            out[col] = sum;
-        }
-        return out;
-    }
-
-    /**
-     * Returns a matrix of (column) solution vectors for linear systems with
-     * coefficient matrix = this and constant vectors = columns of
-     * <code>b</code>.
-     *
-     * @param b  array of constants forming RHS of linear systems to
-     * to solve
-     * @return solution array
-     * @throws IllegalArgumentException if this.rowDimension != row dimension
-     * @throws InvalidMatrixException if this matrix is not square or is singular
-     */
-    public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
-        final int nRows = this.getRowDimension();
-        if (b.length != nRows) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    b.length, nRows);
-        }
-        final BigMatrix bMatrix = new BigMatrixImpl(b);
-        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
-        final BigDecimal[] out = new BigDecimal[nRows];
-        for (int row = 0; row < nRows; row++) {
-            out[row] = solution[row][0];
-        }
-        return out;
-    }
-
-    /**
-     * Returns a matrix of (column) solution vectors for linear systems with
-     * coefficient matrix = this and constant vectors = columns of
-     * <code>b</code>.
-     *
-     * @param b  array of constants forming RHS of linear systems to
-     * to solve
-     * @return solution array
-     * @throws IllegalArgumentException if this.rowDimension != row dimension
-     * @throws InvalidMatrixException if this matrix is not square or is singular
-     */
-    public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
-        final BigDecimal bd[] = new BigDecimal[b.length];
-        for (int i = 0; i < bd.length; i++) {
-            bd[i] = new BigDecimal(b[i]);
-        }
-        return solve(bd);
-    }
-
-    /**
-     * Returns a matrix of (column) solution vectors for linear systems with
-     * coefficient matrix = this and constant vectors = columns of
-     * <code>b</code>.
-     *
-     * @param b  matrix of constant vectors forming RHS of linear systems to
-     * to solve
-     * @return matrix of solution vectors
-     * @throws IllegalArgumentException if this.rowDimension != row dimension
-     * @throws InvalidMatrixException if this matrix is not square or is singular
-     */
-    public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {
-        if (b.getRowDimension() != getRowDimension()) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,
-                    b.getRowDimension(), b.getColumnDimension(), getRowDimension(), "n");
-        }
-        if (!isSquare()) {
-            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());
-        }
-        if (this.isSingular()) { // side effect: compute LU decomp
-            throw new SingularMatrixException();
-        }
-
-        final int nCol = this.getColumnDimension();
-        final int nColB = b.getColumnDimension();
-        final int nRowB = b.getRowDimension();
-
-        // Apply permutations to b
-        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
-        for (int row = 0; row < nRowB; row++) {
-            final BigDecimal[] bpRow = bp[row];
-            for (int col = 0; col < nColB; col++) {
-                bpRow[col] = b.getEntry(permutation[row], col);
-            }
-        }
-
-        // Solve LY = b
-        for (int col = 0; col < nCol; col++) {
-            for (int i = col + 1; i < nCol; i++) {
-                final BigDecimal[] bpI = bp[i];
-                final BigDecimal[] luI = lu[i];
-                for (int j = 0; j < nColB; j++) {
-                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
-                }
-            }
-        }
-
-        // Solve UX = Y
-        for (int col = nCol - 1; col >= 0; col--) {
-            final BigDecimal[] bpCol = bp[col];
-            final BigDecimal luDiag = lu[col][col];
-            for (int j = 0; j < nColB; j++) {
-                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
-            }
-            for (int i = 0; i < col; i++) {
-                final BigDecimal[] bpI = bp[i];
-                final BigDecimal[] luI = lu[i];
-                for (int j = 0; j < nColB; j++) {
-                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
-                }
-            }
-        }
-
-        return new BigMatrixImpl(bp, false);
-
-    }
-
-    /**
-     * Computes a new
-     * <a href="http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf">
-     * LU decompostion</a> for this matrix, storing the result for use by other methods.
-     * <p>
-     * <strong>Implementation Note</strong>:<br>
-     * Uses <a href="http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm">
-     * Crout's algortithm</a>, with partial pivoting.</p>
-     * <p>
-     * <strong>Usage Note</strong>:<br>
-     * This method should rarely be invoked directly. Its only use is
-     * to force recomputation of the LU decomposition when changes have been
-     * made to the underlying data using direct array references. Changes
-     * made using setXxx methods will trigger recomputation when needed
-     * automatically.</p>
-     *
-     * @throws InvalidMatrixException if the matrix is non-square or singular.
-     */
-    public void luDecompose() throws InvalidMatrixException {
-
-        final int nRows = this.getRowDimension();
-        final int nCols = this.getColumnDimension();
-        if (nRows != nCols) {
-            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());
-        }
-        lu = this.getData();
-
-        // Initialize permutation array and parity
-        permutation = new int[nRows];
-        for (int row = 0; row < nRows; row++) {
-            permutation[row] = row;
-        }
-        parity = 1;
-
-        // Loop over columns
-        for (int col = 0; col < nCols; col++) {
-
-            BigDecimal sum = ZERO;
-
-            // upper
-            for (int row = 0; row < col; row++) {
-                final BigDecimal[] luRow = lu[row];
-                sum = luRow[col];
-                for (int i = 0; i < row; i++) {
-                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));
-                }
-                luRow[col] = sum;
-            }
-
-            // lower
-            int max = col; // permutation row
-            BigDecimal largest = ZERO;
-            for (int row = col; row < nRows; row++) {
-                final BigDecimal[] luRow = lu[row];
-                sum = luRow[col];
-                for (int i = 0; i < col; i++) {
-                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));
-                }
-                luRow[col] = sum;
-
-                // maintain best permutation choice
-                if (sum.abs().compareTo(largest) == 1) {
-                    largest = sum.abs();
-                    max = row;
-                }
-            }
-
-            // Singularity check
-            if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {
-                lu = null;
-                throw new SingularMatrixException();
-            }
-
-            // Pivot if necessary
-            if (max != col) {
-                BigDecimal tmp = ZERO;
-                for (int i = 0; i < nCols; i++) {
-                    tmp = lu[max][i];
-                    lu[max][i] = lu[col][i];
-                    lu[col][i] = tmp;
-                }
-                int temp = permutation[max];
-                permutation[max] = permutation[col];
-                permutation[col] = temp;
-                parity = -parity;
-            }
-
-            // Divide the lower elements by the "winning" diagonal elt.
-            final BigDecimal luDiag = lu[col][col];
-            for (int row = col + 1; row < nRows; row++) {
-                final BigDecimal[] luRow = lu[row];
-                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);
-            }
-
-        }
-
-    }
-
-    /**
-     * Get a string representation for this matrix.
-     * @return a string representation for this matrix
-     */
-    @Override
-    public String toString() {
-        StringBuffer res = new StringBuffer();
-        res.append("BigMatrixImpl{");
-        if (data != null) {
-            for (int i = 0; i < data.length; i++) {
-                if (i > 0) {
-                    res.append(",");
-                }
-                res.append("{");
-                for (int j = 0; j < data[0].length; j++) {
-                    if (j > 0) {
-                        res.append(",");
-                    }
-                    res.append(data[i][j]);
-                }
-                res.append("}");
-            }
-        }
-        res.append("}");
-        return res.toString();
-    }
-
-    /**
-     * Returns true iff <code>object</code> is a
-     * <code>BigMatrixImpl</code> instance with the same dimensions as this
-     * and all corresponding matrix entries are equal.  BigDecimal.equals
-     * is used to compare corresponding entries.
-     *
-     * @param object the object to test equality against.
-     * @return true if object equals this
-     */
-    @Override
-    public boolean equals(Object object) {
-        if (object == this ) {
-            return true;
-        }
-        if (object instanceof BigMatrixImpl == false) {
-            return false;
-        }
-        final BigMatrix m = (BigMatrix) object;
-        final int nRows = getRowDimension();
-        final int nCols = getColumnDimension();
-        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
-            return false;
-        }
-        for (int row = 0; row < nRows; row++) {
-            final BigDecimal[] dataRow = data[row];
-            for (int col = 0; col < nCols; col++) {
-                if (!dataRow[col].equals(m.getEntry(row, col))) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Computes a hashcode for the matrix.
-     *
-     * @return hashcode for matrix
-     */
-    @Override
-    public int hashCode() {
-        int ret = 7;
-        final int nRows = getRowDimension();
-        final int nCols = getColumnDimension();
-        ret = ret * 31 + nRows;
-        ret = ret * 31 + nCols;
-        for (int row = 0; row < nRows; row++) {
-            final BigDecimal[] dataRow = data[row];
-            for (int col = 0; col < nCols; col++) {
-                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *
-                dataRow[col].hashCode();
-            }
-        }
-        return ret;
-    }
-
-    //------------------------ Protected methods
-
-    /**
-     *  Returns the LU decomposition as a BigMatrix.
-     *  Returns a fresh copy of the cached LU matrix if this has been computed;
-     *  otherwise the composition is computed and cached for use by other methods.
-     *  Since a copy is returned in either case, changes to the returned matrix do not
-     *  affect the LU decomposition property.
-     * <p>
-     * The matrix returned is a compact representation of the LU decomposition.
-     * Elements below the main diagonal correspond to entries of the "L" matrix;
-     * elements on and above the main diagonal correspond to entries of the "U"
-     * matrix.</p>
-     * <p>
-     * Example: <pre>
-     *
-     *     Returned matrix                L                  U
-     *         2  3  1                   1  0  0            2  3  1
-     *         5  4  6                   5  1  0            0  4  6
-     *         1  7  8                   1  7  1            0  0  8
-     * </pre>
-     *
-     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>
-     *  where permuteRows reorders the rows of the matrix to follow the order determined
-     *  by the <a href=#getPermutation()>permutation</a> property.</p>
-     *
-     * @return LU decomposition matrix
-     * @throws InvalidMatrixException if the matrix is non-square or singular.
-     */
-    protected BigMatrix getLUMatrix() throws InvalidMatrixException {
-        if (lu == null) {
-            luDecompose();
-        }
-        return new BigMatrixImpl(lu);
-    }
-
-    /**
-     * Returns the permutation associated with the lu decomposition.
-     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.
-     * <p>
-     * Example:
-     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second
-     * and current first row is last.</p>
-     * <p>
-     * Returns a fresh copy of the array.</p>
-     *
-     * @return the permutation
-     */
-    protected int[] getPermutation() {
-        final int[] out = new int[permutation.length];
-        System.arraycopy(permutation, 0, out, 0, permutation.length);
-        return out;
-    }
-
-    //------------------------ Private methods
-
-    /**
-     * Returns a fresh copy of the underlying data array.
-     *
-     * @return a copy of the underlying data array.
-     */
-    private BigDecimal[][] copyOut() {
-        final int nRows = this.getRowDimension();
-        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
-        // can't copy 2-d array in one shot, otherwise get row references
-        for (int i = 0; i < nRows; i++) {
-            System.arraycopy(data[i], 0, out[i], 0, data[i].length);
-        }
-        return out;
-    }
-
-    /**
-     * Replaces data with a fresh copy of the input array.
-     * <p>
-     * Verifies that the input array is rectangular and non-empty.</p>
-     *
-     * @param in data to copy in
-     * @throws IllegalArgumentException if input array is emtpy or not
-     *    rectangular
-     * @throws NullPointerException if input array is null
-     */
-    private void copyIn(BigDecimal[][] in) {
-        setSubMatrix(in,0,0);
-    }
-
-    /**
-     * Replaces data with a fresh copy of the input array.
-     *
-     * @param in data to copy in
-     */
-    private void copyIn(double[][] in) {
-        final int nRows = in.length;
-        final int nCols = in[0].length;
-        data = new BigDecimal[nRows][nCols];
-        for (int i = 0; i < nRows; i++) {
-            final BigDecimal[] dataI = data[i];
-            final double[] inI = in[i];
-            for (int j = 0; j < nCols; j++) {
-                dataI[j] = new BigDecimal(inI[j]);
-            }
-        }
-        lu = null;
-    }
-
-    /**
-     * Replaces data with BigDecimals represented by the strings in the input
-     * array.
-     *
-     * @param in data to copy in
-     */
-    private void copyIn(String[][] in) {
-        final int nRows = in.length;
-        final int nCols = in[0].length;
-        data = new BigDecimal[nRows][nCols];
-        for (int i = 0; i < nRows; i++) {
-            final BigDecimal[] dataI = data[i];
-            final String[] inI = in[i];
-            for (int j = 0; j < nCols; j++) {
-                dataI[j] = new BigDecimal(inI[j]);
-            }
-        }
-        lu = null;
-    }
-
-}
diff --git a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java
index 882d9e4..7d97358 100644
--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java
@@ -66,25 +66,18 @@
  * @since 2.0
  */
 public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {
-
     /** Block size. */
     public static final int BLOCK_SIZE = 52;
-
     /** Serializable version identifier */
     private static final long serialVersionUID = 4991895511313664478L;
-
     /** Blocks of matrix entries. */
     private final double blocks[][];
-
     /** Number of rows of the matrix. */
     private final int rows;
-
     /** Number of columns of the matrix. */
     private final int columns;
-
     /** Number of block rows of the matrix. */
     private final int blockRows;
-
     /** Number of block columns of the matrix. */
     private final int blockColumns;
 
@@ -94,22 +87,19 @@
      * @param rows  the number of rows in the new matrix
      * @param columns  the number of columns in the new matrix
      * @throws IllegalArgumentException if row or column dimension is not
-     *  positive
+     * positive.
      */
-    public BlockRealMatrix(final int rows, final int columns)
-        throws IllegalArgumentException {
-
+    public BlockRealMatrix(final int rows, final int columns) {
         super(rows, columns);
-        this.rows    = rows;
+        this.rows = rows;
         this.columns = columns;
 
         // number of blocks
-        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
+        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;
         blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;
 
         // allocate storage blocks, taking care of smaller ones at right and bottom
         blocks = createBlocksLayout(rows, columns);
-
     }
 
     /**
@@ -146,15 +136,13 @@
      * @see #BlockRealMatrix(double[][])
      */
     public BlockRealMatrix(final int rows, final int columns,
-                           final double[][] blockData, final boolean copyArray)
-        throws IllegalArgumentException {
-
+                           final double[][] blockData, final boolean copyArray) {
         super(rows, columns);
-        this.rows    = rows;
+        this.rows = rows;
         this.columns = columns;
 
         // number of blocks
-        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
+        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;
         blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;
 
         if (copyArray) {
@@ -202,12 +190,10 @@
      * @see #createBlocksLayout(int, int)
      * @see #BlockRealMatrix(int, int, double[][], boolean)
      */
-    public static double[][] toBlocksLayout(final double[][] rawData)
-        throws IllegalArgumentException {
-
-        final int rows         = rawData.length;
-        final int columns      = rawData[0].length;
-        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
+    public static double[][] toBlocksLayout(final double[][] rawData) {
+        final int rows = rawData.length;
+        final int columns = rawData[0].length;
+        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;
 
         // safety checks
@@ -222,12 +208,12 @@
         final double[][] blocks = new double[blockRows * blockColumns][];
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
-            final int pStart  = iBlock * BLOCK_SIZE;
-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pStart = iBlock * BLOCK_SIZE;
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             final int iHeight = pEnd - pStart;
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                 final int jWidth = qEnd - qStart;
 
                 // allocate new block
@@ -240,9 +226,7 @@
                     System.arraycopy(rawData[p], qStart, block, index, jWidth);
                     index += jWidth;
                 }
-
                 ++blockIndex;
-
             }
         }
 
@@ -262,19 +246,18 @@
      * @see #BlockRealMatrix(int, int, double[][], boolean)
      */
     public static double[][] createBlocksLayout(final int rows, final int columns) {
-
-        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
+        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;
         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;
 
         final double[][] blocks = new double[blockRows * blockColumns][];
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
-            final int pStart  = iBlock * BLOCK_SIZE;
-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pStart = iBlock * BLOCK_SIZE;
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             final int iHeight = pEnd - pStart;
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                 final int jWidth = qEnd - qStart;
                 blocks[blockIndex] = new double[iHeight * jWidth];
                 ++blockIndex;
@@ -286,15 +269,13 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension)
-        throws IllegalArgumentException {
+    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension) {
         return new BlockRealMatrix(rowDimension, columnDimension);
     }
 
     /** {@inheritDoc} */
     @Override
     public BlockRealMatrix copy() {
-
         // create an empty matrix
         BlockRealMatrix copied = new BlockRealMatrix(rows, columns);
 
@@ -308,12 +289,10 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix add(final RealMatrix m)
-        throws IllegalArgumentException {
+    public BlockRealMatrix add(final RealMatrix m) {
         try {
             return add((BlockRealMatrix) m);
         } catch (ClassCastException cce) {
-
             // safety check
             MatrixUtils.checkAdditionCompatible(this, m);
 
@@ -327,10 +306,10 @@
                     // perform addition on the current block
                     final double[] outBlock = out.blocks[blockIndex];
                     final double[] tBlock   = blocks[blockIndex];
-                    final int      pStart   = iBlock * BLOCK_SIZE;
-                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);
-                    final int      qStart   = jBlock * BLOCK_SIZE;
-                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final int pStart = iBlock * BLOCK_SIZE;
+                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
+                    final int qStart = jBlock * BLOCK_SIZE;
+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                     int k = 0;
                     for (int p = pStart; p < pEnd; ++p) {
                         for (int q = qStart; q < qEnd; ++q) {
@@ -338,10 +317,8 @@
                             ++k;
                         }
                     }
-
                     // go to next block
                     ++blockIndex;
-
                 }
             }
 
@@ -350,15 +327,14 @@
     }
 
     /**
-     * Compute the sum of this and <code>m</code>.
+     * Compute the sum of this matrix and {@code m}.
      *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be added.
+     * @return {@code this} + m.
+     * @throws MatrixDimensionMismatchException if {@code m} is not the same
+     * size as this matrix.
      */
-    public BlockRealMatrix add(final BlockRealMatrix m)
-        throws IllegalArgumentException {
-
+    public BlockRealMatrix add(final BlockRealMatrix m) {
         // safety check
         MatrixUtils.checkAdditionCompatible(this, m);
 
@@ -367,8 +343,8 @@
         // perform addition block-wise, to ensure good cache behavior
         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
             final double[] outBlock = out.blocks[blockIndex];
-            final double[] tBlock   = blocks[blockIndex];
-            final double[] mBlock   = m.blocks[blockIndex];
+            final double[] tBlock = blocks[blockIndex];
+            final double[] mBlock = m.blocks[blockIndex];
             for (int k = 0; k < outBlock.length; ++k) {
                 outBlock[k] = tBlock[k] + mBlock[k];
             }
@@ -379,12 +355,10 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix subtract(final RealMatrix m)
-        throws IllegalArgumentException {
+    public BlockRealMatrix subtract(final RealMatrix m) {
         try {
             return subtract((BlockRealMatrix) m);
         } catch (ClassCastException cce) {
-
             // safety check
             MatrixUtils.checkSubtractionCompatible(this, m);
 
@@ -397,11 +371,11 @@
 
                     // perform subtraction on the current block
                     final double[] outBlock = out.blocks[blockIndex];
-                    final double[] tBlock   = blocks[blockIndex];
-                    final int      pStart   = iBlock * BLOCK_SIZE;
-                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);
-                    final int      qStart   = jBlock * BLOCK_SIZE;
-                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final double[] tBlock = blocks[blockIndex];
+                    final int pStart = iBlock * BLOCK_SIZE;
+                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
+                    final int qStart = jBlock * BLOCK_SIZE;
+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                     int k = 0;
                     for (int p = pStart; p < pEnd; ++p) {
                         for (int q = qStart; q < qEnd; ++q) {
@@ -409,10 +383,8 @@
                             ++k;
                         }
                     }
-
                     // go to next block
                     ++blockIndex;
-
                 }
             }
 
@@ -421,15 +393,14 @@
     }
 
     /**
-     * Compute this minus <code>m</code>.
+     * Subtract {@code m} from this matrix.
      *
-     * @param m    matrix to be subtracted
-     * @return     this - m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be subtracted.
+     * @return {@code this} - m.
+     * @throws MatrixDimensionMismatchException if {@code m} is not the
+     * same size as this matrix.
      */
-    public BlockRealMatrix subtract(final BlockRealMatrix m)
-        throws IllegalArgumentException {
-
+    public BlockRealMatrix subtract(final BlockRealMatrix m) {
         // safety check
         MatrixUtils.checkSubtractionCompatible(this, m);
 
@@ -438,8 +409,8 @@
         // perform subtraction block-wise, to ensure good cache behavior
         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
             final double[] outBlock = out.blocks[blockIndex];
-            final double[] tBlock   = blocks[blockIndex];
-            final double[] mBlock   = m.blocks[blockIndex];
+            final double[] tBlock = blocks[blockIndex];
+            final double[] mBlock = m.blocks[blockIndex];
             for (int k = 0; k < outBlock.length; ++k) {
                 outBlock[k] = tBlock[k] - mBlock[k];
             }
@@ -450,15 +421,14 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix scalarAdd(final double d)
-        throws IllegalArgumentException {
+    public BlockRealMatrix scalarAdd(final double d) {
 
         final BlockRealMatrix out = new BlockRealMatrix(rows, columns);
 
         // perform subtraction block-wise, to ensure good cache behavior
         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
             final double[] outBlock = out.blocks[blockIndex];
-            final double[] tBlock   = blocks[blockIndex];
+            final double[] tBlock = blocks[blockIndex];
             for (int k = 0; k < outBlock.length; ++k) {
                 outBlock[k] = tBlock[k] + d;
             }
@@ -469,15 +439,13 @@
 
     /** {@inheritDoc} */
     @Override
-    public RealMatrix scalarMultiply(final double d)
-        throws IllegalArgumentException {
-
+    public RealMatrix scalarMultiply(final double d) {
         final BlockRealMatrix out = new BlockRealMatrix(rows, columns);
 
         // perform subtraction block-wise, to ensure good cache behavior
         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {
             final double[] outBlock = out.blocks[blockIndex];
-            final double[] tBlock   = blocks[blockIndex];
+            final double[] tBlock = blocks[blockIndex];
             for (int k = 0; k < outBlock.length; ++k) {
                 outBlock[k] = tBlock[k] * d;
             }
@@ -488,12 +456,10 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix multiply(final RealMatrix m)
-        throws IllegalArgumentException {
+    public BlockRealMatrix multiply(final RealMatrix m) {
         try {
             return multiply((BlockRealMatrix) m);
         } catch (ClassCastException cce) {
-
             // safety check
             MatrixUtils.checkMultiplicationCompatible(this, m);
 
@@ -502,27 +468,25 @@
             // perform multiplication block-wise, to ensure good cache behavior
             int blockIndex = 0;
             for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {
-
                 final int pStart = iBlock * BLOCK_SIZE;
-                final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
 
                 for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {
-
                     final int qStart = jBlock * BLOCK_SIZE;
-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());
+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());
 
                     // select current block
                     final double[] outBlock = out.blocks[blockIndex];
 
                     // perform multiplication on current block
                     for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {
-                        final int kWidth      = blockWidth(kBlock);
+                        final int kWidth = blockWidth(kBlock);
                         final double[] tBlock = blocks[iBlock * blockColumns + kBlock];
-                        final int rStart      = kBlock * BLOCK_SIZE;
+                        final int rStart = kBlock * BLOCK_SIZE;
                         int k = 0;
                         for (int p = pStart; p < pEnd; ++p) {
                             final int lStart = (p - pStart) * kWidth;
-                            final int lEnd   = lStart + kWidth;
+                            final int lEnd = lStart + kWidth;
                             for (int q = qStart; q < qEnd; ++q) {
                                 double sum = 0;
                                 int r = rStart;
@@ -535,10 +499,8 @@
                             }
                         }
                     }
-
                     // go to next block
                     ++blockIndex;
-
                 }
             }
 
@@ -547,15 +509,14 @@
     }
 
     /**
-     * Returns the result of postmultiplying this by m.
+     * Returns the result of postmultiplying this by {@code m}.
      *
-     * @param m    matrix to postmultiply by
-     * @return     this * m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
+     * @param m Matrix to postmultiply by.
+     * @return {@code this} * m.
+     * @throws MatrixDimensionMismatchException if the matrices are not
+     * compatible.
      */
-    public BlockRealMatrix multiply(BlockRealMatrix m) throws IllegalArgumentException {
-
+    public BlockRealMatrix multiply(BlockRealMatrix m) {
         // safety check
         MatrixUtils.checkMultiplicationCompatible(this, m);
 
@@ -566,7 +527,7 @@
         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {
 
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
 
             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {
                 final int jWidth = out.blockWidth(jBlock);
@@ -585,7 +546,7 @@
                     int k = 0;
                     for (int p = pStart; p < pEnd; ++p) {
                         final int lStart = (p - pStart) * kWidth;
-                        final int lEnd   = lStart + kWidth;
+                        final int lEnd = lStart + kWidth;
                         for (int nStart = 0; nStart < jWidth; ++nStart) {
                             double sum = 0;
                             int l = lStart;
@@ -607,10 +568,8 @@
                         }
                     }
                 }
-
                 // go to next block
                 ++blockIndex;
-
             }
         }
 
@@ -620,19 +579,18 @@
     /** {@inheritDoc} */
     @Override
     public double[][] getData() {
-
         final double[][] data = new double[getRowDimension()][getColumnDimension()];
         final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;
 
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
-            int regularPos   = 0;
-            int lastPos      = 0;
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
+            int regularPos = 0;
+            int lastPos = 0;
             for (int p = pStart; p < pEnd; ++p) {
                 final double[] dataP = data[p];
                 int blockIndex = iBlock * blockColumns;
-                int dataPos    = 0;
+                int dataPos = 0;
                 for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {
                     System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);
                     dataPos += BLOCK_SIZE;
@@ -687,9 +645,7 @@
     /** {@inheritDoc} */
     @Override
     public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,
-                                   final int startColumn, final int endColumn)
-        throws MatrixIndexException {
-
+                                        final int startColumn, final int endColumn) {
         // safety checks
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
 
@@ -698,10 +654,10 @@
             new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);
 
         // compute blocks shifts
-        final int blockStartRow    = startRow    / BLOCK_SIZE;
-        final int rowsShift        = startRow    % BLOCK_SIZE;
+        final int blockStartRow = startRow / BLOCK_SIZE;
+        final int rowsShift = startRow % BLOCK_SIZE;
         final int blockStartColumn = startColumn / BLOCK_SIZE;
-        final int columnsShift     = startColumn % BLOCK_SIZE;
+        final int columnsShift = startColumn % BLOCK_SIZE;
 
         // perform extraction block-wise, to ensure good cache behavior
         int pBlock = blockStartRow;
@@ -712,13 +668,13 @@
                 final int jWidth = out.blockWidth(jBlock);
 
                 // handle one block of the output matrix
-                final int      outIndex = iBlock * out.blockColumns + jBlock;
+                final int outIndex = iBlock * out.blockColumns + jBlock;
                 final double[] outBlock = out.blocks[outIndex];
-                final int      index    = pBlock * blockColumns + qBlock;
-                final int      width    = blockWidth(qBlock);
+                final int index = pBlock * blockColumns + qBlock;
+                final int width = blockWidth(qBlock);
 
                 final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;
-                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;
+                final int widthExcess = jWidth + columnsShift - BLOCK_SIZE;
                 if (heightExcess > 0) {
                     // the submatrix block spans on two blocks rows from the original matrix
                     if (widthExcess > 0) {
@@ -772,13 +728,9 @@
                                       outBlock, jWidth, 0, 0);
                     }
                }
-
                 ++qBlock;
-
             }
-
             ++pBlock;
-
         }
 
         return out;
@@ -816,15 +768,13 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)
-        throws MatrixIndexException {
-
+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {
         // safety checks
         final int refLength = subMatrix[0].length;
         if (refLength == 0) {
             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
         }
-        final int endRow    = row + subMatrix.length - 1;
+        final int endRow = row + subMatrix.length - 1;
         final int endColumn = column + refLength - 1;
         MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
         for (final double[] subRow : subMatrix) {
@@ -834,24 +784,24 @@
         }
 
         // compute blocks bounds
-        final int blockStartRow    = row / BLOCK_SIZE;
-        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;
+        final int blockStartRow = row / BLOCK_SIZE;
+        final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE;
         final int blockStartColumn = column / BLOCK_SIZE;
-        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;
+        final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;
 
         // perform copy block-wise, to ensure good cache behavior
         for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
-            final int iHeight  = blockHeight(iBlock);
+            final int iHeight = blockHeight(iBlock);
             final int firstRow = iBlock * BLOCK_SIZE;
-            final int iStart   = FastMath.max(row,    firstRow);
-            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);
+            final int iStart = FastMath.max(row,    firstRow);
+            final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight);
 
             for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
-                final int jWidth      = blockWidth(jBlock);
+                final int jWidth = blockWidth(jBlock);
                 final int firstColumn = jBlock * BLOCK_SIZE;
-                final int jStart      = FastMath.max(column,    firstColumn);
-                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);
-                final int jLength     = jEnd - jStart;
+                final int jStart = FastMath.max(column,    firstColumn);
+                final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth);
+                final int jLength = jEnd - jStart;
 
                 // handle one block, row by row
                 final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -867,22 +817,20 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix getRowMatrix(final int row)
-        throws MatrixIndexException {
-
+    public BlockRealMatrix getRowMatrix(final int row) {
         MatrixUtils.checkRowIndex(this, row);
         final BlockRealMatrix out = new BlockRealMatrix(1, columns);
 
         // perform copy block-wise, to ensure good cache behavior
-        final int iBlock  = row / BLOCK_SIZE;
-        final int iRow    = row - iBlock * BLOCK_SIZE;
+        final int iBlock = row / BLOCK_SIZE;
+        final int iRow = row - iBlock * BLOCK_SIZE;
         int outBlockIndex = 0;
-        int outIndex      = 0;
+        int outIndex = 0;
         double[] outBlock = out.blocks[outBlockIndex];
         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
-            final int jWidth     = blockWidth(jBlock);
+            final int jWidth = blockWidth(jBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
-            final int available  = outBlock.length - outIndex;
+            final int available = outBlock.length - outIndex;
             if (jWidth > available) {
                 System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);
                 outBlock = out.blocks[++outBlockIndex];
@@ -914,9 +862,10 @@
      * @param row the row to be set
      * @param matrix row matrix (must have one row and the same number of columns
      * as the instance)
-     * @throws MatrixIndexException if the specified row index is invalid
-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one
-     * instance row
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified row index is invalid.
+     * @throws MatrixDimensionMismatchException if the matrix dimensions do
+     * not match one instance row.
      */
     public void setRowMatrix(final int row, final BlockRealMatrix matrix) {
         MatrixUtils.checkRowIndex(this, row);
@@ -930,12 +879,12 @@
 
         // perform copy block-wise, to ensure good cache behavior
         final int iBlock = row / BLOCK_SIZE;
-        final int iRow   = row - iBlock * BLOCK_SIZE;
-        int mBlockIndex  = 0;
-        int mIndex       = 0;
-        double[] mBlock  = matrix.blocks[mBlockIndex];
+        final int iRow = row - iBlock * BLOCK_SIZE;
+        int mBlockIndex = 0;
+        int mIndex = 0;
+        double[] mBlock = matrix.blocks[mBlockIndex];
         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
-            final int jWidth     = blockWidth(jBlock);
+            final int jWidth = blockWidth(jBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
             final int available  = mBlock.length - mIndex;
             if (jWidth > available) {
@@ -952,18 +901,16 @@
 
     /** {@inheritDoc} */
     @Override
-    public BlockRealMatrix getColumnMatrix(final int column)
-        throws MatrixIndexException {
-
+    public BlockRealMatrix getColumnMatrix(final int column) {
         MatrixUtils.checkColumnIndex(this, column);
         final BlockRealMatrix out = new BlockRealMatrix(rows, 1);
 
         // perform copy block-wise, to ensure good cache behavior
-        final int jBlock  = column / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
         final int jColumn = column - jBlock * BLOCK_SIZE;
-        final int jWidth  = blockWidth(jBlock);
+        final int jWidth = blockWidth(jBlock);
         int outBlockIndex = 0;
-        int outIndex      = 0;
+        int outIndex = 0;
         double[] outBlock = out.blocks[outBlockIndex];
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int iHeight = blockHeight(iBlock);
@@ -997,9 +944,10 @@
      * @param column the column to be set
      * @param matrix column matrix (must have one column and the same number of rows
      * as the instance)
-     * @throws MatrixIndexException if the specified column index is invalid
-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one
-     * instance column
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified column index is invalid.
+     * @throws MatrixDimensionMismatchException if the matrix dimensions do
+     * not match one instance column.
      */
     void setColumnMatrix(final int column, final BlockRealMatrix matrix) {
         MatrixUtils.checkColumnIndex(this, column);
@@ -1012,11 +960,11 @@
         }
 
         // perform copy block-wise, to ensure good cache behavior
-        final int jBlock  = column / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
         final int jColumn = column - jBlock * BLOCK_SIZE;
-        final int jWidth  = blockWidth(jBlock);
+        final int jWidth = blockWidth(jBlock);
         int mBlockIndex = 0;
-        int mIndex      = 0;
+        int mIndex = 0;
         double[] mBlock = matrix.blocks[mBlockIndex];
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int iHeight = blockHeight(iBlock);
@@ -1033,18 +981,16 @@
 
     /** {@inheritDoc} */
     @Override
-    public RealVector getRowVector(final int row)
-        throws MatrixIndexException {
-
+    public RealVector getRowVector(final int row) {
         MatrixUtils.checkRowIndex(this, row);
         final double[] outData = new double[columns];
 
         // perform copy block-wise, to ensure good cache behavior
-        final int iBlock  = row / BLOCK_SIZE;
-        final int iRow    = row - iBlock * BLOCK_SIZE;
-        int outIndex      = 0;
+        final int iBlock = row / BLOCK_SIZE;
+        final int iRow = row - iBlock * BLOCK_SIZE;
+        int outIndex = 0;
         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
-            final int jWidth     = blockWidth(jBlock);
+            final int jWidth = blockWidth(jBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
             System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);
             outIndex += jWidth;
@@ -1065,17 +1011,15 @@
 
     /** {@inheritDoc} */
     @Override
-    public RealVector getColumnVector(final int column)
-        throws MatrixIndexException {
-
+    public RealVector getColumnVector(final int column) {
         MatrixUtils.checkColumnIndex(this, column);
         final double[] outData = new double[rows];
 
         // perform copy block-wise, to ensure good cache behavior
-        final int jBlock  = column / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
         final int jColumn = column - jBlock * BLOCK_SIZE;
-        final int jWidth  = blockWidth(jBlock);
-        int outIndex      = 0;
+        final int jWidth = blockWidth(jBlock);
+        int outIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int iHeight = blockHeight(iBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -1099,16 +1043,14 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] getRow(final int row)
-        throws MatrixIndexException {
-
+    public double[] getRow(final int row) {
         MatrixUtils.checkRowIndex(this, row);
         final double[] out = new double[columns];
 
         // perform copy block-wise, to ensure good cache behavior
-        final int iBlock  = row / BLOCK_SIZE;
-        final int iRow    = row - iBlock * BLOCK_SIZE;
-        int outIndex      = 0;
+        final int iBlock = row / BLOCK_SIZE;
+        final int iRow = row - iBlock * BLOCK_SIZE;
+        int outIndex = 0;
         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
             final int jWidth     = blockWidth(jBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -1129,9 +1071,9 @@
         }
 
         // perform copy block-wise, to ensure good cache behavior
-        final int iBlock  = row / BLOCK_SIZE;
-        final int iRow    = row - iBlock * BLOCK_SIZE;
-        int outIndex      = 0;
+        final int iBlock = row / BLOCK_SIZE;
+        final int iRow = row - iBlock * BLOCK_SIZE;
+        int outIndex = 0;
         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
             final int jWidth     = blockWidth(jBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -1142,9 +1084,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] getColumn(final int column)
-        throws MatrixIndexException {
-
+    public double[] getColumn(final int column) {
         MatrixUtils.checkColumnIndex(this, column);
         final double[] out = new double[rows];
 
@@ -1152,7 +1092,7 @@
         final int jBlock  = column / BLOCK_SIZE;
         final int jColumn = column - jBlock * BLOCK_SIZE;
         final int jWidth  = blockWidth(jBlock);
-        int outIndex      = 0;
+        int outIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int iHeight = blockHeight(iBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -1176,8 +1116,8 @@
         // perform copy block-wise, to ensure good cache behavior
         final int jBlock  = column / BLOCK_SIZE;
         final int jColumn = column - jBlock * BLOCK_SIZE;
-        final int jWidth  = blockWidth(jBlock);
-        int outIndex      = 0;
+        final int jWidth = blockWidth(jBlock);
+        int outIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int iHeight = blockHeight(iBlock);
             final double[] block = blocks[iBlock * blockColumns + jBlock];
@@ -1189,76 +1129,51 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getEntry(final int row, final int column)
-        throws MatrixIndexException {
-        try {
-            final int iBlock = row    / BLOCK_SIZE;
-            final int jBlock = column / BLOCK_SIZE;
-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
-                               (column - jBlock * BLOCK_SIZE);
-            return blocks[iBlock * blockColumns + jBlock][k];
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
+    public double getEntry(final int row, final int column) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        final int iBlock = row / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
+            (column - jBlock * BLOCK_SIZE);
+        return blocks[iBlock * blockColumns + jBlock][k];
     }
 
     /** {@inheritDoc} */
     @Override
-    public void setEntry(final int row, final int column, final double value)
-        throws MatrixIndexException {
-        try {
-            final int iBlock = row    / BLOCK_SIZE;
-            final int jBlock = column / BLOCK_SIZE;
-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
-                               (column - jBlock * BLOCK_SIZE);
-            blocks[iBlock * blockColumns + jBlock][k] = value;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
+    public void setEntry(final int row, final int column, final double value) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        final int iBlock = row / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
+            (column - jBlock * BLOCK_SIZE);
+        blocks[iBlock * blockColumns + jBlock][k] = value;
     }
 
     /** {@inheritDoc} */
     @Override
-    public void addToEntry(final int row, final int column, final double increment)
-        throws MatrixIndexException {
-        try {
-            final int iBlock = row    / BLOCK_SIZE;
-            final int jBlock = column / BLOCK_SIZE;
-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
-                               (column - jBlock * BLOCK_SIZE);
-            blocks[iBlock * blockColumns + jBlock][k] += increment;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
+    public void addToEntry(final int row, final int column, final double increment) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        final int iBlock = row    / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
+        final int k = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
+            (column - jBlock * BLOCK_SIZE);
+        blocks[iBlock * blockColumns + jBlock][k] += increment;
     }
 
     /** {@inheritDoc} */
     @Override
-    public void multiplyEntry(final int row, final int column, final double factor)
-        throws MatrixIndexException {
-        try {
-            final int iBlock = row    / BLOCK_SIZE;
-            final int jBlock = column / BLOCK_SIZE;
-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
-                               (column - jBlock * BLOCK_SIZE);
-            blocks[iBlock * blockColumns + jBlock][k] *= factor;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
+    public void multiplyEntry(final int row, final int column, final double factor) {
+        MatrixUtils.checkMatrixIndex(this, row, column);
+        final int iBlock = row / BLOCK_SIZE;
+        final int jBlock = column / BLOCK_SIZE;
+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +
+            (column - jBlock * BLOCK_SIZE);
+        blocks[iBlock * blockColumns + jBlock][k] *= factor;
     }
 
     /** {@inheritDoc} */
     @Override
     public BlockRealMatrix transpose() {
-
         final int nRows = getRowDimension();
         final int nCols = getColumnDimension();
         final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);
@@ -1267,14 +1182,13 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {
             for (int jBlock = 0; jBlock < blockRows; ++jBlock) {
-
                 // transpose current block
                 final double[] outBlock = out.blocks[blockIndex];
-                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];
-                final int      pStart   = iBlock * BLOCK_SIZE;
-                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);
-                final int      qStart   = jBlock * BLOCK_SIZE;
-                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);
+                final double[] tBlock = blocks[jBlock * blockColumns + iBlock];
+                final int pStart = iBlock * BLOCK_SIZE;
+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);
+                final int qStart = jBlock * BLOCK_SIZE;
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     final int lInc = pEnd - pStart;
@@ -1285,10 +1199,8 @@
                         l+= lInc;
                     }
                 }
-
                 // go to next block
                 ++blockIndex;
-
             }
         }
 
@@ -1309,9 +1221,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] operate(final double[] v)
-        throws IllegalArgumentException {
-
+    public double[] operate(final double[] v) {
         if (v.length != columns) {
             throw new DimensionMismatchException(v.length, columns);
         }
@@ -1320,11 +1230,11 @@
         // perform multiplication block-wise, to ensure good cache behavior
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final double[] block  = blocks[iBlock * blockColumns + jBlock];
-                final int      qStart = jBlock * BLOCK_SIZE;
-                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qStart = jBlock * BLOCK_SIZE;
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     double sum = 0;
@@ -1350,9 +1260,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double[] preMultiply(final double[] v)
-        throws IllegalArgumentException {
-
+    public double[] preMultiply(final double[] v) {
         if (v.length != rows) {
             throw new DimensionMismatchException(v.length, rows);
         }
@@ -1365,11 +1273,11 @@
             final int jWidth3 = jWidth2 + jWidth;
             final int jWidth4 = jWidth3 + jWidth;
             final int qStart = jBlock * BLOCK_SIZE;
-            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
             for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
                 final double[] block  = blocks[iBlock * blockColumns + jBlock];
-                final int      pStart = iBlock * BLOCK_SIZE;
-                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+                final int pStart = iBlock * BLOCK_SIZE;
+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
                 for (int q = qStart; q < qEnd; ++q) {
                     int k = q - qStart;
                     double sum = 0;
@@ -1401,12 +1309,12 @@
         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int qStart = jBlock * BLOCK_SIZE;
-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                     final double[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - pStart) * jWidth;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1426,12 +1334,12 @@
         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int qStart = jBlock * BLOCK_SIZE;
-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                     final double[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - pStart) * jWidth;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1449,19 +1357,19 @@
     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
-            final int p0     = iBlock * BLOCK_SIZE;
+            final int p0 = iBlock * BLOCK_SIZE;
             final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
-                    final int q0     = jBlock * BLOCK_SIZE;
+                    final int q0 = jBlock * BLOCK_SIZE;
                     final int qStart = FastMath.max(startColumn, q0);
-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                     final double[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - p0) * jWidth + qStart - q0;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1479,19 +1387,19 @@
     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
-            final int p0     = iBlock * BLOCK_SIZE;
+            final int p0 = iBlock * BLOCK_SIZE;
             final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
-                    final int q0     = jBlock * BLOCK_SIZE;
+                    final int q0 = jBlock * BLOCK_SIZE;
                     final int qStart = FastMath.max(startColumn, q0);
-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                     final double[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - p0) * jWidth + qStart - q0;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1512,10 +1420,10 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                 final double[] block = blocks[blockIndex];
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
@@ -1538,10 +1446,10 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);
                 final double[] block = blocks[blockIndex];
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
@@ -1561,18 +1469,18 @@
     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,
                                        final int startRow, final int endRow,
                                        final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
-            final int p0     = iBlock * BLOCK_SIZE;
+            final int p0 = iBlock * BLOCK_SIZE;
             final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                 final int jWidth = blockWidth(jBlock);
-                final int q0     = jBlock * BLOCK_SIZE;
+                final int q0 = jBlock * BLOCK_SIZE;
                 final int qStart = FastMath.max(startColumn, q0);
-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                 final double[] block = blocks[iBlock * blockColumns + jBlock];
                 for (int p = pStart; p < pEnd; ++p) {
                     int k = (p - p0) * jWidth + qStart - q0;
@@ -1591,18 +1499,18 @@
     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,
                                        final int startRow, final int endRow,
                                        final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
+        throws MatrixVisitorException {
         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
-            final int p0     = iBlock * BLOCK_SIZE;
+            final int p0 = iBlock * BLOCK_SIZE;
             final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                 final int jWidth = blockWidth(jBlock);
-                final int q0     = jBlock * BLOCK_SIZE;
+                final int q0 = jBlock * BLOCK_SIZE;
                 final int qStart = FastMath.max(startColumn, q0);
-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                 final double[] block = blocks[iBlock * blockColumns + jBlock];
                 for (int p = pStart; p < pEnd; ++p) {
                     int k = (p - p0) * jWidth + qStart - q0;
diff --git a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java
index 4721c87..3f19162 100644
--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java
@@ -34,112 +34,120 @@
 
     /**
      * Get the type of field elements of the matrix.
-     * @return type of field elements of the matrix
+     *
+     * @return the type of field elements of the matrix.
      */
     Field<T> getField();
 
     /**
-     * Create a new FieldMatrix<T> of the same type as the instance with the supplied
-     * row and column dimensions.
+     * Create a new FieldMatrix<T> of the same type as the instance with
+     * the supplied row and column dimensions.
      *
      * @param rowDimension  the number of rows in the new matrix
      * @param columnDimension  the number of columns in the new matrix
      * @return a new matrix of the same type as the instance
-     * @throws IllegalArgumentException if row or column dimension is not positive
+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException
+     * if row or column dimension is not positive.
      * @since 2.0
      */
     FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);
 
     /**
-     * Returns a (deep) copy of this.
+     * Make a (deep) copy of this.
      *
-     * @return matrix copy
+     * @return a copy of this matrix.
      */
     FieldMatrix<T> copy();
 
     /**
      * Compute the sum of this and m.
      *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be added.
+     * @return {@code this} + {@code m}.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
     FieldMatrix<T> add(FieldMatrix<T> m);
 
     /**
-     * Compute this minus m.
+     * Subtract {@code m} from this matrix.
      *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be subtracted.
+     * @return {@code this} - {@code m}.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
     FieldMatrix<T> subtract(FieldMatrix<T> m);
 
      /**
-     * Returns the result of adding d to each entry of this.
+     * Increment each entry of this matrix.
      *
-     * @param d    value to be added to each entry
-     * @return     d + this
+     * @param d Value to be added to each entry.
+     * @return {@code d} + {@code this}.
      */
     FieldMatrix<T> scalarAdd(T d);
 
     /**
-     * Returns the result multiplying each entry of this by d.
+     * Multiply each entry by {@code d}.
      *
-     * @param d    value to multiply all entries by
-     * @return     d * this
+     * @param d Value to multiply all entries by.
+     * @return {@code d} * {@code this}.
      */
     FieldMatrix<T> scalarMultiply(T d);
 
     /**
-     * Returns the result of postmultiplying this by m.
+     * Postmultiply this matrix by {@code m}.
      *
-     * @param m    matrix to postmultiply by
-     * @return     this * m
-     * @throws     IllegalArgumentException
+     * @param m  Matrix to postmultiply by.
+     * @return {@code this} * {@code m}.
+     * @throws IllegalArgumentException
      *             if columnDimension(this) != rowDimension(m)
      */
     FieldMatrix<T> multiply(FieldMatrix<T> m);
 
     /**
-     * Returns the result premultiplying this by <code>m</code>.
-     * @param m    matrix to premultiply by
-     * @return     m * this
-     * @throws     IllegalArgumentException
-     *             if rowDimension(this) != columnDimension(m)
+     * Premultiply this matrix by {@code m}.
+     *
+     * @param m Matrix to premultiply by.
+     * @return {@code m} * {@code this}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if the number of columns of {@code m} differ from the number of rows
+     * of this matrix.
      */
     FieldMatrix<T> preMultiply(FieldMatrix<T> m);
 
     /**
      * Returns matrix entries as a two-dimensional array.
      *
-     * @return    2-dimensional array of entries
+     * @return a 2-dimensional array of entries.
      */
     T[][] getData();
 
     /**
-     * Gets a submatrix. Rows and columns are indicated
-     * counting from 0 to n-1.
+     * Get a submatrix. Rows and columns are indicated
+     * counting from 0 to n - 1.
      *
      * @param startRow Initial row index
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index (inclusive)
-     * @return The subMatrix containing the data of the
-     *         specified rows and columns
-     * @exception MatrixIndexException  if the indices are not valid
+     * @return the matrix containing the data of the
+     * specified rows and columns.
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      */
    FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);
 
    /**
-    * Gets a submatrix. Rows and columns are indicated
-    * counting from 0 to n-1.
+    * Get a submatrix. Rows and columns are indicated
+    * counting from 0 to n - 1.
     *
     * @param selectedRows Array of row indices.
     * @param selectedColumns Array of column indices.
-    * @return The subMatrix containing the data in the
-    *         specified rows and columns
-    * @exception MatrixIndexException if row or column selections are not valid
+    * @return the matrix containing the data in the
+    * specified rows and columns.
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if row or column selections are not valid.
     */
    FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns);
 
@@ -147,34 +155,36 @@
     * Copy a submatrix. Rows and columns are indicated
     * counting from 0 to n-1.
     *
-    * @param startRow Initial row index
-    * @param endRow Final row index (inclusive)
-    * @param startColumn Initial column index
-    * @param endColumn Final column index (inclusive)
+    * @param startRow Initial row index.
+    * @param endRow Final row index (inclusive).
+    * @param startColumn Initial column index.
+    * @param endColumn Final column index (inclusive).
     * @param destination The arrays where the submatrix data should be copied
-    * (if larger than rows/columns counts, only the upper-left part will be used)
-    * @exception MatrixIndexException if the indices are not valid
-    * @exception IllegalArgumentException if the destination array is too small
+    * (if larger than rows/columns counts, only the upper-left part will be used).
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the indices are not valid.
+    * @exception IllegalArgumentException if the destination array is too small.
     */
   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,
                      T[][] destination);
 
   /**
    * Copy a submatrix. Rows and columns are indicated
-   * counting from 0 to n-1.
+   * counting from 0 to n - 1.
    *
-    * @param selectedRows Array of row indices.
-    * @param selectedColumns Array of column indices.
-   * @param destination The arrays where the submatrix data should be copied
+   * @param selectedRows Array of row indices.
+   * @param selectedColumns Array of column indices.
+   * @param destination Arrays where the submatrix data should be copied
    * (if larger than rows/columns counts, only the upper-left part will be used)
-   * @exception MatrixIndexException if the indices are not valid
+   * @throws org.apache.commons.math.exception.OutOfRangeException
+   * if the indices are not valid.
    * @exception IllegalArgumentException if the destination array is too small
    */
   void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination);
 
    /**
-    * Replace the submatrix starting at <code>row, column</code> using data in
-    * the input <code>subMatrix</code> array. Indexes are 0-based.
+    * Replace the submatrix starting at {@code (row, column)} using data in
+    * the input {@code subMatrix} array. Indexes are 0-based.
     * <p>
     * Example:<br>
     * Starting with <pre>
@@ -189,152 +199,165 @@
     * 9  5  6  2
     * </pre></p>
     *
-    * @param subMatrix  array containing the submatrix replacement data
-    * @param row  row coordinate of the top, left element to be replaced
-    * @param column  column coordinate of the top, left element to be replaced
-    * @throws MatrixIndexException  if subMatrix does not fit into this
-    *    matrix from element in (row, column)
-    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
-    *  (not all rows have the same length) or empty
-    * @throws NullPointerException if <code>subMatrix</code> is null
+    * @param subMatrix Array containing the submatrix replacement data.
+    * @param row Row coordinate of the top-left element to be replaced.
+    * @param column Column coordinate of the top-left element to be replaced.
+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+    * if {@code subMatrix} does not fit into this matrix from element in
+    * {@code (row, column)}.
+    * @throws org.apache.commons.math.exception.ZeroException if a row or column
+    * of {@code subMatrix} is empty.
+    * @throws org.apache.commons.math.exception.DimensionMismatchException
+    * if {@code subMatrix} is not rectangular (not all rows have the same
+    * length).
+    * @throws org.apache.commons.math.exception.NullArgumentException
+    * if {@code subMatrix} is {@code null}.
     * @since 2.0
     */
   void setSubMatrix(T[][] subMatrix, int row, int column);
 
    /**
-    * Returns the entries in row number <code>row</code>
-    * as a row matrix.  Row indices start at 0.
+    * Get the entries in row number {@code row}
+    * as a row matrix.
     *
-    * @param row the row to be fetched
-    * @return row matrix
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be fetched.
+    * @return a row matrix.
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified row index is invalid.
     */
    FieldMatrix<T> getRowMatrix(int row);
 
    /**
-    * Sets the entries in row number <code>row</code>
-    * as a row matrix.  Row indices start at 0.
+    * Set the entries in row number {@code row}
+    * as a row matrix.
     *
-    * @param row the row to be set
-    * @param matrix row matrix (must have one row and the same number of columns
-    * as the instance)
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be set.
+    * @param matrix Row matrix (must have one row and the same number
+    * of columns as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified row index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the matrix dimensions do not match one instance row.
     */
    void setRowMatrix(int row, FieldMatrix<T> matrix);
 
    /**
-    * Returns the entries in column number <code>column</code>
-    * as a column matrix.  Column indices start at 0.
+    * Get the entries in column number {@code column}
+    * as a column matrix.
     *
-    * @param column the column to be fetched
-    * @return column matrix
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be fetched.
+    * @return a column matrix.
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified column index is invalid.
     */
    FieldMatrix<T> getColumnMatrix(int column);
 
    /**
-    * Sets the entries in column number <code>column</code>
-    * as a column matrix.  Column indices start at 0.
+    * Set the entries in column number {@code column}
+    * as a column matrix.
     *
-    * @param column the column to be set
-    * @param matrix column matrix (must have one column and the same number of rows
-    * as the instance)
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be set.
+    * @param matrix column matrix (must have one column and the same
+    * number of rows as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified column index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the matrix dimensions do not match one instance column.
     */
    void setColumnMatrix(int column, FieldMatrix<T> matrix);
 
    /**
-    * Returns the entries in row number <code>row</code>
-    * as a vector.  Row indices start at 0.
+    * Get the entries in row number {@code row}
+    * as a vector.
     *
-    * @param row the row to be fetched
-    * @return row vector
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be fetched
+    * @return a row vector.
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified row index is invalid.
     */
    FieldVector<T> getRowVector(int row);
 
    /**
-    * Sets the entries in row number <code>row</code>
-    * as a vector.  Row indices start at 0.
+    * Set the entries in row number {@code row}
+    * as a vector.
     *
-    * @param row the row to be set
+    * @param row Row to be set.
     * @param vector row vector (must have the same number of columns
-    * as the instance)
-    * @throws MatrixIndexException if the specified row index is invalid
+    * as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified row index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the vector dimension does not match one instance row.
     */
    void setRowVector(int row, FieldVector<T> vector);
 
    /**
-    * Returns the entries in column number <code>column</code>
-    * as a vector.  Column indices start at 0.
+    * Returns the entries in column number {@code column}
+    * as a vector.
     *
-    * @param column the column to be fetched
-    * @return column vector
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be fetched.
+    * @return a column vector.
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified column index is invalid.
     */
    FieldVector<T> getColumnVector(int column);
 
    /**
-    * Sets the entries in column number <code>column</code>
-    * as a vector.  Column indices start at 0.
+    * Set the entries in column number {@code column}
+    * as a vector.
     *
-    * @param column the column to be set
-    * @param vector column vector (must have the same number of rows as the instance)
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be set.
+    * @param vector Column vector (must have the same number of rows
+    * as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException
+    * if the specified column index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the vector dimension does not match one instance column.
     */
    void setColumnVector(int column, FieldVector<T> vector);
 
     /**
-     * Returns the entries in row number <code>row</code> as an array.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless {@code 0 <= row < rowDimension}.</p>
+     * Get the entries in row number {@code row} as an array.
      *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
+     * @param row Row to be fetched.
+     * @return array of entries in the row.
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified row index is not valid.
      */
     T[] getRow(int row);
 
     /**
-     * Sets the entries in row number <code>row</code>
-     * as a row matrix.  Row indices start at 0.
+     * Set the entries in row number {@code row}
+     * as a row matrix.
      *
-     * @param row the row to be set
-     * @param array row matrix (must have the same number of columns as the instance)
-     * @throws MatrixIndexException if the specified row index is invalid
+     * @param row Row to be set.
+     * @param array Row matrix (must have the same number of columns as
+     * the instance).
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified row index is invalid.
      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
      * if the array size does not match one instance row.
      */
     void setRow(int row, T[] array);
 
     /**
-     * Returns the entries in column number <code>col</code> as an array.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless {@code 0 <= column < columnDimension}.</p>
+     * Get the entries in column number {@code col} as an array.
      *
      * @param column the column to be fetched
      * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified column index is not valid.
      */
     T[] getColumn(int column);
 
     /**
-     * Sets the entries in column number <code>column</code>
-     * as a column matrix.  Column indices start at 0.
+     * Set the entries in column number {@code column}
+     * as a column matrix.
      *
      * @param column the column to be set
      * @param array column array (must have the same number of rows as the instance)
-     * @throws MatrixIndexException if the specified column index is invalid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the specified column index is invalid.
      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
      * if the array size does not match one instance column.
      */
@@ -342,71 +365,49 @@
 
     /**
      * Returns the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
      *
      * @param row  row location of entry to be fetched
      * @param column  column location of entry to be fetched
      * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the row or column index is not valid.
      */
     T getEntry(int row, int column);
 
     /**
      * Set the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
      *
      * @param row  row location of entry to be set
      * @param column  column location of entry to be set
      * @param value matrix entry to be set in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the row or column index is not valid.
      * @since 2.0
      */
     void setEntry(int row, int column, T value);
 
     /**
      * Change an entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
      *
-     * @param row  row location of entry to be set
-     * @param column  column location of entry to be set
-     * @param increment value to add to the current matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be set.
+     * @param column Column location of entry to be set.
+     * @param increment Value to add to the current matrix entry in
+     * {@code (row, column)}.
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the row or column index is not valid.
      * @since 2.0
      */
-    void addToEntry(int row, int column, T increment) throws MatrixIndexException;
+    void addToEntry(int row, int column, T increment);
 
     /**
      * Change an entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
      *
-     * @param row  row location of entry to be set
-     * @param column  column location of entry to be set
-     * @param factor multiplication factor for the current matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be set.
+     * @param column Column location of entry to be set.
+     * @param factor Multiplication factor for the current matrix entry
+     * in {@code (row,column)}
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the row or column index is not valid.
      * @since 2.0
      */
     void multiplyEntry(int row, int column, T factor);
@@ -520,7 +521,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)
@@ -549,7 +551,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)
@@ -624,7 +627,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)
@@ -653,7 +657,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)
@@ -725,7 +730,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index (inclusive)
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)
@@ -753,7 +759,8 @@
      * @param startColumn Initial column index
      * @param endColumn Final column index (inclusive)
      * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the indices are not valid.
      * @see #walkInRowOrder(FieldMatrixChangingVisitor)
      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)
      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)
diff --git a/src/main/java/org/apache/commons/math/linear/FieldVector.java b/src/main/java/org/apache/commons/math/linear/FieldVector.java
index 2622157..90fc29c 100644
--- a/src/main/java/org/apache/commons/math/linear/FieldVector.java
+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java
@@ -258,28 +258,24 @@
 
     /**
      * Returns the entry in the specified index.
-     * <p>
-     * The index start at 0 and must be lesser than the size,
-     * otherwise a {@link MatrixIndexException} is thrown.
-     * </p>
-     * @param index  index location of entry to be fetched
-     * @return vector entry at index
-     * @throws MatrixIndexException if the index is not valid
+     *
+     * @param index Index location of entry to be fetched.
+     * @return the vector entry at {@code index}.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * index is not valid.
      * @see #setEntry(int, FieldElement)
      */
-    T getEntry(int index)
-        throws MatrixIndexException;
+    T getEntry(int index);
 
     /**
      * Set a single element.
      * @param index element index.
      * @param value new value for the element.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is inconsistent with vector size.
      * @see #getEntry(int)
      */
-    void setEntry(int index, T value)
-        throws MatrixIndexException;
+    void setEntry(int index, T value);
 
     /**
      * Returns the size of the vector.
@@ -313,33 +309,30 @@
      * @param index index of first element.
      * @param n number of elements to be retrieved.
      * @return a vector containing n elements.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is inconsistent with vector size.
      */
-    FieldVector<T> getSubVector(int index, int n)
-        throws MatrixIndexException;
+    FieldVector<T> getSubVector(int index, int n);
 
     /**
      * Set a set of consecutive elements.
      * @param index index of first element to be set.
      * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is inconsistent with vector size.
      * @see #setSubVector(int, FieldElement[])
      */
-    void setSubVector(int index, FieldVector<T> v)
-        throws MatrixIndexException;
+    void setSubVector(int index, FieldVector<T> v);
 
     /**
      * Set a set of consecutive elements.
      * @param index index of first element to be set.
      * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is inconsistent with vector size.
      * @see #setSubVector(int, FieldVector)
      */
-    void setSubVector(int index, T[] v)
-        throws MatrixIndexException;
+    void setSubVector(int index, T[] v);
 
     /**
      * Set all elements to a single value.
diff --git a/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java b/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java
index 1fca8d8..e1e18c8 100644
--- a/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java
+++ b/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java
@@ -25,6 +25,8 @@
  * Thrown when an operation addresses a matrix coordinate (row, col)
  * which is outside of the dimensions of a matrix.
  * @version $Revision$ $Date$
+ * @deprecated in 2.2 (to be removed in 3.0). Please use the exceptions in package
+ * {@link org.apache.commons.math.exception}.
  */
 public class MatrixIndexException extends MathRuntimeException {
 
diff --git a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
index 7cf7466..200de15 100644
--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
@@ -21,12 +21,15 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.lang.reflect.Array;
-import java.math.BigDecimal;
 import java.util.Arrays;
 
 import org.apache.commons.math.Field;
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.NumberIsTooSmallException;
+import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.fraction.BigFraction;
 import org.apache.commons.math.fraction.Fraction;
@@ -97,13 +100,18 @@
      *
      * @param data input array
      * @return  RealMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if either <code>data</code> or
-     * <code>data[0]</code> is null
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code data} is not rectangular (not all rows have the same length).
+     * @throws ZeroException if a row or column is empty.
+     * @throws NullArgumentException if either {@code data} or {@code data[0]}
+     * is {@code null}.
      * @see #createRealMatrix(int, int)
      */
     public static RealMatrix createRealMatrix(double[][] data) {
+        if (data == null ||
+            data[0] == null) {
+            throw new NullArgumentException();
+        }
         return (data.length * data[0].length <= 4096) ?
                 new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);
     }
@@ -118,15 +126,20 @@
      * <p>The input array is copied, not referenced.</p>
      * @param <T> the type of the field elements
      * @param data input array
-     * @return  RealMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if either <code>data</code> or
-     * <code>data[0]</code> is null
+     * @return a matrix containing the values of the array.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code data} is not rectangular (not all rows have the same length).
+     * @throws ZeroException if a row or column is empty.
+     * @throws NullArgumentException if either {@code data} or {@code data[0]}
+     * is {@code null}.
      * @see #createFieldMatrix(Field, int, int)
      * @since 2.0
      */
     public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {
+        if (data == null ||
+            data[0] == null) {
+            throw new NullArgumentException();
+        }
         return (data.length * data[0].length <= 4096) ?
                 new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);
     }
@@ -172,26 +185,6 @@
     }
 
     /**
-     * Returns <code>dimension x dimension</code> identity matrix.
-     *
-     * @param dimension dimension of identity matrix to generate
-     * @return identity matrix
-     * @throws IllegalArgumentException if dimension is not positive
-     * @since 1.1
-     * @deprecated since 2.0, replaced by {@link #createFieldIdentityMatrix(Field, int)}
-     */
-    @Deprecated
-    public static BigMatrix createBigIdentityMatrix(int dimension) {
-        final BigDecimal[][] d = new BigDecimal[dimension][dimension];
-        for (int row = 0; row < dimension; row++) {
-            final BigDecimal[] dRow = d[row];
-            Arrays.fill(dRow, BigMatrixImpl.ZERO);
-            dRow[row] = BigMatrixImpl.ONE;
-        }
-        return new BigMatrixImpl(d, false);
-    }
-
-    /**
      * Returns a diagonal matrix with specified elements.
      *
      * @param diagonal diagonal elements of the matrix (the array elements
@@ -227,84 +220,17 @@
     }
 
     /**
-     * Returns a {@link BigMatrix} whose entries are the the values in the
-     * the input array.  The input array is copied, not referenced.
-     *
-     * @param data input array
-     * @return  RealMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if data is null
-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}
-     */
-    @Deprecated
-    public static BigMatrix createBigMatrix(double[][] data) {
-        return new BigMatrixImpl(data);
-    }
-
-    /**
-     * Returns a {@link BigMatrix} whose entries are the the values in the
-     * the input array.  The input array is copied, not referenced.
-     *
-     * @param data input array
-     * @return  RealMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if data is null
-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}
-     */
-    @Deprecated
-    public static BigMatrix createBigMatrix(BigDecimal[][] data) {
-        return new BigMatrixImpl(data);
-    }
-
-    /**
-     * Returns a {@link BigMatrix} whose entries are the the values in the
-     * the input array.
-     * <p>If an array is built specially in order to be embedded in a
-     * BigMatrix and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param data data for new matrix
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
-     * @return  BigMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>data</code> is null
-     * @see #createRealMatrix(double[][])
-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}
-     */
-    @Deprecated
-    public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {
-        return new BigMatrixImpl(data, copyArray);
-    }
-
-    /**
-     * Returns a {@link BigMatrix} whose entries are the the values in the
-     * the input array.  The input array is copied, not referenced.
-     *
-     * @param data input array
-     * @return  RealMatrix containing the values of the array
-     * @throws IllegalArgumentException if <code>data</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if data is null
-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}
-     */
-    @Deprecated
-    public static BigMatrix createBigMatrix(String[][] data) {
-        return new BigMatrixImpl(data);
-    }
-
-    /**
      * Creates a {@link RealVector} using the data from the input array.
      *
      * @param data the input data
      * @return a data.length RealVector
-     * @throws IllegalArgumentException if <code>data</code> is empty
-     * @throws NullPointerException if <code>data</code>is null
+     * @throws ZeroException if {@code data} is empty.
+     * @throws NullArgumentException if {@code data} is {@code null}.
      */
     public static RealVector createRealVector(double[] data) {
+        if (data == null) {
+            throw new NullArgumentException();
+        }
         return new ArrayRealVector(data, true);
     }
 
@@ -314,23 +240,29 @@
      * @param <T> the type of the field elements
      * @param data the input data
      * @return a data.length FieldVector
-     * @throws IllegalArgumentException if <code>data</code> is empty
-     * @throws NullPointerException if <code>data</code>is null
+     * @throws ZeroException if {@code data} is empty.
+     * @throws NullArgumentException if {@code data} is {@code null}.
      */
     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {
+        if (data == null) {
+            throw new NullArgumentException();
+        }
         return new ArrayFieldVector<T>(data, true);
     }
 
     /**
-     * Creates a row {@link RealMatrix} using the data from the input
+     * Create a row {@link RealMatrix} using the data from the input
      * array.
      *
      * @param rowData the input row data
      * @return a 1 x rowData.length RealMatrix
-     * @throws IllegalArgumentException if <code>rowData</code> is empty
-     * @throws NullPointerException if <code>rowData</code>is null
+     * @throws ZeroException if {@code rowData} is empty.
+     * @throws NullArgumentException if {@code rowData} is {@code null}.
      */
     public static RealMatrix createRowRealMatrix(double[] rowData) {
+        if (rowData == null) {
+            throw new NullArgumentException();
+        }
         final int nCols = rowData.length;
         final RealMatrix m = createRealMatrix(1, nCols);
         for (int i = 0; i < nCols; ++i) {
@@ -340,20 +272,23 @@
     }
 
     /**
-     * Creates a row {@link FieldMatrix} using the data from the input
+     * Create a row {@link FieldMatrix} using the data from the input
      * array.
      *
      * @param <T> the type of the field elements
      * @param rowData the input row data
      * @return a 1 x rowData.length FieldMatrix
-     * @throws IllegalArgumentException if <code>rowData</code> is empty
-     * @throws NullPointerException if <code>rowData</code>is null
+     * @throws ZeroException if {@code rowData} is empty.
+     * @throws NullArgumentException if {@code rowData} is {@code null}.
      */
     public static <T extends FieldElement<T>> FieldMatrix<T>
         createRowFieldMatrix(final T[] rowData) {
+        if (rowData == null) {
+            throw new NullArgumentException();
+        }
         final int nCols = rowData.length;
         if (nCols == 0) {
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
+            throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
         }
         final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);
         for (int i = 0; i < nCols; ++i) {
@@ -363,73 +298,18 @@
     }
 
     /**
-     * Creates a row {@link BigMatrix} using the data from the input
-     * array.
-     *
-     * @param rowData the input row data
-     * @return a 1 x rowData.length BigMatrix
-     * @throws IllegalArgumentException if <code>rowData</code> is empty
-     * @throws NullPointerException if <code>rowData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}
-     */
-    @Deprecated
-    public static BigMatrix createRowBigMatrix(double[] rowData) {
-        final int nCols = rowData.length;
-        final BigDecimal[][] data = new BigDecimal[1][nCols];
-        for (int i = 0; i < nCols; ++i) {
-            data[0][i] = new BigDecimal(rowData[i]);
-        }
-        return new BigMatrixImpl(data, false);
-    }
-
-    /**
-     * Creates a row {@link BigMatrix} using the data from the input
-     * array.
-     *
-     * @param rowData the input row data
-     * @return a 1 x rowData.length BigMatrix
-     * @throws IllegalArgumentException if <code>rowData</code> is empty
-     * @throws NullPointerException if <code>rowData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}
-     */
-    @Deprecated
-    public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {
-        final int nCols = rowData.length;
-        final BigDecimal[][] data = new BigDecimal[1][nCols];
-        System.arraycopy(rowData, 0, data[0], 0, nCols);
-        return new BigMatrixImpl(data, false);
-    }
-
-    /**
-     * Creates a row {@link BigMatrix} using the data from the input
-     * array.
-     *
-     * @param rowData the input row data
-     * @return a 1 x rowData.length BigMatrix
-     * @throws IllegalArgumentException if <code>rowData</code> is empty
-     * @throws NullPointerException if <code>rowData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}
-     */
-    @Deprecated
-    public static BigMatrix createRowBigMatrix(String[] rowData) {
-        final int nCols = rowData.length;
-        final BigDecimal[][] data = new BigDecimal[1][nCols];
-        for (int i = 0; i < nCols; ++i) {
-            data[0][i] = new BigDecimal(rowData[i]);
-        }
-        return new BigMatrixImpl(data, false);
-    }
-
-    /**
      * Creates a column {@link RealMatrix} using the data from the input
      * array.
      *
      * @param columnData  the input column data
      * @return a columnData x 1 RealMatrix
-     * @throws IllegalArgumentException if <code>columnData</code> is empty
-     * @throws NullPointerException if <code>columnData</code>is null
+     * @throws ZeroException if {@code columnData} is empty.
+     * @throws NullArgumentException if {@code columnData} is {@code null}.
      */
     public static RealMatrix createColumnRealMatrix(double[] columnData) {
+        if (columnData == null) {
+            throw new NullArgumentException();
+        }
         final int nRows = columnData.length;
         final RealMatrix m = createRealMatrix(nRows, 1);
         for (int i = 0; i < nRows; ++i) {
@@ -445,11 +325,14 @@
      * @param <T> the type of the field elements
      * @param columnData  the input column data
      * @return a columnData x 1 FieldMatrix
-     * @throws IllegalArgumentException if <code>columnData</code> is empty
-     * @throws NullPointerException if <code>columnData</code>is null
+     * @throws ZeroException if {@code data} is empty.
+     * @throws NullArgumentException if {@code columnData} is {@code null}.
      */
     public static <T extends FieldElement<T>> FieldMatrix<T>
         createColumnFieldMatrix(final T[] columnData) {
+        if (columnData == null) {
+            throw new NullArgumentException();
+        }
         final int nRows = columnData.length;
         if (nRows == 0) {
             throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
@@ -462,118 +345,77 @@
     }
 
     /**
-     * Creates a column {@link BigMatrix} using the data from the input
-     * array.
+     * Check if matrix indices are valid.
      *
-     * @param columnData  the input column data
-     * @return a columnData x 1 BigMatrix
-     * @throws IllegalArgumentException if <code>columnData</code> is empty
-     * @throws NullPointerException if <code>columnData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}
+     * @param m Matrix.
+     * @param row Row index to check.
+     * @param column Column index to check.
+     * @throws OutOfRangeException if {@code row} or {@code column} is not
+     * a valid index.
      */
-    @Deprecated
-    public static BigMatrix createColumnBigMatrix(double[] columnData) {
-        final int nRows = columnData.length;
-        final BigDecimal[][] data = new BigDecimal[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            data[row][0] = new BigDecimal(columnData[row]);
-        }
-        return new BigMatrixImpl(data, false);
-    }
-
-    /**
-     * Creates a column {@link BigMatrix} using the data from the input
-     * array.
-     *
-     * @param columnData  the input column data
-     * @return a columnData x 1 BigMatrix
-     * @throws IllegalArgumentException if <code>columnData</code> is empty
-     * @throws NullPointerException if <code>columnData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}
-     */
-    @Deprecated
-    public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {
-        final int nRows = columnData.length;
-        final BigDecimal[][] data = new BigDecimal[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            data[row][0] = columnData[row];
-        }
-        return new BigMatrixImpl(data, false);
-    }
-
-    /**
-     * Creates a column {@link BigMatrix} using the data from the input
-     * array.
-     *
-     * @param columnData  the input column data
-     * @return a columnData x 1 BigMatrix
-     * @throws IllegalArgumentException if <code>columnData</code> is empty
-     * @throws NullPointerException if <code>columnData</code>is null
-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}
-     */
-    @Deprecated
-    public static BigMatrix createColumnBigMatrix(String[] columnData) {
-        int nRows = columnData.length;
-        final BigDecimal[][] data = new BigDecimal[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            data[row][0] = new BigDecimal(columnData[row]);
-        }
-        return new BigMatrixImpl(data, false);
+    public static void checkMatrixIndex(final AnyMatrix m,
+                                        final int row, final int column) {
+        checkRowIndex(m, row);
+        checkColumnIndex(m, column);
     }
 
     /**
      * Check if a row index is valid.
-     * @param m matrix containing the submatrix
-     * @param row row index to check
-     * @exception MatrixIndexException if index is not valid
+     *
+     * @param m Matrix.
+     * @param row Row index to check.
+     * @throws OutOfRangeException if {@code row} is not a valid index.
      */
     public static void checkRowIndex(final AnyMatrix m, final int row) {
-        if (row < 0 || row >= m.getRowDimension()) {
-            throw new MatrixIndexException(LocalizedFormats.ROW_INDEX_OUT_OF_RANGE,
-                                           row, 0, m.getRowDimension() - 1);
+        if (row < 0 ||
+            row >= m.getRowDimension()) {
+            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,
+                                          row, 0, m.getRowDimension() - 1);
         }
     }
 
     /**
      * Check if a column index is valid.
-     * @param m matrix containing the submatrix
-     * @param column column index to check
-     * @exception MatrixIndexException if index is not valid
+     *
+     * @param m Matrix.
+     * @param column Column index to check.
+     * @throws OutOfRangeException if {@code column} is not a valid index.
      */
-    public static void checkColumnIndex(final AnyMatrix m, final int column)
-        throws MatrixIndexException {
+    public static void checkColumnIndex(final AnyMatrix m, final int column) {
         if (column < 0 || column >= m.getColumnDimension()) {
-            throw new MatrixIndexException(LocalizedFormats.COLUMN_INDEX_OUT_OF_RANGE,
+            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,
                                            column, 0, m.getColumnDimension() - 1);
         }
     }
 
     /**
      * Check if submatrix ranges indices are valid.
-     * Rows and columns are indicated counting from 0 to n-1.
+     * Rows and columns are indicated counting from 0 to {@code n - 1}.
      *
-     * @param m matrix containing the submatrix
-     * @param startRow Initial row index
-     * @param endRow Final row index
-     * @param startColumn Initial column index
-     * @param endColumn Final column index
-     * @exception MatrixIndexException  if the indices are not valid
+     * @param m Matrix.
+     * @param startRow Initial row index.
+     * @param endRow Final row index.
+     * @param startColumn Initial column index.
+     * @param endColumn Final column index.
+     * @throws OutOfRangeException if the indices are invalid.
+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or
+     * {@code endColumn < startColumn}.
      */
     public static void checkSubMatrixIndex(final AnyMatrix m,
                                            final int startRow, final int endRow,
                                            final int startColumn, final int endColumn) {
         checkRowIndex(m, startRow);
         checkRowIndex(m, endRow);
-        if (startRow > endRow) {
-            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,
-                                           startRow, endRow);
+        if (endRow < startRow) {
+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,
+                                                endRow, startRow, false);
         }
 
         checkColumnIndex(m, startColumn);
         checkColumnIndex(m, endColumn);
-        if (startColumn > endColumn) {
-            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,
-                                           startColumn, endColumn);
+        if (endColumn < startColumn) {
+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,
+                                                endColumn, startColumn, false);
         }
 
 
@@ -583,19 +425,29 @@
      * Check if submatrix ranges indices are valid.
      * Rows and columns are indicated counting from 0 to n-1.
      *
-     * @param m matrix containing the submatrix
+     * @param m Matrix.
      * @param selectedRows Array of row indices.
      * @param selectedColumns Array of column indices.
-     * @exception MatrixIndexException if row or column selections are not valid
+     * @throws NullArgumentException if {@code selectedRows} or
+     * {@code selectedColumns} are {@code null}.
+     * @throws ZeroException if the row or column selections are empty (zero
+     * length).
+     * @throws OutOfRangeException if row or column selections are not valid.
      */
     public static void checkSubMatrixIndex(final AnyMatrix m,
-                                           final int[] selectedRows, final int[] selectedColumns)
-        throws MatrixIndexException {
-        if (selectedRows.length * selectedColumns.length == 0) {
-            if (selectedRows.length == 0) {
-                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);
-            }
-            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);
+                                           final int[] selectedRows,
+                                           final int[] selectedColumns) {
+        if (selectedRows == null) {
+            throw new NullArgumentException();
+        }
+        if (selectedColumns == null) {
+            throw new NullArgumentException();
+        }
+        if (selectedRows.length == 0) {
+            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);
+        }
+        if (selectedColumns.length == 0) {
+            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);
         }
 
         for (final int row : selectedRows) {
diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java
index cf11f2a..2f362ee 100644
--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java
@@ -27,38 +27,37 @@
  * @version $Revision$ $Date$
  * @since 2.0
  */
-public class OpenMapRealMatrix extends AbstractRealMatrix implements SparseRealMatrix, Serializable {
-
+public class OpenMapRealMatrix extends AbstractRealMatrix
+    implements SparseRealMatrix, Serializable {
     /** Serializable version identifier. */
     private static final long serialVersionUID = -5962461716457143437L;
-
     /** Number of rows of the matrix. */
     private final int rows;
-
     /** Number of columns of the matrix. */
     private final int columns;
-
     /** Storage for (sparse) matrix elements. */
     private final OpenIntToDoubleHashMap entries;
 
     /**
      * Build a sparse matrix with the supplied row and column dimensions.
-     * @param rowDimension number of rows of the matrix
-     * @param columnDimension number of columns of the matrix
+     *
+     * @param rowDimension Number of rows of the matrix.
+     * @param columnDimension Number of columns of the matrix.
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
-        this.rows    = rowDimension;
+        this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
     }
 
     /**
      * Build a matrix by copying another one.
-     * @param matrix matrix to copy
+     *
+     * @param matrix matrix to copy.
      */
     public OpenMapRealMatrix(OpenMapRealMatrix matrix) {
-        this.rows    = matrix.rows;
+        this.rows = matrix.rows;
         this.columns = matrix.columns;
         this.entries = new OpenIntToDoubleHashMap(matrix.entries);
     }
@@ -71,8 +70,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension)
-            throws IllegalArgumentException {
+    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension) {
         return new OpenMapRealMatrix(rowDimension, columnDimension);
     }
 
@@ -82,25 +80,15 @@
         return columns;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public OpenMapRealMatrix add(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return add((OpenMapRealMatrix) m);
-        } catch (ClassCastException cce) {
-            return (OpenMapRealMatrix) super.add(m);
-        }
-    }
-
     /**
-     * Compute the sum of this and <code>m</code>.
+     * Compute the sum of this matrix and {@code m}.
      *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be added.
+     * @return {@code this} + {@code m}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
-    public OpenMapRealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {
+    public OpenMapRealMatrix add(OpenMapRealMatrix m) {
 
         // safety check
         MatrixUtils.checkAdditionCompatible(this, m);
@@ -129,15 +117,15 @@
     }
 
     /**
-     * Compute this minus <code>m</code>.
+     * Subtract {@code m} from this matrix.
      *
-     * @param m    matrix to be subtracted
-     * @return     this - m
-     * @throws  IllegalArgumentException if m is not the same size as this
+     * @param m Matrix to be subtracted.
+     * @return {@code this} - {@code m}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code m} is not the same size as this matrix.
      */
-    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {
-
-        // safety check
+    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) {
+        // Safety check.
         MatrixUtils.checkAdditionCompatible(this, m);
 
         final OpenMapRealMatrix out = new OpenMapRealMatrix(this);
@@ -149,7 +137,6 @@
         }
 
         return out;
-
     }
 
     /** {@inheritDoc} */
@@ -177,21 +164,20 @@
             }
 
             return out;
-
         }
     }
 
     /**
-     * Returns the result of postmultiplying this by m.
+     * Postmultiply this matrix by {@code m}.
      *
-     * @param m    matrix to postmultiply by
-     * @return     this * m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
+     * @param m Matrix to postmultiply by.
+     * @return {@code this} * {@code m}.
+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
+     * if the number of rows of {@code m} differ from the number of columns
+     * of this matrix.
      */
-    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) throws IllegalArgumentException {
-
-        // safety check
+    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) {
+        // Safety check.
         MatrixUtils.checkMultiplicationCompatible(this, m);
 
         final int outCols = m.getColumnDimension();
@@ -218,12 +204,11 @@
         }
 
         return out;
-
     }
 
     /** {@inheritDoc} */
     @Override
-    public double getEntry(int row, int column) throws MatrixIndexException {
+    public double getEntry(int row, int column) {
         MatrixUtils.checkRowIndex(this, row);
         MatrixUtils.checkColumnIndex(this, column);
         return entries.get(computeKey(row, column));
@@ -237,8 +222,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setEntry(int row, int column, double value)
-            throws MatrixIndexException {
+    public void setEntry(int row, int column, double value) {
         MatrixUtils.checkRowIndex(this, row);
         MatrixUtils.checkColumnIndex(this, column);
         if (value == 0.0) {
@@ -250,8 +234,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void addToEntry(int row, int column, double increment)
-            throws MatrixIndexException {
+    public void addToEntry(int row, int column, double increment) {
         MatrixUtils.checkRowIndex(this, row);
         MatrixUtils.checkColumnIndex(this, column);
         final int key = computeKey(row, column);
@@ -265,8 +248,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void multiplyEntry(int row, int column, double factor)
-            throws MatrixIndexException {
+    public void multiplyEntry(int row, int column, double factor) {
         MatrixUtils.checkRowIndex(this, row);
         MatrixUtils.checkColumnIndex(this, column);
         final int key = computeKey(row, column);
diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
index f098bfb..e14d061 100644
--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
@@ -18,59 +18,58 @@
 
 import java.io.Serializable;
 
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.MathArithmeticException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.OpenIntToDoubleHashMap;
 import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;
 import org.apache.commons.math.util.FastMath;
 
 /**
- * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.
+ * This class implements the {@link RealVector} interface with a
+ * {@link OpenIntToDoubleHashMap} backing store.
  * @version $Revision$ $Date$
  * @since 2.0
 */
-public class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable {
-
+public class OpenMapRealVector extends AbstractRealVector
+    implements SparseRealVector, Serializable {
     /** Default Tolerance for having a value considered zero. */
     public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;
-
     /** Serializable version identifier. */
     private static final long serialVersionUID = 8772222695580707260L;
-
     /** Entries of the vector. */
     private final OpenIntToDoubleHashMap entries;
-
     /** Dimension of the vector. */
     private final int virtualSize;
-
     /** Tolerance for having a value considered zero. */
     private final double epsilon;
 
     /**
      * Build a 0-length vector.
-     * <p>Zero-length vectors may be used to initialized construction of vectors
+     * Zero-length vectors may be used to initialized construction of vectors
      * by data gathering. We start with zero-length and use either the {@link
      * #OpenMapRealVector(OpenMapRealVector, int)} constructor
-     * or one of the <code>append</code> method ({@link #append(double)}, {@link
+     * or one of the {@code append} method ({@link #append(double)}, {@link
      * #append(double[])}, {@link #append(RealVector)}) to gather data
-     * into this vector.</p>
+     * into this vector.
      */
     public OpenMapRealVector() {
         this(0, DEFAULT_ZERO_TOLERANCE);
     }
 
     /**
-     * Construct a (dimension)-length vector of zeros.
-     * @param dimension size of the vector
+     * Construct a vector of zeroes.
+     *
+     * @param dimension Size of the vector.
      */
     public OpenMapRealVector(int dimension) {
         this(dimension, DEFAULT_ZERO_TOLERANCE);
     }
 
     /**
-     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.
-     * @param dimension Size of the vector
-     * @param epsilon The tolerance for having a value considered zero
+     * Construct a vector of zeroes, specifying zero tolerance.
+     *
+     * @param dimension Size of the vector.
+     * @param epsilon Tolerance below which a value considered zero.
      */
     public OpenMapRealVector(int dimension, double epsilon) {
         virtualSize = dimension;
@@ -80,8 +79,9 @@
 
     /**
      * Build a resized vector, for use with append.
-     * @param v The original vector
-     * @param resize The amount to resize it
+     *
+     * @param v Original vector.
+     * @param resize Amount to add.
      */
     protected OpenMapRealVector(OpenMapRealVector v, int resize) {
         virtualSize = v.getDimension() + resize;
@@ -91,18 +91,21 @@
 
     /**
      * Build a vector with known the sparseness (for advanced use only).
-     * @param dimension The size of the vector
-     * @param expectedSize The expected number of non-zero entries
+     *
+     * @param dimension Size of the vector.
+     * @param expectedSize The expected number of non-zero entries.
      */
     public OpenMapRealVector(int dimension, int expectedSize) {
         this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);
     }
 
     /**
-     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).
-     * @param dimension The size of the vector
-     * @param expectedSize The expected number of non-zero entries
-     * @param epsilon The tolerance for having a value considered zero
+     * Build a vector with known the sparseness and zero tolerance
+     * setting (for advanced use only).
+     *
+     * @param dimension Size of the vector.
+     * @param expectedSize Expected number of non-zero entries.
+     * @param epsilon Tolerance below which a value is considered zero.
      */
     public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {
         virtualSize = dimension;
@@ -111,19 +114,21 @@
     }
 
     /**
-     * Create from a double array.
-     * Only non-zero entries will be stored
-     * @param values The set of values to create from
+     * Create from an array.
+     * Only non-zero entries will be stored.
+     *
+     * @param values Set of values to create from.
      */
     public OpenMapRealVector(double[] values) {
         this(values, DEFAULT_ZERO_TOLERANCE);
     }
 
     /**
-     * Create from a double array, specifying zero tolerance.
-     * Only non-zero entries will be stored
-     * @param values The set of values to create from
-     * @param epsilon The tolerance for having a value considered zero
+     * Create from an array, specifying zero tolerance.
+     * Only non-zero entries will be stored.
+     *
+     * @param values Set of values to create from.
+     * @param epsilon Tolerance below which a value is considered zero.
      */
     public OpenMapRealVector(double[] values, double epsilon) {
         virtualSize = values.length;
@@ -138,8 +143,9 @@
     }
 
     /**
-     * Create from a Double array.
-     * Only non-zero entries will be stored
+     * Create from an array.
+     * Only non-zero entries will be stored.
+     *
      * @param values The set of values to create from
      */
     public OpenMapRealVector(Double[] values) {
@@ -147,10 +153,11 @@
     }
 
     /**
-     * Create from a Double array.
-     * Only non-zero entries will be stored
-     * @param values The set of values to create from
-     * @param epsilon The tolerance for having a value considered zero
+     * Create from an array.
+     * Only non-zero entries will be stored.
+     *
+     * @param values Set of values to create from.
+     * @param epsilon Tolerance below which a value is considered zero.
      */
     public OpenMapRealVector(Double[] values, double epsilon) {
         virtualSize = values.length;
@@ -166,7 +173,8 @@
 
     /**
      * Copy constructor.
-     * @param v The instance to copy from
+     *
+     * @param v Instance to copy from.
      */
     public OpenMapRealVector(OpenMapRealVector v) {
         virtualSize = v.getDimension();
@@ -176,7 +184,8 @@
 
     /**
      * Generic copy constructor.
-     * @param v The instance to copy from
+     *
+     * @param v Instance to copy from.
      */
     public OpenMapRealVector(RealVector v) {
         virtualSize = v.getDimension();
@@ -192,7 +201,8 @@
 
     /**
      * Get the entries of this instance.
-     * @return entries of this instance
+     *
+     * @return the entries of this instance.
      */
     private OpenIntToDoubleHashMap getEntries() {
         return entries;
@@ -200,8 +210,10 @@
 
     /**
      * Determine if this value is within epsilon of zero.
-     * @param value The value to test
-     * @return <code>true</code> if this value is within epsilon to zero, <code>false</code> otherwise
+     *
+     * @param value Value to test
+     * @return {@code true} if this value is within epsilon to zero,
+     * {@code false} otherwise.
      * @since 2.1
      */
     protected boolean isDefaultValue(double value) {
@@ -210,7 +222,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public RealVector add(RealVector v) throws IllegalArgumentException {
+        public RealVector add(RealVector v) {
         checkVectorDimensions(v.getDimension());
         if (v instanceof OpenMapRealVector) {
             return add((OpenMapRealVector) v);
@@ -220,12 +232,15 @@
     }
 
     /**
-     * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.
-     * @param v Vector to add with
-     * @return The sum of <code>this</code> with <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     * Optimized method to add two OpenMapRealVectors.
+     * It copies the larger vector, then iterates over the smaller.
+     *
+     * @param v Vector to add.
+     * @return the sum of {@code this} and {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{
+    public OpenMapRealVector add(OpenMapRealVector v) {
         checkVectorDimensions(v.getDimension());
         boolean copyThis = entries.size() > v.entries.size();
         OpenMapRealVector res = copyThis ? this.copy() : v.copy();
@@ -246,7 +261,7 @@
     /**
      * Optimized method to append a OpenMapRealVector.
      * @param v vector to append
-     * @return The result of appending <code>v</code> to self
+     * @return The result of appending {@code v} to self
      */
     public OpenMapRealVector append(OpenMapRealVector v) {
         OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
@@ -293,12 +308,14 @@
 
     /**
      * Optimized method to compute the dot product with an OpenMapRealVector.
-     * Iterates over the smaller of the two.
-     * @param v The vector to compute the dot product with
-     * @return The dot product of <code>this</code> and <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     * It iterates over the smallest of the two.
+     *
+     * @param v Cector to compute the dot product with.
+     * @return the dot product of {@code this} and {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {
+    public double dotProduct(OpenMapRealVector v) {
         checkVectorDimensions(v.getDimension());
         boolean thisIsSmaller  = entries.size() < v.entries.size();
         Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();
@@ -313,7 +330,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double dotProduct(RealVector v) throws IllegalArgumentException {
+    public double dotProduct(RealVector v) {
         if(v instanceof OpenMapRealVector) {
             return dotProduct((OpenMapRealVector)v);
         } else {
@@ -322,7 +339,7 @@
     }
 
     /** {@inheritDoc} */
-    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {
+    public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
@@ -335,7 +352,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {
+    public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
@@ -347,7 +364,7 @@
     }
 
     /** {@inheritDoc} */
-    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {
+    public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
@@ -360,7 +377,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {
+    public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
@@ -372,7 +389,7 @@
     }
 
     /** {@inheritDoc} */
-    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {
+    public OpenMapRealVector getSubVector(int index, int n) {
         checkIndex(index);
         checkIndex(index + n - 1);
         OpenMapRealVector res = new OpenMapRealVector(n);
@@ -407,11 +424,13 @@
 
     /**
      * Optimized method to compute distance.
-     * @param v The vector to compute distance to
-     * @return The distance from <code>this</code> and <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     *
+     * @param v Vector to compute distance to.
+     * @return the distance from {@code this} and {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {
+    public double getDistance(OpenMapRealVector v) {
         Iterator iter = entries.iterator();
         double res = 0;
         while (iter.hasNext()) {
@@ -435,7 +454,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getDistance(RealVector v) throws IllegalArgumentException {
+    public double getDistance(RealVector v) {
         checkVectorDimensions(v.getDimension());
         if (v instanceof OpenMapRealVector) {
             return getDistance((OpenMapRealVector) v);
@@ -445,7 +464,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getDistance(double[] v) throws IllegalArgumentException {
+    public double getDistance(double[] v) {
         checkVectorDimensions(v.length);
         double res = 0;
         for (int i = 0; i < v.length; i++) {
@@ -456,18 +475,19 @@
     }
 
     /** {@inheritDoc} */
-    public double getEntry(int index) throws MatrixIndexException {
+    public double getEntry(int index) {
         checkIndex(index);
         return entries.get(index);
     }
 
     /**
      * Distance between two vectors.
-     * <p>This method computes the distance consistent with
+     * This method computes the distance consistent with
      * L<sub>1</sub> norm, i.e. the sum of the absolute values of
-     * elements differences.</p>
-     * @param v vector to which distance is requested
-     * @return distance between two vectors.
+     * elements differences.
+     *
+     * @param v Vector to which distance is requested.
+     * @return distance between this vector and {@code v}.
      */
     public double getL1Distance(OpenMapRealVector v) {
         double max = 0;
@@ -491,7 +511,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getL1Distance(RealVector v) throws IllegalArgumentException {
+    public double getL1Distance(RealVector v) {
         checkVectorDimensions(v.getDimension());
         if (v instanceof OpenMapRealVector) {
             return getL1Distance((OpenMapRealVector) v);
@@ -501,7 +521,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getL1Distance(double[] v) throws IllegalArgumentException {
+    public double getL1Distance(double[] v) {
         checkVectorDimensions(v.length);
         double max = 0;
         for (int i = 0; i < v.length; i++) {
@@ -513,8 +533,9 @@
 
     /**
      * Optimized method to compute LInfDistance.
-     * @param v The vector to compute from
-     * @return the LInfDistance
+     *
+     * @param v Vector to compute distance from.
+     * @return the LInfDistance.
      */
     private double getLInfDistance(OpenMapRealVector v) {
         double max = 0;
@@ -541,7 +562,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getLInfDistance(RealVector v) throws IllegalArgumentException {
+    public double getLInfDistance(RealVector v) {
         checkVectorDimensions(v.getDimension());
         if (v instanceof OpenMapRealVector) {
             return getLInfDistance((OpenMapRealVector) v);
@@ -551,7 +572,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public double getLInfDistance(double[] v) throws IllegalArgumentException {
+    public double getLInfDistance(double[] v) {
         checkVectorDimensions(v.length);
         double max = 0;
         for (int i = 0; i < v.length; i++) {
@@ -609,7 +630,7 @@
 
      /** {@inheritDoc} */
     @Override
-    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
+    public RealMatrix outerProduct(double[] v) {
         checkVectorDimensions(v.length);
         RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);
         Iterator iter = entries.iterator();
@@ -625,20 +646,20 @@
     }
 
     /** {@inheritDoc} */
-    public RealVector projection(RealVector v) throws IllegalArgumentException {
+    public RealVector projection(RealVector v) {
         checkVectorDimensions(v.getDimension());
         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
     }
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {
+    public OpenMapRealVector projection(double[] v) {
         checkVectorDimensions(v.length);
         return (OpenMapRealVector) projection(new OpenMapRealVector(v));
     }
 
     /** {@inheritDoc} */
-    public void setEntry(int index, double value) throws MatrixIndexException {
+    public void setEntry(int index, double value) {
         checkIndex(index);
         if (!isDefaultValue(value)) {
             entries.put(index, value);
@@ -649,7 +670,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setSubVector(int index, RealVector v) throws MatrixIndexException {
+    public void setSubVector(int index, RealVector v) {
         checkIndex(index);
         checkIndex(index + v.getDimension() - 1);
         setSubVector(index, v.getData());
@@ -657,7 +678,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setSubVector(int index, double[] v) throws MatrixIndexException {
+    public void setSubVector(int index, double[] v) {
         checkIndex(index);
         checkIndex(index + v.length - 1);
         for (int i = 0; i < v.length; i++) {
@@ -675,11 +696,13 @@
 
     /**
      * Optimized method to subtract OpenMapRealVectors.
-     * @param v The vector to subtract from <code>this</code>
-     * @return The difference of <code>this</code> and <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     *
+     * @param v Vector to subtract from {@code this}.
+     * @return the difference of {@code this} and {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{
+    public OpenMapRealVector subtract(OpenMapRealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = copy();
         Iterator iter = v.getEntries().iterator();
@@ -697,7 +720,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {
+    public OpenMapRealVector subtract(RealVector v) {
         checkVectorDimensions(v.getDimension());
         if (v instanceof OpenMapRealVector) {
             return subtract((OpenMapRealVector) v);
@@ -707,7 +730,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {
+    public OpenMapRealVector subtract(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         for (int i = 0; i < v.length; i++) {
@@ -734,27 +757,26 @@
     public void unitize() {
         double norm = getNorm();
         if (isDefaultValue(norm)) {
-            throw  MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
         }
         Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             entries.put(iter.key(), iter.value() / norm);
         }
-
     }
 
-
     /** {@inheritDoc} */
     @Override
     public double[] toArray() {
         return getData();
     }
 
-    /** {@inheritDoc}
-     * <p> Implementation Note: This works on exact values, and as a result
+    /**
+     * {@inheritDoc}
+     * Implementation Note: This works on exact values, and as a result
      * it is possible for {@code a.subtract(b)} to be the zero vector, while
-     * {@code a.hashCode() != b.hashCode()}.</p>
+     * {@code a.hashCode() != b.hashCode()}.
      */
     @Override
     public int hashCode() {
@@ -774,10 +796,10 @@
     }
 
     /**
-     * <p> Implementation Note: This performs an exact comparison, and as a result
-     * it is possible for {@code a.subtract(b}} to be the zero vector, while
-     * {@code  a.equals(b) == false}.</p>
      * {@inheritDoc}
+     * Implementation Note: This performs an exact comparison, and as a result
+     * it is possible for {@code a.subtract(b}} to be the zero vector, while
+     * {@code  a.equals(b) == false}.
      */
     @Override
     public boolean equals(Object obj) {
@@ -817,18 +839,8 @@
     /**
      *
      * @return the percentage of none zero elements as a decimal percent.
-     * @deprecated Use the correctly spelled {@link #getSparsity()}
      */
-    @Deprecated
-    public double getSparcity() {
-        return getSparsity();
-    }
-
-    /**
-    *
-    * @return the percentage of none zero elements as a decimal percent.
-    */
-   public double getSparsity() {
+    public double getSparsity() {
         return (double)entries.size()/(double)getDimension();
     }
 
@@ -839,17 +851,18 @@
     }
 
     /**
-     *  Implementation of <code>Entry</code> optimized for OpenMap.
-     * <p>This implementation does not allow arbitrary calls to <code>setIndex</code>
-     * since the order that entries are returned is undefined.
+     * Implementation of {@code Entry} optimized for OpenMap.
+     * This implementation does not allow arbitrary calls to {@code setIndex}
+     * since the order in which entries are returned is undefined.
      */
     protected class OpenMapEntry extends Entry {
-
         /** Iterator pointing to the entry. */
         private final Iterator iter;
 
-        /** Build an entry from an iterator point to an element.
-         * @param iter iterator pointing to the entry
+        /**
+         * Build an entry from an iterator point to an element.
+         *
+         * @param iter Iterator pointing to the entry.
          */
         protected OpenMapEntry(Iterator iter) {
             this.iter = iter;
@@ -876,15 +889,13 @@
     }
 
     /**
-     *  Iterator class to do iteration over just the non-zero elements.
-     *  <p>This implementation is fail-fast, so cannot be used to modify any zero element.
-     *
+     * Iterator class to do iteration over just the non-zero elements.
+     * This implementation is fail-fast, so cannot be used to modify
+     * any zero element.
      */
     protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {
-
         /** Underlying iterator. */
         private final Iterator iter;
-
         /** Current entry. */
         private final Entry current;
 
@@ -908,7 +919,6 @@
         /** {@inheritDoc} */
         public void remove() {
             throw new UnsupportedOperationException("Not supported");
-       }
-
+        }
     }
 }
diff --git a/src/main/java/org/apache/commons/math/linear/RealMatrix.java b/src/main/java/org/apache/commons/math/linear/RealMatrix.java
index 31a3148..1e048f1 100644
--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java
@@ -134,7 +134,8 @@
      * @param endColumn Final column index (inclusive)
      * @return The subMatrix containing the data of the
      *         specified rows and columns
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      */
     RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);
 
@@ -146,7 +147,8 @@
     * @param selectedColumns Array of column indices.
     * @return The subMatrix containing the data in the
     *         specified rows and columns
-    * @exception MatrixIndexException if row or column selections are not valid
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the indices are not valid.
     */
     RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns);
 
@@ -160,22 +162,24 @@
     * @param endColumn Final column index (inclusive)
     * @param destination The arrays where the submatrix data should be copied
     * (if larger than rows/columns counts, only the upper-left part will be used)
-    * @exception MatrixIndexException if the indices are not valid
+    * @throws org.apache.commons.math.exception.OutOfRangeException if the
+    * indices are not valid.
     * @exception IllegalArgumentException if the destination array is too small
     */
-  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,
-                     double[][] destination);
-  /**
-   * Copy a submatrix. Rows and columns are indicated
-   * counting from 0 to n-1.
-   *
-    * @param selectedRows Array of row indices.
-    * @param selectedColumns Array of column indices.
-   * @param destination The arrays where the submatrix data should be copied
-   * (if larger than rows/columns counts, only the upper-left part will be used)
-   * @exception MatrixIndexException if the indices are not valid
-   * @exception IllegalArgumentException if the destination array is too small
-   */
+    void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,
+                       double[][] destination);
+    /**
+     * Copy a submatrix. Rows and columns are indicated
+     * counting from 0 to n-1.
+     *
+     * @param selectedRows Array of row indices.
+     * @param selectedColumns Array of column indices.
+     * @param destination The arrays where the submatrix data should be copied
+     * (if larger than rows/columns counts, only the upper-left part will be used)
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * indices are not valid.
+     * @exception IllegalArgumentException if the destination array is too small
+     */
     void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination);
 
    /**
@@ -198,58 +202,67 @@
     * @param subMatrix  array containing the submatrix replacement data
     * @param row  row coordinate of the top, left element to be replaced
     * @param column  column coordinate of the top, left element to be replaced
-    * @throws MatrixIndexException  if subMatrix does not fit into this
-    *    matrix from element in (row, column)
-    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
-    *  (not all rows have the same length) or empty
-    * @throws NullPointerException if <code>subMatrix</code> is null
+    * @throws org.apache.commons.math.exception.ZeroException if
+    * {@code subMatrix} does not contain at least one column.
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * {@code subMatrix} does not fit into this matrix from element in
+    * {@code (row, column)}.
+    * @throws org.apache.commons.math.exception.DimensionMismatchException
+    * if {@code subMatrix} is not rectangular.
+    * (not all rows have the same length) or empty.
+    * @throws org.apache.commons.math.exception.NullArgumentException if
+    * {@code subMatrix} is {@code null}.
     * @since 2.0
     */
     void setSubMatrix(double[][] subMatrix, int row, int column);
 
    /**
-    * Returns the entries in row number <code>row</code>
+    * Geet the entries at the given row index
     * as a row matrix.  Row indices start at 0.
     *
-    * @param row the row to be fetched
-    * @return row matrix
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be fetched.
+    * @return row Matrix.
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified row index is invalid.
     */
    RealMatrix getRowMatrix(int row);
 
    /**
-    * Sets the entries in row number <code>row</code>
+    * Set the entries at the given row index
     * as a row matrix.  Row indices start at 0.
     *
-    * @param row the row to be set
-    * @param matrix row matrix (must have one row and the same number of columns
-    * as the instance)
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be set.
+    * @param matrix Row matrix (must have one row and the same number of
+    * columns as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException if the
+    * specified row index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the matrix dimensions do not match one instance row.
     */
     void setRowMatrix(int row, RealMatrix matrix);
 
    /**
-    * Returns the entries in column number <code>column</code>
+    * Get the entries at the given column index
     * as a column matrix.  Column indices start at 0.
     *
-    * @param column the column to be fetched
-    * @return column matrix
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be fetched.
+    * @return column Matrix.
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified column index is invalid.
     */
    RealMatrix getColumnMatrix(int column);
 
    /**
-    * Sets the entries in column number <code>column</code>
+    * Set the entries at the given column index
     * as a column matrix.  Column indices start at 0.
     *
-    * @param column the column to be set
-    * @param matrix column matrix (must have one column and the same number of rows
-    * as the instance)
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be set.
+    * @param matrix Column matrix (must have one column and the same number
+    * of rows as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified column index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
-    * if the matrix dimensions do not match one instance column.
+    * if the {@code matrix} dimensions do not match one instance column.
     */
     void setColumnMatrix(int column, RealMatrix matrix);
 
@@ -257,162 +270,149 @@
     * Returns the entries in row number <code>row</code>
     * as a vector.  Row indices start at 0.
     *
-    * @param row the row to be fetched
-    * @return row vector
-    * @throws MatrixIndexException if the specified row index is invalid
+    * @param row Row to be fetched.
+    * @return a row vector.
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified row index is invalid.
     */
    RealVector getRowVector(int row);
 
    /**
-    * Sets the entries in row number <code>row</code>
+    * Set the entries at the given row index.
     * as a vector.  Row indices start at 0.
     *
-    * @param row the row to be set
+    * @param row Row to be set.
     * @param vector row vector (must have the same number of columns
-    * as the instance)
-    * @throws MatrixIndexException if the specified row index is invalid
+    * as the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified row index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the vector dimension does not match one instance row.
     */
     void setRowVector(int row, RealVector vector);
 
    /**
-    * Returns the entries in column number <code>column</code>
+    * Get the entries at the given column index
     * as a vector.  Column indices start at 0.
     *
-    * @param column the column to be fetched
-    * @return column vector
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be fetched.
+    * @return a column vector.
+    * @throws org.apache.commons.math.exception.OutOfRangeException if
+    * the specified column index is invalid
     */
    RealVector getColumnVector(int column);
 
    /**
-    * Sets the entries in column number <code>column</code>
+    * Set the entries at the given column index
     * as a vector.  Column indices start at 0.
     *
-    * @param column the column to be set
-    * @param vector column vector (must have the same number of rows as the instance)
-    * @throws MatrixIndexException if the specified column index is invalid
+    * @param column Column to be set.
+    * @param vector column vector (must have the same number of rows as
+    * the instance).
+    * @throws org.apache.commons.math.exception.OutOfRangeException if the
+    * specified column index is invalid.
     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
     * if the vector dimension does not match one instance column.
     */
     void setColumnVector(int column, RealVector vector);
 
     /**
-     * Returns the entries in row number <code>row</code> as an array.
-     * <p>
-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless {@code 0 <= row < rowDimension}.</p>
+     * Get the entries at the given row index.
+     * Row indices start at 0.
      *
-     * @param row the row to be fetched
-     * @return array of entries in the row
-     * @throws MatrixIndexException if the specified row index is not valid
+     * @param row Row to be fetched.
+     * @return the array of entries in the row.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * specified row index is not valid.
      */
     double[] getRow(int row);
 
     /**
-     * Sets the entries in row number <code>row</code>
+     * Set the entries at the given row index
      * as a row matrix.  Row indices start at 0.
      *
-     * @param row the row to be set
-     * @param array row matrix (must have the same number of columns as the instance)
-     * @throws MatrixIndexException if the specified row index is invalid
+     * @param row Row to be set.
+     * @param array Row matrix (must have the same number of columns as
+     * the instance)
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * specified row index is invalid.
      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
      * if the array size does not match one instance row.
      */
     void setRow(int row, double[] array);
 
     /**
-     * Returns the entries in column number <code>col</code> as an array.
-     * <p>
-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
-     * unless {@code 0 <= column < columnDimension}.</p>
+     * Get the entries at the given column index as an array.
+     * Column indices start at 0.
      *
-     * @param column the column to be fetched
-     * @return array of entries in the column
-     * @throws MatrixIndexException if the specified column index is not valid
+     * @param column Column to be fetched.
+     * @return the array of entries in the column.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * specified column index is not valid.
      */
     double[] getColumn(int column);
 
     /**
-     * Sets the entries in column number <code>column</code>
-     * as a column matrix.  Column indices start at 0.
+     * Set the entries at the given column index
+     * as a column matrix array.  Column indices start at 0.
      *
-     * @param column the column to be set
-     * @param array column array (must have the same number of rows as the instance)
-     * @throws MatrixIndexException if the specified column index is invalid
+     * @param column Column to be set.
+     * @param array Column array (must have the same number of rows as
+     * the instance).
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * specified column index is invalid.
      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException
      * if the array size does not match one instance column.
      */
     void setColumn(int column, double[] array);
 
     /**
-     * Returns the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
+     * Get the entry in the specified row and column.
+     * Row and column indices start at 0.
      *
-     * @param row  row location of entry to be fetched
-     * @param column  column location of entry to be fetched
-     * @return matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be fetched.
+     * @param column Column location of entry to be fetched.
+     * @return the matrix entry at {@code (row, column)}.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * row or column index is not valid.
      */
     double getEntry(int row, int column);
 
     /**
      * Set the entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
+     * Row and column indices start at 0.
      *
-     * @param row  row location of entry to be set
-     * @param column  column location of entry to be set
-     * @param value matrix entry to be set in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be set.
+     * @param column Column location of entry to be set.
+     * @param value matrix entry to be set.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the row or column index is not valid
      * @since 2.0
      */
     void setEntry(int row, int column, double value);
 
     /**
      * Change an entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
+     * Row and column indices start at 0.
      *
-     * @param row  row location of entry to be set
-     * @param column  column location of entry to be set
-     * @param increment value to add to the current matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be set.
+     * @param column Column location of entry to be set.
+     * @param increment value to add to the matrix entry.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the row or column index is not valid.
      * @since 2.0
      */
     void addToEntry(int row, int column, double increment);
 
     /**
      * Change an entry in the specified row and column.
-     * <p>
-     * Row and column indices start at 0 and must satisfy
-     * <ul>
-     * <li>{@code 0 <= row < rowDimension}</li>
-     * <li>{@code 0 <= column < columnDimension}</li>
-     * </ul>
-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>
+     * Row and column indices start at 0.
      *
-     * @param row  row location of entry to be set
-     * @param column  column location of entry to be set
-     * @param factor multiplication factor for the current matrix entry in row,column
-     * @throws MatrixIndexException if the row or column index is not valid
+     * @param row Row location of entry to be set.
+     * @param column Column location of entry to be set.
+     * @param factor Multiplication factor for the matrix entry.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the row or column index is not valid.
      * @since 2.0
      */
     void multiplyEntry(int row, int column, double factor);
@@ -513,7 +513,7 @@
      * of a row from left to right before going to the leftmost element
      * of the next row.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)
@@ -536,7 +536,7 @@
      * of a row from left to right before going to the leftmost element
      * of the next row.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)
@@ -563,8 +563,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)
@@ -592,8 +593,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -617,7 +619,7 @@
      * of a column from top to bottom before going to the topmost element
      * of the next column.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -640,7 +642,7 @@
      * of a column from top to bottom before going to the topmost element
      * of the next column.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -667,8 +669,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -696,8 +699,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -720,7 +724,7 @@
      * <p>The fastest walking order depends on the exact matrix class. It may be
      * different from traditional row or column orders.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -742,7 +746,7 @@
      * <p>The fastest walking order depends on the exact matrix class. It may be
      * different from traditional row or column orders.</p>
      * @param visitor visitor used to process all matrix entries
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
+     * @throws MatrixVisitorException if the visitor cannot process an entry
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -768,8 +772,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index (inclusive)
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * the indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
@@ -796,8 +801,9 @@
      * @param endRow Final row index (inclusive)
      * @param startColumn Initial column index
      * @param endColumn Final column index (inclusive)
-     * @exception  MatrixVisitorException if the visitor cannot process an entry
-     * @exception MatrixIndexException  if the indices are not valid
+     * @throws MatrixVisitorException if the visitor cannot process an entry
+     * @throws org.apache.commons.math.exception.OutOfRangeException if the
+     * indices are not valid.
      * @see #walkInRowOrder(RealMatrixChangingVisitor)
      * @see #walkInRowOrder(RealMatrixPreservingVisitor)
      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)
diff --git a/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java b/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java
deleted file mode 100644
index b6e7108..0000000
--- a/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java
+++ /dev/null
@@ -1,628 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.linear;
-
-import java.io.Serializable;
-
-import org.apache.commons.math.MathRuntimeException;
-import org.apache.commons.math.exception.util.LocalizedFormats;
-
-/**
- * Implementation of RealMatrix using a double[][] array to store entries and
- * <a href="http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf">
- * LU decomposition</a> to support linear system
- * solution and inverse.
- * <p>
- * The LU decomposition is performed as needed, to support the following operations: <ul>
- * <li>solve</li>
- * <li>isSingular</li>
- * <li>getDeterminant</li>
- * <li>inverse</li> </ul></p>
- * <p>
- * <strong>Usage notes</strong>:<br>
- * <ul><li>
- * The LU decomposition is cached and reused on subsequent calls.
- * If data are modified via references to the underlying array obtained using
- * <code>getDataRef()</code>, then the stored LU decomposition will not be
- * discarded.  In this case, you need to explicitly invoke
- * <code>LUDecompose()</code> to recompute the decomposition
- * before using any of the methods above.</li>
- * <li>
- * As specified in the {@link RealMatrix} interface, matrix element indexing
- * is 0-based -- e.g., <code>getEntry(0, 0)</code>
- * returns the element in the first row, first column of the matrix.</li></ul>
- * </p>
- *
- * @version $Revision$ $Date$
- * @deprecated as of 2.0 replaced by {@link Array2DRowRealMatrix}
- */
-@Deprecated
-public class RealMatrixImpl extends AbstractRealMatrix implements Serializable {
-
-    /** Serializable version identifier */
-    private static final long serialVersionUID = -1067294169172445528L;
-
-    /** Entries of the matrix */
-    protected double data[][];
-
-    /**
-     * Creates a matrix with no data
-     */
-    public RealMatrixImpl() {
-    }
-
-    /**
-     * Create a new RealMatrix with the supplied row and column dimensions.
-     *
-     * @param rowDimension  the number of rows in the new matrix
-     * @param columnDimension  the number of columns in the new matrix
-     * @throws IllegalArgumentException if row or column dimension is not
-     *  positive
-     */
-    public RealMatrixImpl(final int rowDimension, final int columnDimension)
-        throws IllegalArgumentException {
-        super(rowDimension, columnDimension);
-        data = new double[rowDimension][columnDimension];
-    }
-
-    /**
-     * Create a new RealMatrix using the input array as the underlying
-     * data array.
-     * <p>The input array is copied, not referenced. This constructor has
-     * the same effect as calling {@link #RealMatrixImpl(double[][], boolean)}
-     * with the second argument set to <code>true</code>.</p>
-     *
-     * @param d data for new matrix
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     * @see #RealMatrixImpl(double[][], boolean)
-     */
-    public RealMatrixImpl(final double[][] d)
-        throws IllegalArgumentException, NullPointerException {
-        copyIn(d);
-    }
-
-    /**
-     * Create a new RealMatrix using the input array as the underlying
-     * data array.
-     * <p>If an array is built specially in order to be embedded in a
-     * RealMatrix and not used directly, the <code>copyArray</code> may be
-     * set to <code>false</code. This will prevent the copying and improve
-     * performance as no new array will be built and no data will be copied.</p>
-     * @param d data for new matrix
-     * @param copyArray if true, the input array will be copied, otherwise
-     * it will be referenced
-     * @throws IllegalArgumentException if <code>d</code> is not rectangular
-     *  (not all rows have the same length) or empty
-     * @throws NullPointerException if <code>d</code> is null
-     * @see #RealMatrixImpl(double[][])
-     */
-    public RealMatrixImpl(final double[][] d, final boolean copyArray)
-        throws IllegalArgumentException, NullPointerException {
-        if (copyArray) {
-            copyIn(d);
-        } else {
-            if (d == null) {
-                throw new NullPointerException();
-            }
-            final int nRows = d.length;
-            if (nRows == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-            }
-            final int nCols = d[0].length;
-            if (nCols == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-            }
-            for (int r = 1; r < nRows; r++) {
-                if (d[r].length != nCols) {
-                    throw MathRuntimeException.createIllegalArgumentException(
-                            LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                            nCols, d[r].length);
-                }
-            }
-            data = d;
-        }
-    }
-
-    /**
-     * Create a new (column) RealMatrix using <code>v</code> as the
-     * data for the unique column of the <code>v.length x 1</code> matrix
-     * created.
-     * <p>The input array is copied, not referenced.</p>
-     *
-     * @param v column vector holding data for new matrix
-     */
-    public RealMatrixImpl(final double[] v) {
-        final int nRows = v.length;
-        data = new double[nRows][1];
-        for (int row = 0; row < nRows; row++) {
-            data[row][0] = v[row];
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)
-        throws IllegalArgumentException {
-        return new RealMatrixImpl(rowDimension, columnDimension);
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix copy() {
-        return new RealMatrixImpl(copyOut(), false);
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix add(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return add((RealMatrixImpl) m);
-        } catch (ClassCastException cce) {
-            return super.add(m);
-        }
-    }
-
-    /**
-     * Compute the sum of this and <code>m</code>.
-     *
-     * @param m    matrix to be added
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public RealMatrixImpl add(final RealMatrixImpl m)
-        throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkAdditionCompatible(this, m);
-
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final double[][] outData = new double[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final double[] dataRow    = data[row];
-            final double[] mRow       = m.data[row];
-            final double[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col] + mRow[col];
-            }
-        }
-
-        return new RealMatrixImpl(outData, false);
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix subtract(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return subtract((RealMatrixImpl) m);
-        } catch (ClassCastException cce) {
-            return super.subtract(m);
-        }
-    }
-
-    /**
-     * Compute  this minus <code>m</code>.
-     *
-     * @param m    matrix to be subtracted
-     * @return     this + m
-     * @throws  IllegalArgumentException if m is not the same size as this
-     */
-    public RealMatrixImpl subtract(final RealMatrixImpl m)
-        throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkSubtractionCompatible(this, m);
-
-        final int rowCount    = getRowDimension();
-        final int columnCount = getColumnDimension();
-        final double[][] outData = new double[rowCount][columnCount];
-        for (int row = 0; row < rowCount; row++) {
-            final double[] dataRow    = data[row];
-            final double[] mRow       = m.data[row];
-            final double[] outDataRow = outData[row];
-            for (int col = 0; col < columnCount; col++) {
-                outDataRow[col] = dataRow[col] - mRow[col];
-            }
-        }
-
-        return new RealMatrixImpl(outData, false);
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public RealMatrix multiply(final RealMatrix m)
-        throws IllegalArgumentException {
-        try {
-            return multiply((RealMatrixImpl) m);
-        } catch (ClassCastException cce) {
-            return super.multiply(m);
-        }
-    }
-
-    /**
-     * Returns the result of postmultiplying this by <code>m</code>.
-     * @param m    matrix to postmultiply by
-     * @return     this*m
-     * @throws     IllegalArgumentException
-     *             if columnDimension(this) != rowDimension(m)
-     */
-    public RealMatrixImpl multiply(final RealMatrixImpl m)
-        throws IllegalArgumentException {
-
-        // safety check
-        MatrixUtils.checkMultiplicationCompatible(this, m);
-
-        final int nRows = this.getRowDimension();
-        final int nCols = m.getColumnDimension();
-        final int nSum = this.getColumnDimension();
-        final double[][] outData = new double[nRows][nCols];
-        for (int row = 0; row < nRows; row++) {
-            final double[] dataRow    = data[row];
-            final double[] outDataRow = outData[row];
-            for (int col = 0; col < nCols; col++) {
-                double sum = 0;
-                for (int i = 0; i < nSum; i++) {
-                    sum += dataRow[i] * m.data[i][col];
-                }
-                outDataRow[col] = sum;
-            }
-        }
-
-        return new RealMatrixImpl(outData, false);
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double[][] getData() {
-        return copyOut();
-    }
-
-    /**
-     * Returns a reference to the underlying data array.
-     * <p>
-     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>
-     *
-     * @return 2-dimensional array of entries
-     */
-    public double[][] getDataRef() {
-        return data;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)
-    throws MatrixIndexException {
-        if (data == null) {
-            if (row > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                        LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET,
-                        row);
-            }
-            if (column > 0) {
-                throw MathRuntimeException.createIllegalStateException(
-                        LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET,
-                        column);
-            }
-            final int nRows = subMatrix.length;
-            if (nRows == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);
-            }
-
-            final int nCols = subMatrix[0].length;
-            if (nCols == 0) {
-                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
-            }
-            data = new double[subMatrix.length][nCols];
-            for (int i = 0; i < data.length; ++i) {
-                if (subMatrix[i].length != nCols) {
-                    throw MathRuntimeException.createIllegalArgumentException(
-                            LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
-                            nCols, subMatrix[i].length);
-                }
-                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);
-            }
-        } else {
-            super.setSubMatrix(subMatrix, row, column);
-        }
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double getEntry(final int row, final int column)
-        throws MatrixIndexException {
-        try {
-            return data[row][column];
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void setEntry(final int row, final int column, final double value)
-        throws MatrixIndexException {
-        try {
-            data[row][column] = value;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void addToEntry(final int row, final int column, final double increment)
-        throws MatrixIndexException {
-        try {
-            data[row][column] += increment;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void multiplyEntry(final int row, final int column, final double factor)
-        throws MatrixIndexException {
-        try {
-            data[row][column] *= factor;
-        } catch (ArrayIndexOutOfBoundsException e) {
-            throw new MatrixIndexException(
-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,
-                    row, column, getRowDimension(), getColumnDimension());
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public int getRowDimension() {
-        return (data == null) ? 0 : data.length;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public int getColumnDimension() {
-        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double[] operate(final double[] v)
-        throws IllegalArgumentException {
-        final int nRows = this.getRowDimension();
-        final int nCols = this.getColumnDimension();
-        if (v.length != nCols) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    v.length, nCols);
-        }
-        final double[] out = new double[nRows];
-        for (int row = 0; row < nRows; row++) {
-            final double[] dataRow = data[row];
-            double sum = 0;
-            for (int i = 0; i < nCols; i++) {
-                sum += dataRow[i] * v[i];
-            }
-            out[row] = sum;
-        }
-        return out;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double[] preMultiply(final double[] v)
-        throws IllegalArgumentException {
-
-        final int nRows = getRowDimension();
-        final int nCols = getColumnDimension();
-        if (v.length != nRows) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    v.length, nRows);
-        }
-
-        final double[] out = new double[nCols];
-        for (int col = 0; col < nCols; ++col) {
-            double sum = 0;
-            for (int i = 0; i < nRows; ++i) {
-                sum += data[i][col] * v[i];
-            }
-            out[col] = sum;
-        }
-
-        return out;
-
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)
-        throws MatrixVisitorException {
-        final int rows    = getRowDimension();
-        final int columns = getColumnDimension();
-        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
-        for (int i = 0; i < rows; ++i) {
-            final double[] rowI = data[i];
-            for (int j = 0; j < columns; ++j) {
-                rowI[j] = visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)
-        throws MatrixVisitorException {
-        final int rows    = getRowDimension();
-        final int columns = getColumnDimension();
-        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
-        for (int i = 0; i < rows; ++i) {
-            final double[] rowI = data[i];
-            for (int j = 0; j < columns; ++j) {
-                visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
-                                 final int startRow, final int endRow,
-                                 final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
-        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
-        visitor.start(getRowDimension(), getColumnDimension(),
-                      startRow, endRow, startColumn, endColumn);
-        for (int i = startRow; i <= endRow; ++i) {
-            final double[] rowI = data[i];
-            for (int j = startColumn; j <= endColumn; ++j) {
-                rowI[j] = visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
-                                 final int startRow, final int endRow,
-                                 final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
-        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
-        visitor.start(getRowDimension(), getColumnDimension(),
-                      startRow, endRow, startColumn, endColumn);
-        for (int i = startRow; i <= endRow; ++i) {
-            final double[] rowI = data[i];
-            for (int j = startColumn; j <= endColumn; ++j) {
-                visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)
-        throws MatrixVisitorException {
-        final int rows    = getRowDimension();
-        final int columns = getColumnDimension();
-        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
-        for (int j = 0; j < columns; ++j) {
-            for (int i = 0; i < rows; ++i) {
-                final double[] rowI = data[i];
-                rowI[j] = visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)
-        throws MatrixVisitorException {
-        final int rows    = getRowDimension();
-        final int columns = getColumnDimension();
-        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
-        for (int j = 0; j < columns; ++j) {
-            for (int i = 0; i < rows; ++i) {
-                visitor.visit(i, j, data[i][j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,
-                                    final int startRow, final int endRow,
-                                    final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
-        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
-        visitor.start(getRowDimension(), getColumnDimension(),
-                      startRow, endRow, startColumn, endColumn);
-        for (int j = startColumn; j <= endColumn; ++j) {
-            for (int i = startRow; i <= endRow; ++i) {
-                final double[] rowI = data[i];
-                rowI[j] = visitor.visit(i, j, rowI[j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,
-                                    final int startRow, final int endRow,
-                                    final int startColumn, final int endColumn)
-        throws MatrixIndexException, MatrixVisitorException {
-        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
-        visitor.start(getRowDimension(), getColumnDimension(),
-                      startRow, endRow, startColumn, endColumn);
-        for (int j = startColumn; j <= endColumn; ++j) {
-            for (int i = startRow; i <= endRow; ++i) {
-                visitor.visit(i, j, data[i][j]);
-            }
-        }
-        return visitor.end();
-    }
-
-    /**
-     * Returns a fresh copy of the underlying data array.
-     *
-     * @return a copy of the underlying data array.
-     */
-    private double[][] copyOut() {
-        final int nRows = this.getRowDimension();
-        final double[][] out = new double[nRows][this.getColumnDimension()];
-        // can't copy 2-d array in one shot, otherwise get row references
-        for (int i = 0; i < nRows; i++) {
-            System.arraycopy(data[i], 0, out[i], 0, data[i].length);
-        }
-        return out;
-    }
-
-    /**
-     * Replaces data with a fresh copy of the input array.
-     * <p>
-     * Verifies that the input array is rectangular and non-empty.</p>
-     *
-     * @param in data to copy in
-     * @throws IllegalArgumentException if input array is empty or not
-     *    rectangular
-     * @throws NullPointerException if input array is null
-     */
-    private void copyIn(final double[][] in) {
-        setSubMatrix(in, 0, 0);
-    }
-
-}
diff --git a/src/main/java/org/apache/commons/math/linear/RealVector.java b/src/main/java/org/apache/commons/math/linear/RealVector.java
index d2d47d8..3abdcdd 100644
--- a/src/main/java/org/apache/commons/math/linear/RealVector.java
+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java
@@ -46,202 +46,234 @@
  * @since 2.0
  */
 public interface RealVector {
-
     /**
      * Acts as if it is implemented as:
-     * Entry e = null;
-     * for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {
-     *   e.setValue(function.value(e.getValue()));
-     * }
-     * @param function to apply to each successive entry
-     * @return this vector
-     * @throws FunctionEvaluationException if function throws it on application to any entry
+     * <pre>
+     *  Entry e = null;
+     *  for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {
+     *      e.setValue(function.value(e.getValue()));
+     *  }
+     * </pre>
+     *
+     * @param function Function to apply to each entry.
+     * @return this vector.
+     * @throws FunctionEvaluationException if the function throws it.
      */
     RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException;
 
     /**
      * Acts as if implemented as:
-     * return copy().map(function);
-     * @param function to apply to each successive entry
-     * @return a new vector
-     * @throws FunctionEvaluationException if function throws it on application to any entry
+     * <pre>
+     *  return copy().map(function);
+     * </pre>
+     *
+     * @param function Functin to apply to each entry.
+     * @return a new vector.
+     * @throws FunctionEvaluationException if the function throws it.
      */
     RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException;
 
     /** Class representing a modifiable entry in the vector. */
     public abstract class Entry {
-
         /** Index of the entry. */
         private int index;
 
-        /** Get the value of the entry.
-         * @return value of the entry
+        /**
+         * Get the value of the entry.
+         *
+         * @return the value of the entry.
          */
         public abstract double getValue();
-
-        /** Set the value of the entry.
-         * @param value new value for the entry
+        /**
+         * Set the value of the entry.
+         *
+         * @param value New value for the entry.
          */
         public abstract void setValue(double value);
-
-        /** Get the index of the entry.
-         * @return index of the entry
+        /**
+         * Get the index of the entry.
+         *
+         * @return the index of the entry.
          */
         public int getIndex() {
             return index;
         }
-
-        /** Set the index of the entry.
-         * @param index new index for the entry
+        /**
+         * Set the index of the entry.
+         *
+         * @param index New index for the entry.
          */
         public void setIndex(int index) {
             this.index = index;
         }
-
     }
 
     /**
-     * Generic dense iterator - starts with index == zero, and hasNext() == true until index == getDimension();
+     * Generic dense iterator.
+     * It iterates in increasing order of the vector index.
+     *
      * @return a dense iterator
      */
     Iterator<Entry> iterator();
 
     /**
-     * Specialized implementations may choose to not iterate over all dimensions, either because those values are
-     * unset, or are equal to defaultValue(), or are small enough to be ignored for the purposes of iteration.
+     * Specialized implementations may choose to not iterate over all
+     * dimensions, either because those values are unset, or are equal
+     * to defaultValue(), or are small enough to be ignored for the
+     * purposes of iteration.
      * No guarantees are made about order of iteration.
-     * In dense implementations, this method will often delegate to {@link #iterator()}
+     * In dense implementations, this method will often delegate to
+     * {@link #iterator()}.
+     *
      * @return a sparse iterator
      */
     Iterator<Entry> sparseIterator();
 
     /**
-     * Returns a (deep) copy of this.
-     * @return vector copy
+     * Returns a (deep) copy of this vector.
+     *
+     * @return a vector copy.
      */
     RealVector copy();
 
     /**
-     * Compute the sum of this and v.
-     * @param v vector to be added
-     * @return this + v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * Compute the sum of this vector and {@code v}.
+     *
+     * @param v Vector to be added.
+     * @return {@code this} + {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector add(RealVector v)
-        throws IllegalArgumentException;
+    RealVector add(RealVector v);
 
     /**
-     * Compute the sum of this and v.
-     * @param v vector to be added
-     * @return this + v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * Compute the sum of this vector and {@code v}.
+     *
+     * @param v Vector to be added.
+     * @return {@code this} + {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector add(double[] v)
-        throws IllegalArgumentException;
+    RealVector add(double[] v);
+
 
     /**
-     * Compute this minus v.
-     * @param v vector to be subtracted
-     * @return this + v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * Subtract {@code v} from this vector.
+     *
+     * @param v Vector to be subtracted.
+     * @return {@code this} - {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector subtract(RealVector v)
-        throws IllegalArgumentException;
+    RealVector subtract(RealVector v);
 
     /**
-     * Compute this minus v.
-     * @param v vector to be subtracted
-     * @return this - v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * Subtract {@code v} from this vector.
+     *
+     * @param v Vector to be subtracted.
+     * @return {@code this} - {@code v}.
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector subtract(double[] v)
-        throws IllegalArgumentException;
+    RealVector subtract(double[] v);
 
     /**
-     * Map an addition operation to each entry.
-     * @param d value to be added to each entry
-     * @return this + d
+     * Add a value to each entry.
+     *
+     * @param d Value to be added to each entry.
+     * @return {@code this} + {@code d}.
      */
     RealVector mapAdd(double d);
 
     /**
-     * Map an addition operation to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @param d value to be added to each entry
-     * @return for convenience, return this
+     * Add a value to each entry.
+     * The instance is changed in-place.
+     *
+     * @param d Value to be added to each entry.
+     * @return {@code this}.
      */
     RealVector mapAddToSelf(double d);
 
     /**
-     * Map a subtraction operation to each entry.
-     * @param d value to be subtracted to each entry
-     * @return this - d
+     * Subtract a value from each entry.
+     *
+     * @param d Value to be subtracted.
+     * @return {@code this} - {@code d}.
      */
     RealVector mapSubtract(double d);
 
     /**
-     * Map a subtraction operation to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @param d value to be subtracted to each entry
-     * @return for convenience, return this
+     * Subtract a value from each entry.
+     * The instance is changed in-place.
+     *
+     * @param d Value to be subtracted.
+     * @return {@code this}.
      */
     RealVector mapSubtractToSelf(double d);
 
     /**
-     * Map a multiplication operation to each entry.
-     * @param d value to multiply all entries by
-     * @return this * d
+     * Multiply each entry.
+     *
+     * @param d Multiplication factor.
+     * @return {@code this} * {@code d}.
      */
     RealVector mapMultiply(double d);
 
     /**
-     * Map a multiplication operation to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @param d value to multiply all entries by
-     * @return for convenience, return this
+     * Multiply each entry.
+     * The instance is changed in-place.
+     *
+     * @param d Multiplication factor.
+     * @return {@code this}.
      */
     RealVector mapMultiplyToSelf(double d);
 
     /**
-     * Map a division operation to each entry.
-     * @param d value to divide all entries by
-     * @return this / d
+     * Divide each entry.
+     *
+     * @param d Value to divide by.
+     * @return {@code this} / {@code d}.
      */
     RealVector mapDivide(double d);
 
     /**
-     * Map a division operation to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @param d value to divide all entries by
-     * @return for convenience, return this
+     * Divide each entry.
+     * The instance is changed in-place.
+     *
+     * @param d Value to divide by.
+     * @return {@code this}.
      */
     RealVector mapDivideToSelf(double d);
 
     /**
      * Map a power operation to each entry.
-     * @param d value to raise all entries to
-     * @return this ^ d
+     *
+     * @param d Operator value.
+     * @return a mapped copy of the vector.
      */
     RealVector mapPow(double d);
 
     /**
      * Map a power operation to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @param d value to raise all entries to
-     * @return for convenience, return this
+     * The instance is changed in-place.
+     *
+     * @param d Operator value.
+     * @return the mapped vector.
      */
     RealVector mapPowToSelf(double d);
 
     /**
      * Map the {@link Math#exp(double)} function to each entry.
-     * @return a vector containing the result of applying the function to each entry
+     *
+     * @return a mapped copy of the vector.
      */
     RealVector mapExp();
 
     /**
-     * Map the {@link Math#exp(double)} function to each entry.
-     * <p>The instance <strong>is</strong> changed by this method.</p>
-     * @return for convenience, return this
+     * Map {@link Math#exp(double)} operation to each entry.
+     * The instance is changed in-place.
+     *
+     * @return the mapped vector.
      */
     RealVector mapExpToSelf();
 
@@ -535,33 +567,37 @@
      * Element-by-element multiplication.
      * @param v vector by which instance elements must be multiplied
      * @return a vector containing this[i] * v[i] for all i
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector ebeMultiply(RealVector v) throws IllegalArgumentException;
+    RealVector ebeMultiply(RealVector v);
 
     /**
      * Element-by-element multiplication.
      * @param v vector by which instance elements must be multiplied
      * @return a vector containing this[i] * v[i] for all i
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector ebeMultiply(double[] v) throws IllegalArgumentException;
+    RealVector ebeMultiply(double[] v);
 
     /**
      * Element-by-element division.
      * @param v vector by which instance elements must be divided
      * @return a vector containing this[i] / v[i] for all i
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector ebeDivide(RealVector v) throws IllegalArgumentException;
+    RealVector ebeDivide(RealVector v);
 
     /**
      * Element-by-element division.
      * @param v vector by which instance elements must be divided
      * @return a vector containing this[i] / v[i] for all i
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector ebeDivide(double[] v) throws IllegalArgumentException;
+    RealVector ebeDivide(double[] v);
 
     /**
      * Returns vector entries as a double array.
@@ -573,19 +609,19 @@
      * Compute the dot product.
      * @param v vector with which dot product should be computed
      * @return the scalar dot product between instance and v
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    double dotProduct(RealVector v)
-        throws IllegalArgumentException;
+    double dotProduct(RealVector v);
 
     /**
      * Compute the dot product.
      * @param v vector with which dot product should be computed
      * @return the scalar dot product between instance and v
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    double dotProduct(double[] v)
-        throws IllegalArgumentException;
+    double dotProduct(double[] v);
 
     /**
      * Returns the L<sub>2</sub> norm of the vector.
@@ -627,13 +663,13 @@
      * elements differences, or euclidian distance.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getL1Distance(RealVector)
      * @see #getLInfDistance(RealVector)
      * @see #getNorm()
      */
-    double getDistance(RealVector v)
-        throws IllegalArgumentException;
+    double getDistance(RealVector v);
 
     /**
      * Distance between two vectors.
@@ -642,13 +678,13 @@
      * elements differences, or euclidian distance.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getL1Distance(double[])
      * @see #getLInfDistance(double[])
      * @see #getNorm()
      */
-    double getDistance(double[] v)
-        throws IllegalArgumentException;
+    double getDistance(double[] v);
 
     /**
      * Distance between two vectors.
@@ -657,13 +693,13 @@
      * elements differences.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getDistance(RealVector)
      * @see #getLInfDistance(RealVector)
      * @see #getL1Norm()
      */
-    double getL1Distance(RealVector v)
-        throws IllegalArgumentException;
+    double getL1Distance(RealVector v);
 
     /**
      * Distance between two vectors.
@@ -672,13 +708,13 @@
      * elements differences.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getDistance(double[])
      * @see #getLInfDistance(double[])
      * @see #getL1Norm()
      */
-    double getL1Distance(double[] v)
-        throws IllegalArgumentException;
+    double getL1Distance(double[] v);
 
     /**
      * Distance between two vectors.
@@ -687,13 +723,13 @@
      * elements differences.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getDistance(RealVector)
      * @see #getL1Distance(RealVector)
      * @see #getLInfNorm()
      */
-    double getLInfDistance(RealVector v)
-        throws IllegalArgumentException;
+    double getLInfDistance(RealVector v);
 
     /**
      * Distance between two vectors.
@@ -702,13 +738,13 @@
      * elements differences.</p>
      * @param v vector to which distance is requested
      * @return distance between two vectors.
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      * @see #getDistance(double[])
      * @see #getL1Distance(double[])
      * @see #getLInfNorm()
      */
-    double getLInfDistance(double[] v)
-        throws IllegalArgumentException;
+    double getLInfDistance(double[] v);
 
     /** Creates a unit vector pointing in the direction of this vector.
      * <p>The instance is not changed by this method.</p>
@@ -719,68 +755,65 @@
 
     /** Converts this vector into a unit vector.
      * <p>The instance itself is changed by this method.</p>
-     * @exception ArithmeticException if the norm is null
+     * @throws  org.apache.commons.math.exception.MathArithmeticException
+     * if the norm is zero.
      */
     void unitize();
 
     /** Find the orthogonal projection of this vector onto another vector.
      * @param v vector onto which instance must be projected
      * @return projection of the instance onto v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector projection(RealVector v)
-        throws IllegalArgumentException;
+    RealVector projection(RealVector v);
 
     /** Find the orthogonal projection of this vector onto another vector.
      * @param v vector onto which instance must be projected
      * @return projection of the instance onto v
-     * @throws IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealVector projection(double[] v)
-        throws IllegalArgumentException;
+    RealVector projection(double[] v);
 
     /**
      * Compute the outer product.
      * @param v vector with which outer product should be computed
      * @return the square matrix outer product between instance and v
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealMatrix outerProduct(RealVector v)
-        throws IllegalArgumentException;
+    RealMatrix outerProduct(RealVector v);
 
     /**
      * Compute the outer product.
      * @param v vector with which outer product should be computed
      * @return the square matrix outer product between instance and v
-     * @exception IllegalArgumentException if v is not the same size as this
+     * @throws org.apache.commons.math.exception.DimensionMismatchException
+     * if {@code v} is not the same size as this vector.
      */
-    RealMatrix outerProduct(double[] v)
-        throws IllegalArgumentException;
+    RealMatrix outerProduct(double[] v);
 
     /**
      * Returns the entry in the specified index.
-     * <p>
-     * The index start at 0 and must be lesser than the size,
-     * otherwise a {@link MatrixIndexException} is thrown.
-     * </p>
-     * @param index  index location of entry to be fetched
-     * @return vector entry at index
-     * @throws MatrixIndexException if the index is not valid
+     *
+     * @param index Index location of entry to be fetched.
+     * @return the vector entry at {@code index}.
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is not valid.
      * @see #setEntry(int, double)
      */
-    double getEntry(int index)
-        throws MatrixIndexException;
+    double getEntry(int index);
 
     /**
      * Set a single element.
      * @param index element index.
      * @param value new value for the element.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is not valid.
      * @see #getEntry(int)
      */
-    void setEntry(int index, double value)
-        throws MatrixIndexException;
+    void setEntry(int index, double value);
 
     /**
      * Returns the size of the vector.
@@ -814,33 +847,30 @@
      * @param index index of first element.
      * @param n number of elements to be retrieved.
      * @return a vector containing n elements.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is not valid.
      */
-    RealVector getSubVector(int index, int n)
-        throws MatrixIndexException;
+    RealVector getSubVector(int index, int n);
 
     /**
      * Set a set of consecutive elements.
      * @param index index of first element to be set.
      * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is not valid.
      * @see #setSubVector(int, double[])
      */
-    void setSubVector(int index, RealVector v)
-        throws MatrixIndexException;
+    void setSubVector(int index, RealVector v);
 
     /**
      * Set a set of consecutive elements.
      * @param index index of first element to be set.
      * @param v vector containing the values to set.
-     * @exception MatrixIndexException if the index is
-     * inconsistent with vector size
+     * @throws org.apache.commons.math.exception.OutOfRangeException
+     * if the index is not valid.
      * @see #setSubVector(int, RealVector)
      */
-    void setSubVector(int index, double[] v)
-        throws MatrixIndexException;
+    void setSubVector(int index, double[] v);
 
     /**
      * Set all elements to a single value.
@@ -857,17 +887,17 @@
     double[] toArray();
 
     /**
-     * Returns true if any coordinate of this vector is NaN; false otherwise
-     * @return  true if any coordinate of this vector is NaN; false otherwise
+     * Check whether any coordinate of this vector is {@code NaN}.
+     * @return {@code true} if any coordinate of this vector is {@code NaN},
+     * {@code false} otherwise.
      */
     boolean isNaN();
 
     /**
-     * Returns true if any coordinate of this vector is infinite and none are NaN;
-     * false otherwise
-     * @return  true if any coordinate of this vector is infinite and none are NaN;
-     * false otherwise
+     * Check whether any coordinate of this vector is infinite and none are {@code NaN}.
+     *
+     * @return {@code true} if any coordinate of this vector is infinite and
+     * none are {@code NaN}, {@code false} otherwise.
      */
     boolean isInfinite();
-
 }
diff --git a/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java
index ca90a2b..d19c9ec 100644
--- a/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java
@@ -28,25 +28,19 @@
  * @since 2.0
  */
 public class SparseFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {
-    /**
-     *  Serial id
-     */
+    /** Serialization identifier. */
     private static final long serialVersionUID = 9078068119297757342L;
     /** Storage for (sparse) matrix elements. */
     private final OpenIntToFieldHashMap<T> entries;
-    /**
-     * row dimension
-     */
+    /** Row dimension. */
     private final int rows;
-    /**
-     * column dimension
-     */
+    /** Column dimension. */
     private final int columns;
 
-
     /**
-     * Creates a matrix with no data.
-     * @param field field to which the elements belong
+     * Create a matrix with no data.
+     *
+     * @param field Field to which the elements belong.
      */
     public SparseFieldMatrix(final Field<T> field) {
         super(field);
@@ -56,16 +50,17 @@
     }
 
     /**
-     * Create a new SparseFieldMatrix<T> with the supplied row and column dimensions.
+     * Create a new SparseFieldMatrix<T> with the supplied row and column
+     * dimensions.
      *
-     * @param field field to which the elements belong
-     * @param rowDimension  the number of rows in the new matrix
-     * @param columnDimension  the number of columns in the new matrix
-     * @throws IllegalArgumentException if row or column dimension is not positive
+     * @param field Field to which the elements belong.
+     * @param rowDimension Number of rows in the new matrix.
+     * @param columnDimension Number of columns in the new matrix.
+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException
+     * if row or column dimension is not positive.
      */
     public SparseFieldMatrix(final Field<T> field,
-                             final int rowDimension, final int columnDimension)
-        throws IllegalArgumentException {
+                             final int rowDimension, final int columnDimension) {
         super(field, rowDimension, columnDimension);
         this.rows = rowDimension;
         this.columns = columnDimension;
@@ -74,7 +69,8 @@
 
     /**
      * Copy constructor.
-     * @param other The instance to copy
+     *
+     * @param other Instance to copy.
      */
     public SparseFieldMatrix(SparseFieldMatrix<T> other) {
         super(other.getField(), other.getRowDimension(), other.getColumnDimension());
@@ -85,7 +81,8 @@
 
     /**
      * Generic copy constructor.
-     * @param other The instance to copy
+     *
+     * @param other Instance to copy.
      */
     public SparseFieldMatrix(FieldMatrix<T> other){
         super(other.getField(), other.getRowDimension(), other.getColumnDimension());
@@ -101,8 +98,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void addToEntry(int row, int column, T increment)
-            throws MatrixIndexException {
+    public void addToEntry(int row, int column, T increment) {
         checkRowIndex(row);
         checkColumnIndex(column);
         final int key = computeKey(row, column);
@@ -112,7 +108,6 @@
         } else {
             entries.put(key, value);
         }
-
     }
 
     /** {@inheritDoc} */
@@ -123,8 +118,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension)
-            throws IllegalArgumentException {
+    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension) {
         return new SparseFieldMatrix<T>(getField(), rowDimension, columnDimension);
     }
 
@@ -136,7 +130,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public T getEntry(int row, int column) throws MatrixIndexException {
+    public T getEntry(int row, int column) {
         checkRowIndex(row);
         checkColumnIndex(column);
         return entries.get(computeKey(row, column));
@@ -150,8 +144,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void multiplyEntry(int row, int column, T factor)
-            throws MatrixIndexException {
+    public void multiplyEntry(int row, int column, T factor) {
         checkRowIndex(row);
         checkColumnIndex(column);
         final int key = computeKey(row, column);
@@ -166,8 +159,7 @@
 
     /** {@inheritDoc} */
     @Override
-    public void setEntry(int row, int column, T value)
-            throws MatrixIndexException {
+    public void setEntry(int row, int column, T value) {
         checkRowIndex(row);
         checkColumnIndex(column);
         if (getField().getZero().equals(value)) {
@@ -175,16 +167,16 @@
         } else {
             entries.put(computeKey(row, column), value);
         }
-
     }
+
     /**
-     * Compute the key to access a matrix element
-     * @param row row index of the matrix element
-     * @param column column index of the matrix element
-     * @return key within the map to access the matrix element
+     * Compute the key to access a matrix element.
+     *
+     * @param row Row index of the matrix element.
+     * @param column Column index of the matrix element.
+     * @return the key within the map to access the matrix element.
      */
     private int computeKey(int row, int column) {
         return row * columns + column;
     }
-
 }
diff --git a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java
index ee5a98a..b9f0d22 100644
--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java
+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java
@@ -21,8 +21,8 @@
 
 import org.apache.commons.math.Field;
 import org.apache.commons.math.FieldElement;
-import org.apache.commons.math.MathRuntimeException;
-import org.apache.commons.math.exception.util.LocalizedFormats;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.DimensionMismatchException;
 import org.apache.commons.math.util.OpenIntToFieldHashMap;
 
 /**
@@ -32,10 +32,7 @@
  * @since 2.0
  */
 public class SparseFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {
-
-    /**
-     *  Serial version id
-     */
+    /**  Serialization identifier. */
     private static final long serialVersionUID = 7841233292190413362L;
     /** Field to which the elements belong. */
     private final Field<T> field;
@@ -46,13 +43,14 @@
 
     /**
      * Build a 0-length vector.
-     * <p>Zero-length vectors may be used to initialize construction of vectors
+     * Zero-length vectors may be used to initialize construction of vectors
      * by data gathering. We start with zero-length and use either the {@link
      * #SparseFieldVector(SparseFieldVector, int)} constructor
-     * or one of the <code>append</code> method ({@link #append(FieldElement)},
+     * or one of the {@code append} method ({@link #append(FieldElement)},
      * {@link #append(FieldElement[])}, {@link #append(FieldVector)},
-     * {@link #append(SparseFieldVector)}) to gather data into this vector.</p>
-     * @param field field to which the elements belong
+     * {@link #append(SparseFieldVector)}) to gather data into this vector.
+     *
+     * @param field Field to which the elements belong.
      */
     public SparseFieldVector(Field<T> field) {
         this(field, 0);
@@ -60,9 +58,10 @@
 
 
     /**
-     * Construct a (dimension)-length vector of zeros.
-     * @param field field to which the elements belong
-     * @param dimension Size of the vector
+     * Construct a vector of zeroes.
+     *
+     * @param field Field to which the elements belong.
+     * @param dimension Size of the vector.
      */
     public SparseFieldVector(Field<T> field, int dimension) {
         this.field = field;
@@ -72,8 +71,9 @@
 
     /**
      * Build a resized vector, for use with append.
-     * @param v The original vector
-     * @param resize The amount to resize it
+     *
+     * @param v Original vector
+     * @param resize Amount to add.
      */
     protected SparseFieldVector(SparseFieldVector<T> v, int resize) {
         field = v.field;
@@ -84,9 +84,10 @@
 
     /**
      * Build a vector with known the sparseness (for advanced use only).
-     * @param field field to which the elements belong
-     * @param dimension The size of the vector
-     * @param expectedSize The expected number of non-zero entries
+     *
+     * @param field Field to which the elements belong.
+     * @param dimension Size of the vector.
+     * @param expectedSize Expected number of non-zero entries.
      */
     public SparseFieldVector(Field<T> field, int dimension, int expectedSize) {
         this.field = field;
@@ -96,9 +97,10 @@
 
     /**
      * Create from a Field array.
-     * Only non-zero entries will be stored
-     * @param field field to which the elements belong
-     * @param values The set of values to create from
+     * Only non-zero entries will be stored.
+     *
+     * @param field Field to which the elements belong.
+     * @param values Set of values to create from.
      */
     public SparseFieldVector(Field<T> field, T[] values) {
         this.field = field;
@@ -110,11 +112,10 @@
         }
     }
 
-
-
     /**
      * Copy constructor.
-     * @param v The instance to copy from
+     *
+     * @param v Instance to copy.
      */
     public SparseFieldVector(SparseFieldVector<T> v) {
         field = v.field;
@@ -124,7 +125,8 @@
 
     /**
      * Get the entries of this instance.
-     * @return entries of this instance
+     *
+     * @return the entries of this instance
      */
     private OpenIntToFieldHashMap<T> getEntries() {
         return entries;
@@ -132,11 +134,13 @@
 
     /**
      * Optimized method to add sparse vectors.
-     * @param v vector to add
-     * @return The sum of <code>this</code> and <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     *
+     * @param v Vector to add.
+     * @return the sum of {@code this} and {@code v}.
+     * @throws DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public FieldVector<T> add(SparseFieldVector<T> v) throws IllegalArgumentException {
+    public FieldVector<T> add(SparseFieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();
         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();
@@ -156,7 +160,7 @@
 
 
     /** {@inheritDoc} */
-    public FieldVector<T> add(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> add(T[] v) {
         checkVectorDimensions(v.length);
         SparseFieldVector<T> res = new SparseFieldVector<T>(field,getDimension());
         for (int i = 0; i < v.length; i++) {
@@ -167,8 +171,9 @@
 
     /**
      * Construct a vector by appending a vector to this vector.
-     * @param v vector to append to this one.
-     * @return a new vector
+     *
+     * @param v Vector to append to this one.
+     * @return a new vector.
      */
     public FieldVector<T> append(SparseFieldVector<T> v) {
         SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension());
@@ -211,7 +216,7 @@
    }
 
     /** {@inheritDoc} */
-    public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {
+    public T dotProduct(FieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         T res = field.getZero();
         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();
@@ -223,7 +228,7 @@
     }
 
     /** {@inheritDoc} */
-    public T dotProduct(T[] v) throws IllegalArgumentException {
+    public T dotProduct(T[] v) {
         checkVectorDimensions(v.length);
         T res = field.getZero();
         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();
@@ -239,8 +244,7 @@
      }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeDivide(FieldVector<T> v)
-        throws IllegalArgumentException {
+    public FieldVector<T> ebeDivide(FieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         SparseFieldVector<T> res = new SparseFieldVector<T>(this);
         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();
@@ -252,7 +256,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> ebeDivide(T[] v) {
         checkVectorDimensions(v.length);
         SparseFieldVector<T> res = new SparseFieldVector<T>(this);
         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();
@@ -264,7 +268,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> ebeMultiply(FieldVector<T> v)throws IllegalArgumentException {
+    public FieldVector<T> ebeMultiply(FieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         SparseFieldVector<T> res = new SparseFieldVector<T>(this);
         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();
@@ -276,7 +280,7 @@
     }
 
     /** {@inheritDoc} */
-     public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {
+     public FieldVector<T> ebeMultiply(T[] v) {
         checkVectorDimensions(v.length);
         SparseFieldVector<T> res = new SparseFieldVector<T>(this);
         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();
@@ -304,7 +308,7 @@
     }
 
      /** {@inheritDoc} */
-     public T getEntry(int index) throws MatrixIndexException {
+     public T getEntry(int index) {
         checkIndex(index);
         return entries.get(index);
    }
@@ -315,8 +319,7 @@
     }
 
      /** {@inheritDoc} */
-     public FieldVector<T> getSubVector(int index, int n)
-            throws MatrixIndexException {
+     public FieldVector<T> getSubVector(int index, int n) {
         checkIndex(index);
         checkIndex(index + n - 1);
         SparseFieldVector<T> res = new SparseFieldVector<T>(field,n);
@@ -398,14 +401,14 @@
         return mapAddToSelf(field.getZero().subtract(d));
     }
 
-     /**
-      * Optimized method to compute outer product when both vectors are sparse.
-      * @param v vector with which outer product should be computed
-      * @return the square matrix outer product between instance and v
-      * @throws IllegalArgumentException if v is not the same size as {@code this}
-      */
-    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v)
-            throws IllegalArgumentException {
+    /**
+     * Optimized method to compute outer product when both vectors are sparse.
+     * @param v vector with which outer product should be computed
+     * @return the square matrix outer product between instance and v
+     * @throws DimensionMismatchException
+     * if the dimensions do not match.
+     */
+    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         SparseFieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);
         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();
@@ -421,7 +424,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {
+    public FieldMatrix<T> outerProduct(T[] v) {
         checkVectorDimensions(v.length);
         FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);
         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();
@@ -437,8 +440,7 @@
      }
 
     /** {@inheritDoc} */
-    public FieldMatrix<T> outerProduct(FieldVector<T> v)
-    throws IllegalArgumentException {
+    public FieldMatrix<T> outerProduct(FieldVector<T> v) {
         if(v instanceof SparseFieldVector<?>)
             return outerProduct((SparseFieldVector<T>)v);
         else
@@ -446,14 +448,13 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> projection(FieldVector<T> v)
-    throws IllegalArgumentException {
+    public FieldVector<T> projection(FieldVector<T> v) {
         checkVectorDimensions(v.getDimension());
         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> projection(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> projection(T[] v) {
         checkVectorDimensions(v.length);
         return projection(new SparseFieldVector<T>(field,v));
     }
@@ -466,21 +467,20 @@
     }
 
     /** {@inheritDoc} */
-    public void setEntry(int index, T value) throws MatrixIndexException {
+    public void setEntry(int index, T value) {
         checkIndex(index);
         entries.put(index, value);
    }
 
     /** {@inheritDoc} */
-    public void setSubVector(int index, FieldVector<T> v)
-            throws MatrixIndexException {
+    public void setSubVector(int index, FieldVector<T> v) {
         checkIndex(index);
         checkIndex(index + v.getDimension() - 1);
         setSubVector(index, v.getData());
     }
 
     /** {@inheritDoc} */
-    public void setSubVector(int index, T[] v) throws MatrixIndexException {
+    public void setSubVector(int index, T[] v) {
         checkIndex(index);
         checkIndex(index + v.length - 1);
         for (int i = 0; i < v.length; i++) {
@@ -491,11 +491,13 @@
 
     /**
      * Optimized method to subtract SparseRealVectors.
-     * @param v The vector to subtract from <code>this</code>
-     * @return The difference of <code>this</code> and <code>v</code>
-     * @throws IllegalArgumentException If the dimensions don't match
+     *
+     * @param v Vector to subtract.
+     * @return the difference between {@code this} and {@code v}.
+     * @throws DimensionMismatchException
+     * if the dimensions do not match.
      */
-    public SparseFieldVector<T> subtract(SparseFieldVector<T> v) throws IllegalArgumentException{
+    public SparseFieldVector<T> subtract(SparseFieldVector<T> v){
         checkVectorDimensions(v.getDimension());
         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();
         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();
@@ -512,8 +514,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> subtract(FieldVector<T> v)
-           throws IllegalArgumentException {
+    public FieldVector<T> subtract(FieldVector<T> v) {
         if(v instanceof SparseFieldVector<?>)
             return subtract((SparseFieldVector<T>)v);
         else
@@ -521,7 +522,7 @@
     }
 
     /** {@inheritDoc} */
-    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {
+    public FieldVector<T> subtract(T[] v) {
         checkVectorDimensions(v.length);
         SparseFieldVector<T> res = new SparseFieldVector<T>(this);
         for (int i = 0; i < v.length; i++) {
@@ -540,39 +541,31 @@
     }
 
     /**
-     * Check if an index is valid.
+     * Check whether an index is valid.
      *
-     * @param index
-     *            index to check
-     * @exception MatrixIndexException
-     *                if index is not valid
+     * @param index Index to check.
+     * @throws OutOfRangeException if the dimensions do not match.
      */
-    private void checkIndex(final int index) throws MatrixIndexException {
+    private void checkIndex(final int index) {
         if (index < 0 || index >= getDimension()) {
-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,
-                                           index, 0, getDimension() - 1);
+            throw new OutOfRangeException(index, 0, getDimension() - 1);
         }
     }
 
     /**
      * Check if instance dimension is equal to some expected value.
      *
-     * @param n
-     *            expected dimension.
-     * @exception IllegalArgumentException
-     *                if the dimension is inconsistent with vector size
+     * @param n Expected dimension.
+     * @throws DimensionMismatchException if the dimensions do not match.
      */
-    protected void checkVectorDimensions(int n) throws IllegalArgumentException {
+    protected void checkVectorDimensions(int n) {
         if (getDimension() != n) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,
-                    getDimension(), n);
+            throw new DimensionMismatchException(getDimension(), n);
         }
     }
 
-
     /** {@inheritDoc} */
-    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {
+    public FieldVector<T> add(FieldVector<T> v) {
         if (v instanceof SparseFieldVector<?>) {
             return add((SparseFieldVector<T>)v);
         } else {
@@ -580,9 +573,11 @@
         }
     }
 
-    /** Build an array of elements.
-     * @param length size of the array to build
-     * @return a new array
+    /**
+     * Build an array of elements.
+     *
+     * @param length Size of the array to build.
+     * @return a new array.
      */
     @SuppressWarnings("unchecked") // field is type T
     private T[] buildArray(final int length) {
@@ -651,7 +646,4 @@
         }
         return true;
     }
-
-
-
 }
diff --git a/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties b/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
index bccc02a..fb05f33 100644
--- a/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
+++ b/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
@@ -84,11 +84,12 @@
 INDEX_LARGER_THAN_MAX = l''index sp\u00e9cifi\u00e9 ({0}) d\u00e9passe l''index maximal courant ({1})
 INDEX_NOT_POSITIVE = l''indice ({0}) n''est pas positif
 INDEX_OUT_OF_RANGE = l''indice ({0}) est hors du domaine autoris\u00e9 [{1}, {2}]
+INDEX = indice ({0})
 INFINITE_ARRAY_ELEMENT = le tableau contient l''\u00e9l\u00e9ment infini {0} \u00e0 l''index {1}
 INFINITE_VALUE_CONVERSION = les valeurs infinies ne peuvent \u00eatre converties
 INITIAL_CAPACITY_NOT_POSITIVE = la capacit\u00e9 initiale ({0}) n''est pas positive
-INITIAL_COLUMN_AFTER_FINAL_COLUMN = colonne initiale {0} apr\u00e8s la colonne finale {1}
-INITIAL_ROW_AFTER_FINAL_ROW = ligne initiale {0} apr\u00e8s la ligne finale {1}
+INITIAL_COLUMN_AFTER_FINAL_COLUMN = colonne initiale {1} apr\u00e8s la colonne finale {0}
+INITIAL_ROW_AFTER_FINAL_ROW = ligne initiale {1} apr\u00e8s la ligne finale {0}
 INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE = les donn\u00e9es d''entr\u00e9e proviennent 
 INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES = l''instance de la classe {0} n''est pas comparable aux valeurs existantes
 INSUFFICIENT_DATA_FOR_T_STATISTIC = deux valeurs ou plus sont n\u00e9cessaires pour la statistique t, il y en a {0}
diff --git a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java
index 4cca7f6..1997b5f 100644
--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java
+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java
@@ -21,6 +21,9 @@
 import org.apache.commons.math.TestUtils;
 import org.apache.commons.math.util.FastMath;
 import org.apache.commons.math.exception.MatrixDimensionMismatchException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.NumberIsTooSmallException;
 
 /**
  * Test cases for the {@link Array2DRowRealMatrix} class.
@@ -316,14 +319,14 @@
         TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);
         try {
             m.getRow(10);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
         try {
             m.getColumn(-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
     }
@@ -333,8 +336,8 @@
         assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
         try {
             m.getEntry(10, 4);
-            fail ("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail ("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -394,9 +397,17 @@
             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);
             assertEquals(new Array2DRowRealMatrix(reference), sub);
             if (mustFail) {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (!mustFail) {
                 throw e;
             }
@@ -410,9 +421,17 @@
             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);
             assertEquals(new Array2DRowRealMatrix(reference), sub);
             if (mustFail) {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (!mustFail) {
                 throw e;
             }
@@ -449,9 +468,17 @@
             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);
             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));
             if (mustFail) {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (!mustFail) {
                 throw e;
             }
@@ -468,9 +495,17 @@
             m.copySubMatrix(selectedRows, selectedColumns, sub);
             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));
             if (mustFail) {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (!mustFail) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (!mustFail) {
                 throw e;
             }
@@ -487,14 +522,14 @@
                 m.getRowMatrix(3));
         try {
             m.getRowMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -507,8 +542,8 @@
         assertEquals(mRow3, m.getRowMatrix(0));
         try {
             m.setRowMatrix(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -529,14 +564,14 @@
                 m.getColumnMatrix(3));
         try {
             m.getColumnMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -549,8 +584,8 @@
         assertEquals(mColumn3, m.getColumnMatrix(1));
         try {
             m.setColumnMatrix(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -569,14 +604,14 @@
         assertEquals("Row3", mRow3, m.getRowVector(3));
         try {
             m.getRowVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -589,8 +624,8 @@
         assertEquals(mRow3, m.getRowVector(0));
         try {
             m.setRowVector(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -609,14 +644,14 @@
         assertEquals("Column3", mColumn3, m.getColumnVector(3));
         try {
             m.getColumnVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -629,8 +664,8 @@
         assertEquals(mColumn3, m.getColumnVector(1));
         try {
             m.setColumnVector(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -655,14 +690,14 @@
         checkArrays(subRow3[0], m.getRow(3));
         try {
             m.getRow(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRow(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -674,8 +709,8 @@
         checkArrays(subRow3[0], m.getRow(0));
         try {
             m.setRow(-1, subRow3[0]);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -694,14 +729,14 @@
         checkArrays(mColumn3, m.getColumn(3));
         try {
             m.getColumn(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumn(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -714,8 +749,8 @@
         checkArrays(mColumn3, m.getColumn(1));
         try {
             m.setColumn(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -783,21 +818,21 @@
         // dimension overflow
         try {
             m.setSubMatrix(testData,1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         // dimension underflow
         try {
             m.setSubMatrix(testData,-1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         try {
             m.setSubMatrix(testData,1,-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
 
diff --git a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
index 275c5ea..44f8280 100644
--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
@@ -26,6 +26,7 @@
 import org.apache.commons.math.TestUtils;
 import org.apache.commons.math.fraction.Fraction;
 import org.apache.commons.math.fraction.FractionField;
+import org.apache.commons.math.exception.OutOfRangeException;
 
 /**
  * Test cases for the {@link ArrayFieldVector} class.
@@ -365,8 +366,8 @@
         assertEquals(new Fraction(5), vout5.getEntry(1));
         try {
             v4.getSubVector(3, 7);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -375,8 +376,8 @@
         assertEquals(new Fraction(11), v_set1.getEntry(1));
         try {
             v_set1.setEntry(3, new Fraction(11));
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -386,8 +387,8 @@
         assertEquals(new Fraction(7), v_set2.getEntry(6));
         try {
             v_set2.set(7, v1);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -408,8 +409,8 @@
         assertEquals(new Fraction(7), v_set4.getEntry(6));
         try {
             v_set4.setSubVector(7, v2_t);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
diff --git a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java
index 5edfde3..863dc66 100644
--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java
+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java
@@ -25,6 +25,7 @@
 import org.apache.commons.math.TestUtils;
 import org.apache.commons.math.analysis.UnivariateRealFunction;
 import org.apache.commons.math.util.FastMath;
+import org.apache.commons.math.exception.OutOfRangeException;
 
 /**
  * Test cases for the {@link ArrayRealVector} class.
@@ -655,8 +656,8 @@
         assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));
         try {
             v4.getSubVector(3, 7);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -665,8 +666,8 @@
         assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));
         try {
             v_set1.setEntry(3, 11.0);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -676,8 +677,8 @@
         assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));
         try {
             v_set2.set(7, v1);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -698,8 +699,8 @@
         assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));
         try {
             v_set4.setSubVector(7, v2_t);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
diff --git a/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java b/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java
deleted file mode 100644
index 712ca1c..0000000
--- a/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java
+++ /dev/null
@@ -1,836 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.math.linear;
-
-import java.math.BigDecimal;
-
-import junit.framework.TestCase;
-
-
-/**
- * Test cases for the {@link BigMatrixImpl} class.
- *
- * @version $Revision$ $Date$
- */
-@Deprecated
-public final class BigMatrixImplTest extends TestCase {
-
-    // Test data for String constructors
-    protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };
-
-    // 3 x 3 identity matrix
-    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };
-
-    // Test data for group operations
-    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
-    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};
-    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };
-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},
-            {-1d,0d,-8d} };
-    protected double[] testDataRow1 = {1d,2d,3d};
-    protected double[] testDataCol3 = {3d,3d,8d};
-    protected double[][] testDataInv =
-        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };
-    protected double[] preMultTest = {8,12,33};
-    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};
-    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};
-    protected double[][] testDataPlusInv =
-        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };
-
-    // lu decomposition tests
-    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };
-    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},
-            {0.33333333333333,0d,0.33333333333333} };
-
-    // singular matrices
-    protected double[][] singular = { {2d,3d}, {2d,3d} };
-    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},
-            {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd
-    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };
-    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};
-
-    // vectors
-    protected double[] testVector = {1,2,3};
-    protected double[] testVector2 = {1,2,3,4};
-
-    // submatrix accessor tests
-    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},
-            {2, 4, 6, 8}, {4, 5, 6, 7}};
-    // array selections
-    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};
-    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};
-    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};
-    // effective permutations
-    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};
-    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};
-    // contiguous ranges
-    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};
-    protected double[][] subRows23Cols00 = {{2} , {4}};
-    protected double[][] subRows00Cols33 = {{4}};
-    // row matrices
-    protected double[][] subRow0 = {{1,2,3,4}};
-    protected double[][] subRow3 = {{4,5,6,7}};
-    // column matrices
-    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};
-    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};
-
-    // tolerances
-    protected double entryTolerance = 10E-16;
-    protected double normTolerance = 10E-14;
-
-    public BigMatrixImplTest(String name) {
-        super(name);
-    }
-
-    public static final double[] asDouble(BigDecimal[] data) {
-        double d[] = new double[data.length];
-        for (int i=0;i<d.length;i++) {
-            d[i] = data[i].doubleValue();
-        }
-        return d;
-    }
-
-    public static final double[][] asDouble(BigDecimal[][] data) {
-        double d[][] = new double[data.length][data[0].length];
-        for (int i=0;i<d.length;i++) {
-            for (int j=0;j<d[i].length;j++)
-            d[i][j] = data[i][j].doubleValue();
-        }
-        return d;
-    }
-
-    public static final BigDecimal[] asBigDecimal(double [] data) {
-        BigDecimal d[] = new BigDecimal[data.length];
-        for (int i=0;i<d.length;i++) {
-            d[i] = new BigDecimal(data[i]);
-        }
-        return d;
-    }
-
-    public static final BigDecimal[][] asBigDecimal(double [][] data) {
-        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];
-        for (int i=0;i<d.length;i++) {
-            for (int j=0;j<data[i].length;j++) {
-                d[i][j] = new BigDecimal(data[i][j]);
-            }
-        }
-        return d;
-    }
-
-    /** test dimensions */
-    public void testDimensions() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl m2 = new BigMatrixImpl(testData2);
-        assertEquals("testData row dimension",3,m.getRowDimension());
-        assertEquals("testData column dimension",3,m.getColumnDimension());
-        assertTrue("testData is square",m.isSquare());
-        assertEquals("testData2 row dimension",m2.getRowDimension(),2);
-        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
-        assertTrue("testData2 is not square",!m2.isSquare());
-    }
-
-    /** test copy functions */
-    public void testCopyFunctions() {
-        BigMatrixImpl m1 = new BigMatrixImpl(testData);
-        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());
-        assertEquals(m2,m1);
-        BigMatrixImpl m3 = new BigMatrixImpl(testData);
-        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);
-        assertEquals(m4,m3);
-    }
-
-    /** test constructors */
-    public void testConstructors() {
-        BigMatrix m1 = new BigMatrixImpl(testData);
-        BigMatrix m2 = new BigMatrixImpl(testDataString);
-        BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));
-        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);
-        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);
-        assertClose("double, string", m1, m2, Double.MIN_VALUE);
-        assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);
-        assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);
-        assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE);
-        assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE);
-        try {
-            new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});
-            fail("Expecting NumberFormatException");
-        } catch (NumberFormatException ex) {
-            // expected
-        }
-        try {
-            new BigMatrixImpl(new String[][] {});
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            new BigMatrixImpl(new String[][] {{},{}});
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-
-        try {
-            new BigMatrixImpl(0, 1);
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            new BigMatrixImpl(1, 0);
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-    }
-
-    /** test add */
-    public void testAdd() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
-        BigMatrix mPlusMInv = m.add(mInv);
-        double[][] sumEntries = asDouble(mPlusMInv.getData());
-        for (int row = 0; row < m.getRowDimension(); row++) {
-            for (int col = 0; col < m.getColumnDimension(); col++) {
-                assertEquals("sum entry entry",
-                    testDataPlusInv[row][col],sumEntries[row][col],
-                        entryTolerance);
-            }
-        }
-    }
-
-    /** test add failure */
-    public void testAddFail() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl m2 = new BigMatrixImpl(testData2);
-        try {
-            m.add(m2);
-            fail("IllegalArgumentException expected");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test norm */
-    public void testNorm() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl m2 = new BigMatrixImpl(testData2);
-        assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);
-        assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);
-    }
-
-     /** test m-n = m + -n */
-    public void testPlusMinus() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);
-        assertClose("m-n = m + -n",m.subtract(m2),
-            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);
-        try {
-            m.subtract(new BigMatrixImpl(testData2));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test multiply */
-     public void testMultiply() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
-        BigMatrixImpl identity = new BigMatrixImpl(id);
-        BigMatrixImpl m2 = new BigMatrixImpl(testData2);
-        assertClose("inverse multiply",m.multiply(mInv),
-            identity,entryTolerance);
-        assertClose("inverse multiply",mInv.multiply(m),
-            identity,entryTolerance);
-        assertClose("identity multiply",m.multiply(identity),
-            m,entryTolerance);
-        assertClose("identity multiply",identity.multiply(mInv),
-            mInv,entryTolerance);
-        assertClose("identity multiply",m2.multiply(identity),
-            m2,entryTolerance);
-        try {
-            m.multiply(new BigMatrixImpl(bigSingular));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    //Additional Test for BigMatrixImplTest.testMultiply
-
-    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};
-    private double[][] d4 = new double[][] {{1},{2},{3},{4}};
-    private double[][] d5 = new double[][] {{30},{70}};
-
-    public void testMultiply2() {
-       BigMatrix m3 = new BigMatrixImpl(d3);
-       BigMatrix m4 = new BigMatrixImpl(d4);
-       BigMatrix m5 = new BigMatrixImpl(d5);
-       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);
-   }
-
-    /** test isSingular */
-    public void testIsSingular() {
-        BigMatrixImpl m = new BigMatrixImpl(singular);
-        assertTrue("singular",m.isSingular());
-        m = new BigMatrixImpl(bigSingular);
-        assertTrue("big singular",m.isSingular());
-        m = new BigMatrixImpl(id);
-        assertTrue("identity nonsingular",!m.isSingular());
-        m = new BigMatrixImpl(testData);
-        assertTrue("testData nonsingular",!m.isSingular());
-    }
-
-    /** test inverse */
-    public void testInverse() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrix mInv = new BigMatrixImpl(testDataInv);
-        assertClose("inverse",mInv,m.inverse(),normTolerance);
-        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);
-
-        // Not square
-        m = new BigMatrixImpl(testData2);
-        try {
-            m.inverse();
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // expected
-        }
-
-        // Singular
-        m = new BigMatrixImpl(singular);
-        try {
-            m.inverse();
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // expected
-        }
-    }
-
-    /** test solve */
-    public void testSolve() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrix mInv = new BigMatrixImpl(testDataInv);
-        // being a bit slothful here -- actually testing that X = A^-1 * B
-        assertClose("inverse-operate",
-                    asDouble(mInv.operate(asBigDecimal(testVector))),
-                    asDouble(m.solve(asBigDecimal(testVector))),
-                    normTolerance);
-        try {
-            asDouble(m.solve(asBigDecimal(testVector2)));
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-        BigMatrix bs = new BigMatrixImpl(bigSingular);
-        try {
-            bs.solve(bs);
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // ignored
-        }
-        try {
-            m.solve(bs);
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-        try {
-            new BigMatrixImpl(testData2).solve(bs);
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-        try {
-            (new BigMatrixImpl(testData2)).luDecompose();
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // ignored
-        }
-    }
-
-    /** test determinant */
-    public void testDeterminant() {
-        BigMatrix m = new BigMatrixImpl(bigSingular);
-        assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);
-        m = new BigMatrixImpl(detData);
-        assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);
-
-        // Examples verified against R (version 1.8.1, Red Hat Linux 9)
-        m = new BigMatrixImpl(detData2);
-        assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);
-        m = new BigMatrixImpl(testData);
-        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);
-
-        try {
-            double d = new BigMatrixImpl(testData2).getDeterminant().doubleValue();
-            fail("Expecting InvalidMatrixException, got " + d);
-        } catch (InvalidMatrixException ex) {
-            // ignored
-        }
-    }
-
-    /** test trace */
-    public void testTrace() {
-        BigMatrix m = new BigMatrixImpl(id);
-        assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);
-        m = new BigMatrixImpl(testData2);
-        try {
-            double t = m.getTrace().doubleValue();
-            fail("Expecting NonSquareMatrixException, got " + t);
-        } catch (NonSquareMatrixException ex) {
-            // ignored
-        }
-    }
-
-    /** test sclarAdd */
-    public void testScalarAdd() {
-        BigMatrix m = new BigMatrixImpl(testData);
-        assertClose("scalar add",new BigMatrixImpl(testDataPlus2),
-            m.scalarAdd(new BigDecimal(2d)),entryTolerance);
-    }
-
-    /** test operate */
-    public void testOperate() {
-        BigMatrix m = new BigMatrixImpl(id);
-        double[] x = asDouble(m.operate(asBigDecimal(testVector)));
-        assertClose("identity operate",testVector,x,entryTolerance);
-        m = new BigMatrixImpl(bigSingular);
-        try {
-            asDouble(m.operate(asBigDecimal(testVector)));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test issue MATH-209 */
-    public void testMath209() {
-        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {
-                { new BigDecimal(1), new BigDecimal(2) },
-                { new BigDecimal(3), new BigDecimal(4) },
-                { new BigDecimal(5), new BigDecimal(6) }
-        }, false);
-        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });
-        assertEquals(a.getRowDimension(), b.length);
-        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);
-        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);
-        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);
-    }
-
-    /** test transpose */
-    public void testTranspose() {
-        BigMatrix m = new BigMatrixImpl(testData);
-        assertClose("inverse-transpose",m.inverse().transpose(),
-            m.transpose().inverse(),normTolerance);
-        m = new BigMatrixImpl(testData2);
-        BigMatrix mt = new BigMatrixImpl(testData2T);
-        assertClose("transpose",mt,m.transpose(),normTolerance);
-    }
-
-    /** test preMultiply by vector */
-    public void testPremultiplyVector() {
-        BigMatrix m = new BigMatrixImpl(testData);
-        assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);
-        m = new BigMatrixImpl(bigSingular);
-        try {
-            m.preMultiply(asBigDecimal(testVector));
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    public void testPremultiply() {
-        BigMatrix m3 = new BigMatrixImpl(d3);
-        BigMatrix m4 = new BigMatrixImpl(d4);
-        BigMatrix m5 = new BigMatrixImpl(d5);
-        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);
-
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
-        BigMatrixImpl identity = new BigMatrixImpl(id);
-        new BigMatrixImpl(testData2);
-        assertClose("inverse multiply",m.preMultiply(mInv),
-                identity,entryTolerance);
-        assertClose("inverse multiply",mInv.preMultiply(m),
-                identity,entryTolerance);
-        assertClose("identity multiply",m.preMultiply(identity),
-                m,entryTolerance);
-        assertClose("identity multiply",identity.preMultiply(mInv),
-                mInv,entryTolerance);
-        try {
-            m.preMultiply(new BigMatrixImpl(bigSingular));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    public void testGetVectors() {
-        BigMatrix m = new BigMatrixImpl(testData);
-        assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);
-        assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);
-        try {
-            m.getRowAsDoubleArray(10);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // ignored
-        }
-        try {
-            m.getColumnAsDoubleArray(-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // ignored
-        }
-    }
-
-    public void testLUDecomposition() throws Exception {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrix lu = m.getLUMatrix();
-        assertClose("LU decomposition", lu, new BigMatrixImpl(testDataLU), normTolerance);
-        verifyDecomposition(m, lu);
-        m = new BigMatrixImpl(luData);
-        lu = m.getLUMatrix();
-        assertClose("LU decomposition", lu, new BigMatrixImpl(luDataLUDecomposition), normTolerance);
-        verifyDecomposition(m, lu);
-        m = new BigMatrixImpl(testDataMinus);
-        lu = m.getLUMatrix();
-        verifyDecomposition(m, lu);
-        m = new BigMatrixImpl(id);
-        lu = m.getLUMatrix();
-        verifyDecomposition(m, lu);
-        try {
-            m = new BigMatrixImpl(bigSingular); // singular
-            lu = m.getLUMatrix();
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // expected
-        }
-        try {
-            m = new BigMatrixImpl(testData2);  // not square
-            lu = m.getLUMatrix();
-            fail("Expecting InvalidMatrixException");
-        } catch (InvalidMatrixException ex) {
-            // expected
-        }
-    }
-
-   /**
-    * test submatrix accessors
-    */
-    public void testSubMatrix() {
-        BigMatrix m = new BigMatrixImpl(subTestData);
-        BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);
-        BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);
-        BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);
-        BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);
-        BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);
-        BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);
-        BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);
-        BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);
-        assertEquals("Rows23Cols00", mRows23Cols00,
-                m.getSubMatrix(2 , 3 , 0, 0));
-        assertEquals("Rows00Cols33", mRows00Cols33,
-                m.getSubMatrix(0 , 0 , 3, 3));
-        assertEquals("Rows01Cols23", mRows01Cols23,
-                m.getSubMatrix(0 , 1 , 2, 3));
-        assertEquals("Rows02Cols13", mRows02Cols13,
-                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));
-        assertEquals("Rows03Cols12", mRows03Cols12,
-                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));
-        assertEquals("Rows03Cols123", mRows03Cols123,
-                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));
-        assertEquals("Rows20Cols123", mRows20Cols123,
-                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));
-        assertEquals("Rows31Cols31", mRows31Cols31,
-                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));
-        assertEquals("Rows31Cols31", mRows31Cols31,
-                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));
-
-        try {
-            m.getSubMatrix(1,0,2,4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getSubMatrix(-1,1,2,2);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getSubMatrix(1,0,2,2);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getSubMatrix(1,0,2,4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getSubMatrix(new int[] {}, new int[] {0});
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getSubMatrix(new int[] {0}, new int[] {4});
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testGetColumnMatrix() {
-        BigMatrix m = new BigMatrixImpl(subTestData);
-        BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);
-        BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);
-        assertEquals("Column1", mColumn1,
-                m.getColumnMatrix(1));
-        assertEquals("Column3", mColumn3,
-                m.getColumnMatrix(3));
-        try {
-            m.getColumnMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getColumnMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testGetRowMatrix() {
-        BigMatrix m = new BigMatrixImpl(subTestData);
-        BigMatrix mRow0 = new BigMatrixImpl(subRow0);
-        BigMatrix mRow3 = new BigMatrixImpl(subRow3);
-        assertEquals("Row0", mRow0,
-                m.getRowMatrix(0));
-        assertEquals("Row3", mRow3,
-                m.getRowMatrix(3));
-        try {
-            m.getRowMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getRowMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testEqualsAndHashCode() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        BigMatrixImpl m1 = (BigMatrixImpl) m.copy();
-        BigMatrixImpl mt = (BigMatrixImpl) m.transpose();
-        assertTrue(m.hashCode() != mt.hashCode());
-        assertEquals(m.hashCode(), m1.hashCode());
-        assertEquals(m, m);
-        assertEquals(m, m1);
-        assertFalse(m.equals(null));
-        assertFalse(m.equals(mt));
-        assertFalse(m.equals(new BigMatrixImpl(bigSingular)));
-        // Different scales make BigDecimals, so matrices unequal
-        m = new BigMatrixImpl(new String[][] {{"2.0"}});
-        m1 = new BigMatrixImpl(new String[][] {{"2.00"}});
-        assertTrue(m.hashCode() != m1.hashCode());
-        assertFalse(m.equals(m1));
-    }
-
-    public void testToString() {
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",
-                m.toString());
-        m = new BigMatrixImpl();
-        assertEquals("BigMatrixImpl{}",
-                m.toString());
-    }
-
-    public void testSetSubMatrix() throws Exception {
-        BigDecimal[][] detData3 =
-            MatrixUtils.createBigMatrix(detData2).getData();
-        BigMatrixImpl m = new BigMatrixImpl(testData);
-        m.setSubMatrix(detData3,1,1);
-        BigMatrix expected = MatrixUtils.createBigMatrix
-            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});
-        assertEquals(expected, m);
-
-        m.setSubMatrix(detData3,0,0);
-        expected = MatrixUtils.createBigMatrix
-            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});
-        assertEquals(expected, m);
-
-        BigDecimal[][] testDataPlus3 =
-            MatrixUtils.createBigMatrix(testDataPlus2).getData();
-        m.setSubMatrix(testDataPlus3,0,0);
-        expected = MatrixUtils.createBigMatrix
-        (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});
-        assertEquals(expected, m);
-
-        // javadoc example
-        BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix
-            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});
-        matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),
-            new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);
-        expected = MatrixUtils.createBigMatrix
-            (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),
-             new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),
-             new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},
-             {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),
-              new BigDecimal(2)}});
-        assertEquals(expected, matrix);
-
-        // dimension overflow
-        try {
-            m.setSubMatrix(matrix.getData(),1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
-            // expected
-        }
-
-        // null
-        try {
-            m.setSubMatrix(null,1,1);
-            fail("expecting NullPointerException");
-        } catch (NullPointerException e) {
-            // expected
-        }
-
-        // ragged
-        try {
-            m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},
-                    {new BigDecimal(2), new BigDecimal(3)}}, 0, 0);
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        // empty
-        try {
-            m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-    }
-
-    //--------------- -----------------Protected methods
-
-    /** verifies that two matrices are close (1-norm) */
-    protected void assertClose(String msg, BigMatrix m, BigMatrix n,
-        double tolerance) {
-        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);
-    }
-
-    /** verifies that two vectors are close (sup norm) */
-    protected void assertClose(String msg, double[] m, double[] n,
-        double tolerance) {
-        if (m.length != n.length) {
-            fail("vectors not same length");
-        }
-        for (int i = 0; i < m.length; i++) {
-            assertEquals(msg + " " +  i + " elements differ",
-                m[i],n[i],tolerance);
-        }
-    }
-
-    /** extracts the l  and u matrices from compact lu representation */
-    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {
-        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||
-                lowerData.length != upperData.length
-                || lowerData.length != lu.getRowDimension()) {
-            throw new InvalidMatrixException("incorrect dimensions");
-        }
-        int n = lu.getRowDimension();
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < n; j++) {
-                if (j < i) {
-                    lowerData[i][j] = lu.getEntry(i, j);
-                    upperData[i][j] = new BigDecimal(0);
-                } else if (i == j) {
-                    lowerData[i][j] = new BigDecimal(1);
-                    upperData[i][j] = lu.getEntry(i, j);
-                } else {
-                    lowerData[i][j] = new BigDecimal(0);
-                    upperData[i][j] = lu.getEntry(i, j);
-                }
-            }
-        }
-    }
-
-    /** Returns the result of applying the given row permutation to the matrix */
-    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {
-        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {
-            throw new IllegalArgumentException("dimension mismatch");
-        }
-        int n = matrix.getRowDimension();
-        int m = matrix.getColumnDimension();
-        BigDecimal out[][] = new BigDecimal[m][n];
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                out[i][j] = matrix.getEntry(permutation[i], j);
-            }
-        }
-        return new BigMatrixImpl(out);
-    }
-
-    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */
-    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{
-        int n = matrix.getRowDimension();
-        BigDecimal[][] lowerData = new BigDecimal[n][n];
-        BigDecimal[][] upperData = new BigDecimal[n][n];
-        splitLU(lu, lowerData, upperData);
-        BigMatrix lower =new BigMatrixImpl(lowerData);
-        BigMatrix upper = new BigMatrixImpl(upperData);
-        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();
-        BigMatrix permuted = permuteRows(matrix, permutation);
-        assertClose("lu decomposition does not work", permuted,
-                lower.multiply(upper), normTolerance);
-    }
-
-//    /** Useful for debugging */
-//    private void dumpMatrix(BigMatrix m) {
-//          for (int i = 0; i < m.getRowDimension(); i++) {
-//              String os = "";
-//              for (int j = 0; j < m.getColumnDimension(); j++) {
-//                  os += m.getEntry(i, j) + " ";
-//              }
-//              System.out.println(os);
-//          }
-//    }
-
-}
-
diff --git a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java
index 80485c6..4d70417 100644
--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java
+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java
@@ -24,6 +24,9 @@
 import org.apache.commons.math.TestUtils;
 import org.apache.commons.math.util.FastMath;
 import org.apache.commons.math.exception.MatrixDimensionMismatchException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.NumberIsTooSmallException;
 
 /**
  * Test cases for the {@link BlockRealMatrix} class.
@@ -416,14 +419,14 @@
         assertClose(m.getColumn(2), testDataCol3, entryTolerance);
         try {
             m.getRow(10);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
         try {
             m.getColumn(-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
     }
@@ -433,8 +436,8 @@
         assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
         try {
             m.getEntry(10, 4);
-            fail ("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail ("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -494,9 +497,17 @@
             if (reference != null) {
                 assertEquals(new BlockRealMatrix(reference), sub);
             } else {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (reference != null) {
                 throw e;
             }
@@ -510,9 +521,17 @@
             if (reference != null) {
                 assertEquals(new BlockRealMatrix(reference), sub);
             } else {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallExceptiono r ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (reference != null) {
                 throw e;
             }
@@ -568,9 +587,17 @@
             if (reference != null) {
                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
             } else {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (reference != null) {
                 throw e;
             }
@@ -587,9 +614,17 @@
             if (reference != null) {
                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
             } else {
-                fail("Expecting MatrixIndexException");
+                fail("Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException");
             }
-        } catch (MatrixIndexException e) {
+        } catch (OutOfRangeException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (NumberIsTooSmallException e) {
+            if (reference != null) {
+                throw e;
+            }
+        } catch (ZeroException e) {
             if (reference != null) {
                 throw e;
             }
@@ -604,14 +639,14 @@
         assertEquals("Row3", mRow3, m.getRowMatrix(3));
         try {
             m.getRowMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -624,8 +659,8 @@
         assertEquals(mRow3, m.getRowMatrix(0));
         try {
             m.setRowMatrix(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -663,14 +698,14 @@
         assertEquals(mColumn3, m.getColumnMatrix(3));
         try {
             m.getColumnMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -683,8 +718,8 @@
         assertEquals(mColumn3, m.getColumnMatrix(1));
         try {
             m.setColumnMatrix(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -722,14 +757,14 @@
         assertEquals(mRow3, m.getRowVector(3));
         try {
             m.getRowVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -742,8 +777,8 @@
         assertEquals(mRow3, m.getRowVector(0));
         try {
             m.setRowVector(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -781,14 +816,14 @@
         assertEquals(mColumn3, m.getColumnVector(3));
         try {
             m.getColumnVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -801,8 +836,8 @@
         assertEquals(mColumn3, m.getColumnVector(1));
         try {
             m.setColumnVector(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -846,14 +881,14 @@
         checkArrays(subRow3[0], m.getRow(3));
         try {
             m.getRow(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRow(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -865,8 +900,8 @@
         checkArrays(subRow3[0], m.getRow(0));
         try {
             m.setRow(-1, subRow3[0]);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -905,14 +940,14 @@
         checkArrays(mColumn3, m.getColumn(3));
         try {
             m.getColumn(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumn(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -925,8 +960,8 @@
         checkArrays(mColumn3, m.getColumn(1));
         try {
             m.setColumn(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
@@ -1019,21 +1054,21 @@
         // dimension overflow
         try {
             m.setSubMatrix(testData,1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         // dimension underflow
         try {
             m.setSubMatrix(testData,-1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         try {
             m.setSubMatrix(testData,1,-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
 
diff --git a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
index 9bdda45..14dd4e7 100644
--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
@@ -24,6 +24,8 @@
 import org.apache.commons.math.fraction.Fraction;
 import org.apache.commons.math.fraction.FractionConversionException;
 import org.apache.commons.math.fraction.FractionField;
+import org.apache.commons.math.exception.NullArgumentException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 
 /**
  * Test cases for the {@link MatrixUtils} class.
@@ -83,8 +85,8 @@
         }
         try {
             MatrixUtils.createRealMatrix(null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -108,40 +110,8 @@
         }
         try {
             MatrixUtils.createFieldMatrix((Fraction[][])null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
-            // expected
-        }
-    }
-
-    @Deprecated
-    public void testCreateBigMatrix() {
-        assertEquals(new BigMatrixImpl(testData),
-                MatrixUtils.createBigMatrix(testData));
-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true),
-                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));
-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false),
-                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));
-        assertEquals(new BigMatrixImpl(bigColMatrix),
-                MatrixUtils.createBigMatrix(bigColMatrix));
-        assertEquals(new BigMatrixImpl(stringColMatrix),
-                MatrixUtils.createBigMatrix(stringColMatrix));
-        try {
-            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            MatrixUtils.createBigMatrix(nullMatrix);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -151,14 +121,14 @@
                      new BlockRealMatrix(rowMatrix));
         try {
             MatrixUtils.createRowRealMatrix(new double[] {});  // empty
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
+            fail("Expecting NotStrictlyPositiveException");
+        } catch (NotStrictlyPositiveException ex) {
             // expected
         }
         try {
             MatrixUtils.createRowRealMatrix(null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -176,30 +146,8 @@
         }
         try {
             MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
-            // expected
-        }
-    }
-
-    @Deprecated
-    public void testCreateRowBigMatrix() {
-        assertEquals(MatrixUtils.createRowBigMatrix(row),
-                new BigMatrixImpl(rowMatrix));
-        assertEquals(MatrixUtils.createRowBigMatrix(bigRow),
-                new BigMatrixImpl(bigRowMatrix));
-        assertEquals(MatrixUtils.createRowBigMatrix(stringRow),
-                new BigMatrixImpl(stringRowMatrix));
-        try {
-            MatrixUtils.createRowBigMatrix(new double[] {});  // empty
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -215,8 +163,8 @@
         }
         try {
             MatrixUtils.createColumnRealMatrix(null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -235,31 +183,8 @@
         }
         try {
             MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
-            // expected
-        }
-    }
-
-    @Deprecated
-    public void testCreateColumnBigMatrix() {
-        assertEquals(MatrixUtils.createColumnBigMatrix(col),
-                new BigMatrixImpl(colMatrix));
-        assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),
-                new BigMatrixImpl(bigColMatrix));
-        assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),
-                new BigMatrixImpl(stringColMatrix));
-
-        try {
-            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null
-            fail("Expecting NullPointerException");
-        } catch (NullPointerException ex) {
+            fail("Expecting NullArgumentException");
+        } catch (NullArgumentException ex) {
             // expected
         }
     }
@@ -370,35 +295,5 @@
         }
         return d;
     }
-
-    /**
-     * Verifies that the matrix is an identity matrix
-     */
-    @Deprecated
-    protected void checkIdentityBigMatrix(BigMatrix m) {
-        for (int i = 0; i < m.getRowDimension(); i++) {
-            for (int j =0; j < m.getColumnDimension(); j++) {
-                if (i == j) {
-                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);
-                } else {
-                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);
-                }
-            }
-        }
-    }
-
-    @Deprecated
-    public void testCreateBigIdentityMatrix() {
-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));
-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));
-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));
-        try {
-            MatrixUtils.createRealIdentityMatrix(0);
-            fail("Expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // expected
-        }
-    }
-
 }
 
diff --git a/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java b/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java
deleted file mode 100644
index 47a63ff..0000000
--- a/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java
+++ /dev/null
@@ -1,1009 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.math.linear;
-
-import junit.framework.TestCase;
-
-import org.apache.commons.math.TestUtils;
-import org.apache.commons.math.util.FastMath;
-import org.apache.commons.math.exception.MatrixDimensionMismatchException;
-
-/**
- * Test cases for the {@link RealMatrixImpl} class.
- *
- * @version $Revision$ $Date$
- */
-@Deprecated
-public final class RealMatrixImplTest extends TestCase {
-
-    // 3 x 3 identity matrix
-    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };
-
-    // Test data for group operations
-    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
-    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};
-    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };
-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},
-       {-1d,0d,-8d} };
-    protected double[] testDataRow1 = {1d,2d,3d};
-    protected double[] testDataCol3 = {3d,3d,8d};
-    protected double[][] testDataInv =
-        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };
-    protected double[] preMultTest = {8,12,33};
-    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};
-    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};
-    protected double[][] testDataPlusInv =
-        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };
-
-    // lu decomposition tests
-    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };
-    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},
-            {0.33333333333333,0d,0.33333333333333} };
-
-    // singular matrices
-    protected double[][] singular = { {2d,3d}, {2d,3d} };
-    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},
-        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd
-    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };
-    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};
-
-    // vectors
-    protected double[] testVector = {1,2,3};
-    protected double[] testVector2 = {1,2,3,4};
-
-    // submatrix accessor tests
-    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},
-            {2, 4, 6, 8}, {4, 5, 6, 7}};
-    // array selections
-    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};
-    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};
-    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};
-    // effective permutations
-    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};
-    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};
-    // contiguous ranges
-    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};
-    protected double[][] subRows23Cols00 = {{2} , {4}};
-    protected double[][] subRows00Cols33 = {{4}};
-    // row matrices
-    protected double[][] subRow0 = {{1,2,3,4}};
-    protected double[][] subRow3 = {{4,5,6,7}};
-    // column matrices
-    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};
-    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};
-
-    // tolerances
-    protected double entryTolerance = 10E-16;
-    protected double normTolerance = 10E-14;
-
-    public RealMatrixImplTest(String name) {
-        super(name);
-    }
-
-    /** test dimensions */
-    public void testDimensions() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);
-        assertEquals("testData row dimension",3,m.getRowDimension());
-        assertEquals("testData column dimension",3,m.getColumnDimension());
-        assertTrue("testData is square",m.isSquare());
-        assertEquals("testData2 row dimension",m2.getRowDimension(),2);
-        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
-        assertTrue("testData2 is not square",!m2.isSquare());
-    }
-
-    /** test copy functions */
-    public void testCopyFunctions() {
-        RealMatrixImpl m1 = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());
-        assertEquals(m2,m1);
-        RealMatrixImpl m3 = new RealMatrixImpl(testData);
-        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);
-        assertEquals(m4,m3);
-    }
-
-    /** test add */
-    public void testAdd() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
-        RealMatrix mPlusMInv = m.add(mInv);
-        double[][] sumEntries = mPlusMInv.getData();
-        for (int row = 0; row < m.getRowDimension(); row++) {
-            for (int col = 0; col < m.getColumnDimension(); col++) {
-                assertEquals("sum entry entry",
-                    testDataPlusInv[row][col],sumEntries[row][col],
-                        entryTolerance);
-            }
-        }
-    }
-
-    /** test add failure */
-    public void testAddFail() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);
-        try {
-            m.add(m2);
-            fail("IllegalArgumentException expected");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test norm */
-    public void testNorm() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);
-        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
-        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
-    }
-
-    /** test Frobenius norm */
-    public void testFrobeniusNorm() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);
-        assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);
-        assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);
-    }
-
-     /** test m-n = m + -n */
-    public void testPlusMinus() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);
-        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),
-            m2.scalarMultiply(-1d).add(m),entryTolerance);
-        try {
-            m.subtract(new RealMatrixImpl(testData2));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test multiply */
-     public void testMultiply() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
-        RealMatrixImpl identity = new RealMatrixImpl(id);
-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);
-        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),
-            identity,entryTolerance);
-        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),
-            identity,entryTolerance);
-        TestUtils.assertEquals("identity multiply",m.multiply(identity),
-            m,entryTolerance);
-        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),
-            mInv,entryTolerance);
-        TestUtils.assertEquals("identity multiply",m2.multiply(identity),
-            m2,entryTolerance);
-        try {
-            m.multiply(new RealMatrixImpl(bigSingular));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    //Additional Test for RealMatrixImplTest.testMultiply
-
-    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};
-    private double[][] d4 = new double[][] {{1},{2},{3},{4}};
-    private double[][] d5 = new double[][] {{30},{70}};
-
-    public void testMultiply2() {
-       RealMatrix m3 = new RealMatrixImpl(d3);
-       RealMatrix m4 = new RealMatrixImpl(d4);
-       RealMatrix m5 = new RealMatrixImpl(d5);
-       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);
-   }
-
-    /** test trace */
-    public void testTrace() {
-        RealMatrix m = new RealMatrixImpl(id);
-        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
-        m = new RealMatrixImpl(testData2);
-        try {
-            m.getTrace();
-            fail("Expecting NonSquareMatrixException");
-        } catch (NonSquareMatrixException ex) {
-            // ignored
-        }
-    }
-
-    /** test sclarAdd */
-    public void testScalarAdd() {
-        RealMatrix m = new RealMatrixImpl(testData);
-        TestUtils.assertEquals("scalar add",new RealMatrixImpl(testDataPlus2),
-            m.scalarAdd(2d),entryTolerance);
-    }
-
-    /** test operate */
-    public void testOperate() {
-        RealMatrix m = new RealMatrixImpl(id);
-        TestUtils.assertEquals("identity operate", testVector,
-                    m.operate(testVector), entryTolerance);
-        TestUtils.assertEquals("identity operate", testVector,
-                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);
-        m = new RealMatrixImpl(bigSingular);
-        try {
-            m.operate(testVector);
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    /** test issue MATH-209 */
-    public void testMath209() {
-        RealMatrix a = new RealMatrixImpl(new double[][] {
-                { 1, 2 }, { 3, 4 }, { 5, 6 }
-        }, false);
-        double[] b = a.operate(new double[] { 1, 1 });
-        assertEquals(a.getRowDimension(), b.length);
-        assertEquals( 3.0, b[0], 1.0e-12);
-        assertEquals( 7.0, b[1], 1.0e-12);
-        assertEquals(11.0, b[2], 1.0e-12);
-    }
-
-    /** test transpose */
-    public void testTranspose() {
-        RealMatrix m = new RealMatrixImpl(testData);
-        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();
-        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();
-        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);
-        m = new RealMatrixImpl(testData2);
-        RealMatrix mt = new RealMatrixImpl(testData2T);
-        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);
-    }
-
-    /** test preMultiply by vector */
-    public void testPremultiplyVector() {
-        RealMatrix m = new RealMatrixImpl(testData);
-        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),
-                    preMultTest, normTolerance);
-        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),
-                    preMultTest, normTolerance);
-        m = new RealMatrixImpl(bigSingular);
-        try {
-            m.preMultiply(testVector);
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    public void testPremultiply() {
-        RealMatrix m3 = new RealMatrixImpl(d3);
-        RealMatrix m4 = new RealMatrixImpl(d4);
-        RealMatrix m5 = new RealMatrixImpl(d5);
-        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);
-
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
-        RealMatrixImpl identity = new RealMatrixImpl(id);
-        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),
-                identity,entryTolerance);
-        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),
-                identity,entryTolerance);
-        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),
-                m,entryTolerance);
-        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),
-                mInv,entryTolerance);
-        try {
-            m.preMultiply(new RealMatrixImpl(bigSingular));
-            fail("Expecting illegalArgumentException");
-        } catch (IllegalArgumentException ex) {
-            // ignored
-        }
-    }
-
-    public void testGetVectors() {
-        RealMatrix m = new RealMatrixImpl(testData);
-        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);
-        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);
-        try {
-            m.getRow(10);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // ignored
-        }
-        try {
-            m.getColumn(-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // ignored
-        }
-    }
-
-    public void testGetEntry() {
-        RealMatrix m = new RealMatrixImpl(testData);
-        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
-        try {
-            m.getEntry(10, 4);
-            fail ("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    /** test examples in user guide */
-    public void testExamples() {
-        // Create a real matrix with two rows and three columns
-        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
-        RealMatrix m = new RealMatrixImpl(matrixData);
-        // One more with three rows, two columns
-        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
-        RealMatrix n = new RealMatrixImpl(matrixData2);
-        // Now multiply m by n
-        RealMatrix p = m.multiply(n);
-        assertEquals(2, p.getRowDimension());
-        assertEquals(2, p.getColumnDimension());
-        // Invert p
-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
-        assertEquals(2, pInverse.getRowDimension());
-        assertEquals(2, pInverse.getColumnDimension());
-
-        // Solve example
-        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};
-        RealMatrix coefficients = new RealMatrixImpl(coefficientsData);
-        double[] constants = {1, -2, 1};
-        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);
-        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
-        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);
-
-    }
-
-    // test submatrix accessors
-    public void testGetSubMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);
-        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);
-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);
-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);
-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);
-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);
-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);
-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);
-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);
-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
-        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);
-        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);
-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
-        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);
-        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);
-    }
-
-    private void checkGetSubMatrix(RealMatrix m, double[][] reference,
-                                   int startRow, int endRow, int startColumn, int endColumn,
-                                   boolean mustFail) {
-        try {
-            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);
-            assertEquals(new RealMatrixImpl(reference), sub);
-            if (mustFail) {
-                fail("Expecting MatrixIndexException");
-            }
-        } catch (MatrixIndexException e) {
-            if (!mustFail) {
-                throw e;
-            }
-        }
-    }
-
-    private void checkGetSubMatrix(RealMatrix m, double[][] reference,
-                                   int[] selectedRows, int[] selectedColumns,
-                                   boolean mustFail) {
-        try {
-            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);
-            assertEquals(new RealMatrixImpl(reference), sub);
-            if (mustFail) {
-                fail("Expecting MatrixIndexException");
-            }
-        } catch (MatrixIndexException e) {
-            if (!mustFail) {
-                throw e;
-            }
-        }
-    }
-
-    public void testCopySubMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);
-        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);
-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);
-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);
-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);
-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);
-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);
-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);
-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);
-
-        checkCopy(m, null,  1, 0, 2, 4, true);
-        checkCopy(m, null, -1, 1, 2, 2, true);
-        checkCopy(m, null,  1, 0, 2, 2, true);
-        checkCopy(m, null,  1, 0, 2, 4, true);
-        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);
-        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);
-    }
-
-    private void checkCopy(RealMatrix m, double[][] reference,
-                           int startRow, int endRow, int startColumn, int endColumn,
-                           boolean mustFail) {
-        try {
-            double[][] sub = (reference == null) ?
-                             new double[1][1] :
-                             new double[reference.length][reference[0].length];
-            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);
-            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));
-            if (mustFail) {
-                fail("Expecting MatrixIndexException");
-            }
-        } catch (MatrixIndexException e) {
-            if (!mustFail) {
-                throw e;
-            }
-        }
-    }
-
-    private void checkCopy(RealMatrix m, double[][] reference,
-                           int[] selectedRows, int[] selectedColumns,
-                           boolean mustFail) {
-        try {
-            double[][] sub = (reference == null) ?
-                    new double[1][1] :
-                    new double[reference.length][reference[0].length];
-            m.copySubMatrix(selectedRows, selectedColumns, sub);
-            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));
-            if (mustFail) {
-                fail("Expecting MatrixIndexException");
-            }
-        } catch (MatrixIndexException e) {
-            if (!mustFail) {
-                throw e;
-            }
-        }
-    }
-
-    public void testGetRowMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealMatrix mRow0 = new RealMatrixImpl(subRow0);
-        RealMatrix mRow3 = new RealMatrixImpl(subRow3);
-        assertEquals("Row0", mRow0,
-                m.getRowMatrix(0));
-        assertEquals("Row3", mRow3,
-                m.getRowMatrix(3));
-        try {
-            m.getRowMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getRowMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetRowMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealMatrix mRow3 = new RealMatrixImpl(subRow3);
-        assertNotSame(mRow3, m.getRowMatrix(0));
-        m.setRowMatrix(0, mRow3);
-        assertEquals(mRow3, m.getRowMatrix(0));
-        try {
-            m.setRowMatrix(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setRowMatrix(0, m);
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    public void testGetColumnMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);
-        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);
-        assertEquals("Column1", mColumn1,
-                m.getColumnMatrix(1));
-        assertEquals("Column3", mColumn3,
-                m.getColumnMatrix(3));
-        try {
-            m.getColumnMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getColumnMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetColumnMatrix() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);
-        assertNotSame(mColumn3, m.getColumnMatrix(1));
-        m.setColumnMatrix(1, mColumn3);
-        assertEquals(mColumn3, m.getColumnMatrix(1));
-        try {
-            m.setColumnMatrix(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setColumnMatrix(0, m);
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    public void testGetRowVector() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealVector mRow0 = new ArrayRealVector(subRow0[0]);
-        RealVector mRow3 = new ArrayRealVector(subRow3[0]);
-        assertEquals("Row0", mRow0, m.getRowVector(0));
-        assertEquals("Row3", mRow3, m.getRowVector(3));
-        try {
-            m.getRowVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getRowVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetRowVector() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealVector mRow3 = new ArrayRealVector(subRow3[0]);
-        assertNotSame(mRow3, m.getRowMatrix(0));
-        m.setRowVector(0, mRow3);
-        assertEquals(mRow3, m.getRowVector(0));
-        try {
-            m.setRowVector(-1, mRow3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setRowVector(0, new ArrayRealVector(5));
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    public void testGetColumnVector() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealVector mColumn1 = columnToVector(subColumn1);
-        RealVector mColumn3 = columnToVector(subColumn3);
-        assertEquals("Column1", mColumn1, m.getColumnVector(1));
-        assertEquals("Column3", mColumn3, m.getColumnVector(3));
-        try {
-            m.getColumnVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getColumnVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetColumnVector() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        RealVector mColumn3 = columnToVector(subColumn3);
-        assertNotSame(mColumn3, m.getColumnVector(1));
-        m.setColumnVector(1, mColumn3);
-        assertEquals(mColumn3, m.getColumnVector(1));
-        try {
-            m.setColumnVector(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setColumnVector(0, new ArrayRealVector(5));
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    private RealVector columnToVector(double[][] column) {
-        double[] data = new double[column.length];
-        for (int i = 0; i < data.length; ++i) {
-            data[i] = column[i][0];
-        }
-        return new ArrayRealVector(data, false);
-    }
-
-    public void testGetRow() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        checkArrays(subRow0[0], m.getRow(0));
-        checkArrays(subRow3[0], m.getRow(3));
-        try {
-            m.getRow(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getRow(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetRow() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        assertTrue(subRow3[0][0] != m.getRow(0)[0]);
-        m.setRow(0, subRow3[0]);
-        checkArrays(subRow3[0], m.getRow(0));
-        try {
-            m.setRow(-1, subRow3[0]);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setRow(0, new double[5]);
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    public void testGetColumn() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        double[] mColumn1 = columnToArray(subColumn1);
-        double[] mColumn3 = columnToArray(subColumn3);
-        checkArrays(mColumn1, m.getColumn(1));
-        checkArrays(mColumn3, m.getColumn(3));
-        try {
-            m.getColumn(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.getColumn(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-    }
-
-    public void testSetColumn() {
-        RealMatrix m = new RealMatrixImpl(subTestData);
-        double[] mColumn3 = columnToArray(subColumn3);
-        assertTrue(mColumn3[0] != m.getColumn(1)[0]);
-        m.setColumn(1, mColumn3);
-        checkArrays(mColumn3, m.getColumn(1));
-        try {
-            m.setColumn(-1, mColumn3);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
-            // expected
-        }
-        try {
-            m.setColumn(0, new double[5]);
-            fail("Expecting MatrixDimensionMismatchException");
-        } catch (MatrixDimensionMismatchException ex) {
-            // expected
-        }
-    }
-
-    private double[] columnToArray(double[][] column) {
-        double[] data = new double[column.length];
-        for (int i = 0; i < data.length; ++i) {
-            data[i] = column[i][0];
-        }
-        return data;
-    }
-
-    private void checkArrays(double[] expected, double[] actual) {
-        assertEquals(expected.length, actual.length);
-        for (int i = 0; i < expected.length; ++i) {
-            assertEquals(expected[i], actual[i]);
-        }
-    }
-
-    public void testEqualsAndHashCode() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        RealMatrixImpl m1 = (RealMatrixImpl) m.copy();
-        RealMatrixImpl mt = (RealMatrixImpl) m.transpose();
-        assertTrue(m.hashCode() != mt.hashCode());
-        assertEquals(m.hashCode(), m1.hashCode());
-        assertEquals(m, m);
-        assertEquals(m, m1);
-        assertFalse(m.equals(null));
-        assertFalse(m.equals(mt));
-        assertFalse(m.equals(new RealMatrixImpl(bigSingular)));
-    }
-
-    public void testToString() {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
-                m.toString());
-        m = new RealMatrixImpl();
-        assertEquals("RealMatrixImpl{}",
-                m.toString());
-    }
-
-    public void testSetSubMatrix() throws Exception {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        m.setSubMatrix(detData2,1,1);
-        RealMatrix expected = MatrixUtils.createRealMatrix
-            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});
-        assertEquals(expected, m);
-
-        m.setSubMatrix(detData2,0,0);
-        expected = MatrixUtils.createRealMatrix
-            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});
-        assertEquals(expected, m);
-
-        m.setSubMatrix(testDataPlus2,0,0);
-        expected = MatrixUtils.createRealMatrix
-            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});
-        assertEquals(expected, m);
-
-        // dimension overflow
-        try {
-            m.setSubMatrix(testData,1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
-            // expected
-        }
-        // dimension underflow
-        try {
-            m.setSubMatrix(testData,-1,1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
-            // expected
-        }
-        try {
-            m.setSubMatrix(testData,1,-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
-            // expected
-        }
-
-        // null
-        try {
-            m.setSubMatrix(null,1,1);
-            fail("expecting NullPointerException");
-        } catch (NullPointerException e) {
-            // expected
-        }
-        RealMatrixImpl m2 = new RealMatrixImpl();
-        try {
-            m2.setSubMatrix(testData,0,1);
-            fail("expecting IllegalStateException");
-        } catch (IllegalStateException e) {
-            // expected
-        }
-        try {
-            m2.setSubMatrix(testData,1,0);
-            fail("expecting IllegalStateException");
-        } catch (IllegalStateException e) {
-            // expected
-        }
-
-        // ragged
-        try {
-            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        // empty
-        try {
-            m.setSubMatrix(new double[][] {{}}, 0, 0);
-            fail("expecting IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-    }
-
-    public void testWalk() {
-        int rows    = 150;
-        int columns = 75;
-
-        RealMatrix m = new RealMatrixImpl(rows, columns);
-        m.walkInRowOrder(new SetVisitor());
-        GetVisitor getVisitor = new GetVisitor();
-        m.walkInOptimizedOrder(getVisitor);
-        assertEquals(rows * columns, getVisitor.getCount());
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);
-        getVisitor = new GetVisitor();
-        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);
-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
-        for (int i = 0; i < rows; ++i) {
-            assertEquals(0.0, m.getEntry(i, 0), 0);
-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);
-        }
-        for (int j = 0; j < columns; ++j) {
-            assertEquals(0.0, m.getEntry(0, j), 0);
-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);
-        }
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInColumnOrder(new SetVisitor());
-        getVisitor = new GetVisitor();
-        m.walkInOptimizedOrder(getVisitor);
-        assertEquals(rows * columns, getVisitor.getCount());
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);
-        getVisitor = new GetVisitor();
-        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);
-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
-        for (int i = 0; i < rows; ++i) {
-            assertEquals(0.0, m.getEntry(i, 0), 0);
-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);
-        }
-        for (int j = 0; j < columns; ++j) {
-            assertEquals(0.0, m.getEntry(0, j), 0);
-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);
-        }
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInOptimizedOrder(new SetVisitor());
-        getVisitor = new GetVisitor();
-        m.walkInRowOrder(getVisitor);
-        assertEquals(rows * columns, getVisitor.getCount());
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);
-        getVisitor = new GetVisitor();
-        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);
-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
-        for (int i = 0; i < rows; ++i) {
-            assertEquals(0.0, m.getEntry(i, 0), 0);
-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);
-        }
-        for (int j = 0; j < columns; ++j) {
-            assertEquals(0.0, m.getEntry(0, j), 0);
-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);
-        }
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInOptimizedOrder(new SetVisitor());
-        getVisitor = new GetVisitor();
-        m.walkInColumnOrder(getVisitor);
-        assertEquals(rows * columns, getVisitor.getCount());
-
-        m = new RealMatrixImpl(rows, columns);
-        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);
-        getVisitor = new GetVisitor();
-        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);
-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
-        for (int i = 0; i < rows; ++i) {
-            assertEquals(0.0, m.getEntry(i, 0), 0);
-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);
-        }
-        for (int j = 0; j < columns; ++j) {
-            assertEquals(0.0, m.getEntry(0, j), 0);
-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);
-        }
-
-    }
-
-    public void testSerial()  {
-        RealMatrixImpl m = new RealMatrixImpl(testData);
-        assertEquals(m,TestUtils.serializeAndRecover(m));
-    }
-
-
-    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {
-        @Override
-        public double visit(int i, int j, double value) {
-            return i + j / 1024.0;
-        }
-    }
-
-    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {
-        private int count = 0;
-        @Override
-        public void visit(int i, int j, double value) {
-            ++count;
-            assertEquals(i + j / 1024.0, value, 0.0);
-        }
-        public int getCount() {
-            return count;
-        }
-    }
-
-    //--------------- -----------------Protected methods
-
-    /** extracts the l  and u matrices from compact lu representation */
-    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData)  {
-        if (!lu.isSquare() ||
-            lowerData.length != lowerData[0].length ||
-            upperData.length != upperData[0].length ||
-            lowerData.length != upperData.length ||
-            lowerData.length != lu.getRowDimension()) {
-            throw new IllegalArgumentException("incorrect dimensions");
-        }
-        int n = lu.getRowDimension();
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < n; j++) {
-                if (j < i) {
-                    lowerData[i][j] = lu.getEntry(i, j);
-                    upperData[i][j] = 0d;
-                } else if (i == j) {
-                    lowerData[i][j] = 1d;
-                    upperData[i][j] = lu.getEntry(i, j);
-                } else {
-                    lowerData[i][j] = 0d;
-                    upperData[i][j] = lu.getEntry(i, j);
-                }
-            }
-        }
-    }
-
-    /** Returns the result of applying the given row permutation to the matrix */
-    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {
-        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {
-            throw new IllegalArgumentException("dimension mismatch");
-        }
-        int n = matrix.getRowDimension();
-        int m = matrix.getColumnDimension();
-        double out[][] = new double[m][n];
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                out[i][j] = matrix.getEntry(permutation[i], j);
-            }
-        }
-        return new RealMatrixImpl(out);
-    }
-
-//    /** Useful for debugging */
-//    private void dumpMatrix(RealMatrix m) {
-//          for (int i = 0; i < m.getRowDimension(); i++) {
-//              String os = "";
-//              for (int j = 0; j < m.getColumnDimension(); j++) {
-//                  os += m.getEntry(i, j) + " ";
-//              }
-//              System.out.println(os);
-//          }
-//    }
-}
-
diff --git a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java
index f35e486..c900c49 100644
--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java
+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java
@@ -19,6 +19,9 @@
 import junit.framework.TestCase;
 
 import org.apache.commons.math.TestUtils;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.ZeroException;
+import org.apache.commons.math.exception.NumberIsTooSmallException;
 
 /**
  * Test cases for the {@link OpenMapRealMatrix} class.
@@ -324,14 +327,14 @@
         assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);
         try {
             m.getRow(10);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
         try {
             m.getColumn(-1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // ignored
         }
     }
@@ -341,8 +344,8 @@
         assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);
         try {
             m.getEntry(10, 4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -408,38 +411,38 @@
 
         try {
             m.getSubMatrix(1, 0, 2, 4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting NumberIsTooSmallException");
+        } catch (NumberIsTooSmallException ex) {
             // expected
         }
         try {
             m.getSubMatrix(-1, 1, 2, 2);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getSubMatrix(1, 0, 2, 2);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting NumberIsTooSmallException");
+        } catch (NumberIsTooSmallException ex) {
             // expected
         }
         try {
             m.getSubMatrix(1, 0, 2, 4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting NumberIsTooSmallException");
+        } catch (NumberIsTooSmallException ex) {
             // expected
         }
         try {
             m.getSubMatrix(new int[] {}, new int[] { 0 });
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting ZeroException");
+        } catch (ZeroException ex) {
             // expected
         }
         try {
             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -452,14 +455,14 @@
         assertEquals("Row3", mRow3, m.getRowMatrix(3));
         try {
             m.getRowMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -472,14 +475,14 @@
         assertEquals("Column3", mColumn3, m.getColumnMatrix(3));
         try {
             m.getColumnMatrix(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnMatrix(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -492,14 +495,14 @@
         assertEquals("Row3", mRow3, m.getRowVector(3));
         try {
             m.getRowVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getRowVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -512,14 +515,14 @@
         assertEquals("Column3", mColumn3, m.getColumnVector(3));
         try {
             m.getColumnVector(-1);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
         try {
             m.getColumnVector(4);
-            fail("Expecting MatrixIndexException");
-        } catch (MatrixIndexException ex) {
+            fail("Expecting OutOfRangeException");
+        } catch (OutOfRangeException ex) {
             // expected
         }
     }
@@ -582,21 +585,21 @@
         // dimension overflow
         try {
             m.setSubMatrix(testData, 1, 1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         // dimension underflow
         try {
             m.setSubMatrix(testData, -1, 1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
         try {
             m.setSubMatrix(testData, 1, -1);
-            fail("expecting MatrixIndexException");
-        } catch (MatrixIndexException e) {
+            fail("expecting OutOfRangeException");
+        } catch (OutOfRangeException e) {
             // expected
         }
 
diff --git a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java
index 478bd5a..04a75a1 100644
--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java
+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java
@@ -25,6 +25,7 @@
 import org.apache.commons.math.TestUtils;
 import org.apache.commons.math.analysis.UnivariateRealFunction;
 import org.apache.commons.math.util.FastMath;
+import org.apache.commons.math.exception.OutOfRangeException;
 
 /**
  * Test cases for the {@link OpenMapRealVector} class.
@@ -636,8 +637,8 @@
         assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));
         try {
             v4.getSubVector(3, 7);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -646,8 +647,8 @@
         assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));
         try {
             v_set1.setEntry(3, 11.0);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -657,8 +658,8 @@
         assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));
         try {
             v_set2.setSubVector(7, v1);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -668,8 +669,8 @@
 
         try {
             v_set3.getEntry(23);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
@@ -679,8 +680,8 @@
         assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));
         try {
             v_set4.setSubVector(7, v2_t);
-            fail("MatrixIndexException expected");
-        } catch (MatrixIndexException ex) {
+            fail("OutOfRangeException expected");
+        } catch (OutOfRangeException ex) {
             // expected behavior
         }
 
