package root.analysis.groum.vector;

import root.analysis.groum.entity.AbstractNode;
import root.analysis.groum.entity.IntraGroum;

import java.util.*;
import java.util.stream.Collectors;

public class Exaser {

    LinkedHashMap<Feature, Integer> featureCounts;

    public Exaser() {
        this.featureCounts = new LinkedHashMap<>();
    }

    public List<Integer> getVector() {
        List<Integer> vector = new ArrayList<>();
        for (Map.Entry<Feature, Integer> entries :featureCounts.entrySet()) {
            vector.add(entries.getValue());
        }
        return vector;
    }

    /**
     * g = f + e, where g is a new fragment which build from f by extending f with an edge e.
     * e = (u, v):
     *            1. u is a new node: new features are created from the 1-path u, 2-path u-v, the new (0,1)-node at u.
     *                                The (x,y)-node at v is replaced by (x+1,y)-node.
     *                                All new n-paths are generated by adding u to the first of all (n-1)-paths starting from v(deep search within g from v to the depth of n-2).
     *            2. v is a new node: similar to the above, but n-paths are generated from (n-1)-paths ending at u.
     *                                (x,y)-node at v is replaced by a new (x,y+1)-node.(backward dfs)
     *            3. no new node: The (x,y)-node at u is replaced by (x+1,y)-node. (x,y)-node at v is replaced by a new (x,y+1)-node.
     *                            new n-paths are generated by combination of any i-path ending at u(backward dfs) and a j-path starting from v(forward dfs) for all i+j=n.
     * 复杂度达到和路径长度N有关，假设N中节点的最大度为d，复杂度为O(m.N.d^(N-2)), m为边的数量…反正不能比一整个函数就是了
     * 该方法应该在tail<-head边加进g之前执行！！！
     * 目前的构图方式决定了 head一定在g里！
     **/
    public void incrVector(IntraGroum g, AbstractNode head, AbstractNode tail) {
        List<AbstractNode> nodes = g.getNodes();
        //case 3
        if (nodes.contains(head) && nodes.contains(tail)) {
            //replace node
            String newComponent = String.valueOf(head.getOutgoingEdges().size() + 1);
            replaceFeature(head, newComponent, 2);
            newComponent = String.valueOf(tail.getIncomingEdges().size() + 1);
            replaceFeature(tail, newComponent, 1);
            //add n-paths
            List<Feature> headEndPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.endNodeIs(head.getLabel())).collect(Collectors.toList());
            List<List<Object>> iPaths = headEndPaths.stream().map(Feature::getLabelComponents)
                    .collect(Collectors.toList());
            List<Feature> tailStartPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.startNodeIs(tail.getLabel())).collect(Collectors.toList());
            List<List<Object>> jPaths = tailStartPaths.stream().map(Feature::getLabelComponents)
                    .collect(Collectors.toList());
            iPaths.forEach(iPath -> {
                jPaths.forEach(jPath -> {
                    addFeature(iPath, jPath);
                });
            });//combine
        }
        //case 2
        if (!nodes.contains(tail)) {
            //replace node
            String newComponent = String.valueOf(head.getOutgoingEdges().size() + 1);
            replaceFeature(head, newComponent, 2);
            //new node
            addFeature(tail, false);
            //new 1-path head
            addFeature(tail);
            //new 2-path head-tail
            addFeature(head, tail);
            //add n-paths from (n-1)-path
            List<Feature> headEndPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.endNodeIs(head.getLabel())).collect(Collectors.toList());
            List<List<Object>> path2Add = headEndPaths.stream().map(Feature::getLabelComponents)
                    .collect(Collectors.toList());
            path2Add.forEach(p -> addFeature(tail, false, p));
        }
        //case 1 目前的构图方式中不会有？
        if (!nodes.contains(head)) {
            //replace node
            String newComponent = String.valueOf(tail.getIncomingEdges().size() + 1);
            replaceFeature(tail, newComponent, 1);
            //new node
            addFeature(head, false);
            //new 1-path head
            addFeature(head);
            //new 2-path head-tail
            addFeature(head, tail);
            //add n-paths from (n-1)-path
            List<Feature> tailStartPaths = featureCounts.keySet().stream().filter(feature ->
                    feature.startNodeIs(tail.getLabel())).collect(Collectors.toList());
            List<List<Object>> path2Add = tailStartPaths.stream().map(Feature::getLabelComponents)
                    .collect(Collectors.toList());
            path2Add.forEach(p -> addFeature(head, true, p));
        }
    }

    public void newNode(AbstractNode node) {
        //new node
        Feature feature = new Feature(node, node.getIncomingEdges().size(), node.getOutgoingEdges().size());
        featureCounts.put(feature, 1);
        //1-path
        addFeature(node);
    }

    private void addFeature(List<Object> iPath, List<Object> jPath) {//combine n-path
        AbstractNode root = (AbstractNode) iPath.remove(0);
        Feature feature = new Feature(root);
        iPath.addAll(jPath);
        feature.addComponents(iPath);
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode node, boolean isStart, List<Object> components) {//n-paths,n>2
        Feature feature;
        if (isStart) {
            feature = new Feature(node);
            feature.addComponents(components);
        } else {
            AbstractNode root = (AbstractNode) components.remove(0);
            feature = new Feature(root);
            components.add(node);
            feature.addComponents(components);
        }
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode... nodes) {//path
        Feature feature = new Feature(nodes[0]);
        for (int i = 1; i < nodes.length; i ++) {
            feature.addComponent(nodes[i].getLabel());
        }
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature) ;
        }
        featureCounts.put(feature, count);
    }

    private void addFeature(AbstractNode node, boolean isIn4Node) {//node
        int incomingSize = isIn4Node ? node.getIncomingEdges().size() + 1 : 0;
        int outgoingSize = isIn4Node ? 0 : node.getOutgoingEdges().size() + 1;
        Feature feature = new Feature(node, incomingSize, outgoingSize);
        int count = 1;
        if (featureCounts.containsKey(feature)) {
            count += featureCounts.get(feature);
        }
        featureCounts.put(feature, count);
    }

    private void replaceFeature(AbstractNode node, String newComponent, int idx) {
        Feature feature = new Feature(node, node.getIncomingEdges().size(), node.getOutgoingEdges().size());
        Integer oldCount = featureCounts.get(feature);
        if (oldCount == null) {
            oldCount = 1;
        }
        featureCounts.remove(feature);
        feature.replaceLabel(newComponent, idx);
        featureCounts.put(feature, oldCount);
    }
}
