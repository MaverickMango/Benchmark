diff -r -u original/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java
--- original/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java	2023-06-13 15:31:37.847073759 +0800
+++ buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java	2023-06-12 11:40:17.535130648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 Google Inc.
+ * Copyright 2009 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@
 import com.google.javascript.jscomp.ControlFlowGraph.Branch;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.jscomp.graph.GraphNode;
+import com.google.javascript.jscomp.graph.LatticeElement;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -52,7 +53,7 @@
     this.jsScope = jsScope;
     this.escaped = Sets.newHashSet();
 
-    // TODO(user): May be comute it somewhere else and re-use the escape
+    // TODO(user): Maybe compute it somewhere else and re-use the escape
     // local set here.
     computeEscaped(jsScope, escaped, compiler);
   }
@@ -175,10 +176,10 @@
           // for(x in y) {...}
           Node lhs = n.getFirstChild();
           Node rhs = lhs.getNext();
-          if (NodeUtil.isVar(lhs)) {
+          if (lhs.isVar()) {
             lhs = lhs.getLastChild(); // for(var x in y) {...}
           }
-          if (NodeUtil.isName(lhs) && !conditional) {
+          if (lhs.isName() && !conditional) {
             removeFromUseIfLocal(lhs.getString(), output);
           }
           computeMayUse(rhs, cfgNode, output, conditional);
@@ -210,14 +211,14 @@
         return;
 
       default:
-        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
+        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
           Node name = n.getFirstChild();
           if (!conditional) {
             removeFromUseIfLocal(name.getString(), output);
           }
 
           // In case of a += "Hello". There is a read of a.
-          if (!NodeUtil.isAssign(n)) {
+          if (!n.isAssign()) {
             addToUseIfLocal(name.getString(), cfgNode, output);
           }
 
diff -r -u original/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java buggy/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
--- original/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java	2023-06-13 15:31:37.847073759 +0800
+++ buggy/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java	2023-06-12 11:40:17.535130648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 Google Inc.
+ * Copyright 2009 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,9 +25,14 @@
 public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {
 
   public static final String EXTERN_FUNCTIONS = "" +
+      "var print;\n" +
       "/** @nosideeffects */ function noSFX() {} \n" +
       "                      function hasSFX() {} \n";
 
+  public FlowSensitiveInlineVariablesTest() {
+    enableNormalize(true);
+  }
+
   @Override
   public int getNumRepetitions() {
     // Test repeatedly inline.
@@ -60,6 +65,13 @@
     inline("var x = 1; x = x + 1", "var x; x = 1 + 1");
   }
 
+  public void testSimpleForIn() {
+    inline("var a,b,x = a in b; x",
+           "var a,b,x; a in b");
+    noInline("var a, b; var x = a in b; print(1); x");
+    noInline("var a,b,x = a in b; delete a[b]; x");
+  }
+
   public void testExported() {
     noInline("var _x = 1; print(_x)");
   }
@@ -103,8 +115,10 @@
   }
 
   public void testMultiDefinitionsInSameCfgNode() {
-    noInline("var x; x = 1 || x = 2; print(x)");
-    noInline("var x; x = 1 && x = 2; print(x)");
+    noInline("var x; (x = 1) || (x = 2); print(x)");
+    noInline("var x; x = (1 || (x = 2)); print(x)");
+    noInline("var x;(x = 1) && (x = 2); print(x)");
+    noInline("var x;x = (1 && (x = 2)); print(x)");
     noInline("var x; x = 1 , x = 2; print(x)");
   }
 
@@ -190,14 +204,20 @@
 
   public void testInlineExpression8() {
     // The same variable inlined twice.
-    inline("var x = a + b; print(x);      x = a - b; print(x)",
-           "var x;         print(a + b);             print(a - b)");
+    inline(
+        "var a,b;" +
+        "var x = a + b; print(x);      x = a - b; print(x)",
+        "var a,b;" +
+        "var x;         print(a + b);             print(a - b)");
   }
 
   public void testInlineExpression9() {
     // Check for actual control flow sensitivity.
-    inline("var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)",
-           "var x; if (g) {           print(a + b)}             print(a - b)");
+    inline(
+        "var a,b;" +
+        "var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)",
+        "var a,b;" +
+        "var x; if (g) {           print(a + b)}             print(a - b)");
   }
 
   public void testInlineExpression10() {
@@ -307,13 +327,19 @@
   }
 
   public void testRemoveWithLabels() {
-    inline("var x = 1; L: x = 2; print(x)", "var x = 1; print(2)");
-    inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; print(2)");
-    inline("var x = 1; L: M: N: x = 2; print(x)", "var x = 1; print(2)");
+    inline("var x = 1; L: x = 2; print(x)", "var x = 1; L:{} print(2)");
+    inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; L:M:{} print(2)");
+    inline("var x = 1; L: M: N: x = 2; print(x)",
+           "var x = 1; L:M:N:{} print(2)");
   }
 
   public void testInlineAcrossSideEffect1() {
-    inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))");
+    // This can't be inlined because print() has side-effects and might change
+    // the definition of noSFX.
+    //
+    // noSFX must be both const and pure in order to inline it.
+    noInline("var y; var x = noSFX(y); print(x)");
+    //inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))");
   }
 
   public void testInlineAcrossSideEffect2() {
@@ -343,8 +369,14 @@
   }
 
   public void testCanInlineAcrossNoSideEffect() {
-    inline("var y; var x = noSFX(Y), z = noSFX(); noSFX(); noSFX(), print(x)",
-           "var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(Y))");
+    // This can't be inlined because print() has side-effects and might change
+    // the definition of noSFX. We should be able to mark noSFX as const
+    // in some way.
+    noInline(
+        "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)");
+    //inline(
+    //    "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)",
+    //    "var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))");
   }
 
   public void testDependOnOuterScopeVariables() {
@@ -363,7 +395,7 @@
     inline("var x = 1; x = (x = x + 1)", "var x; x = (x = 1 + 1)");
 
     noInline("var x = 1; x = (x = (x = 10) + x)");
-    noInline("var x = 1; x = (f(x) = (x = 10) + x);");
+    noInline("var x = 1; x = (f(x) + (x = 10) + x);");
     noInline("var x = 1; x=-1,foo(x)");
     noInline("var x = 1; x-=1,foo(x)");
   }
@@ -372,11 +404,100 @@
     testSame("function _func(x) { print(x) }");
     testSame("function _func(x,y) { if(y) { x = 1 }; print(x) }");
 
-    test("function(x, y) { x = 1; print(x) }",
-         "function(x, y) { print(1) }");
+    test("function f(x, y) { x = 1; print(x) }",
+         "function f(x, y) { print(1) }");
+
+    test("function f(x, y) { if (y) { x = 1; print(x) }}",
+         "function f(x, y) { if (y) { print(1) }}");
+  }
 
-    test("function(x, y) { if (y) { x = 1; print(x) }}",
-         "function(x, y) { if (y) { print(1) }}");
+  public void testInvalidInlineArguments1() {
+    testSame("function f(x, y) { x = 1; arguments[0] = 2; print(x) }");
+    testSame("function f(x, y) { x = 1; var z = arguments;" +
+        "z[0] = 2; z[1] = 3; print(x)}");
+    testSame("function g(a){a[0]=2} function f(x){x=1;g(arguments);print(x)}");
+  }
+
+  public void testInvalidInlineArguments2() {
+    testSame("function f(c) {var f = c; arguments[0] = this;" +
+             "f.apply(this, arguments); return this;}");
+  }
+
+  public void testForIn() {
+    noInline("var x; var y = {}; for(x in y){}");
+    noInline("var x; var y = {}; var z; for(x in z = y){print(z)}");
+    noInline("var x; var y = {}; var z; for(x in y){print(z)}");
+
+  }
+
+  public void testNotOkToSkipCheckPathBetweenNodes() {
+    noInline("var x; for(x = 1; foo(x);) {}");
+    noInline("var x; for(; x = 1;foo(x)) {}");
+  }
+
+  public void testIssue698() {
+    // Most of the flow algorithms operate on Vars. We want to make
+    // sure the algorithm bails out appropriately if it sees
+    // a var that it doesn't know about.
+    inline(
+        "var x = ''; "
+        + "unknown.length < 2 && (unknown='0' + unknown);"
+        + "x = x + unknown; "
+        + "unknown.length < 3 && (unknown='0' + unknown);"
+        + "x = x + unknown; "
+        + "return x;",
+        "var x; "
+        + "unknown.length < 2 && (unknown='0' + unknown);"
+        + "x = '' + unknown; "
+        + "unknown.length < 3 && (unknown='0' + unknown);"
+        + "x = x + unknown; "
+        + "return x;");
+  }
+
+  public void testIssue777() {
+    test(
+        "function f(cmd, ta) {" +
+        "  var temp = cmd;" +
+        "  var temp2 = temp >> 2;" +
+        "  cmd = STACKTOP;" +
+        "  for (var src = temp2, dest = cmd >> 2, stop = src + 37;" +
+        "       src < stop;" +
+        "       src++, dest++) {" +
+        "    HEAP32[dest] = HEAP32[src];" +
+        "  }" +
+        "  temp = ta;" +
+        "  temp2 = temp >> 2;" +
+        "  ta = STACKTOP;" +
+        "  STACKTOP += 8;" +
+        "  HEAP32[ta >> 2] = HEAP32[temp2];" +
+        "  HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];" +
+        "}",
+        "function f(cmd, ta){" +
+        "  var temp;" +
+        "  var temp2 = cmd >> 2;" +
+        "  cmd = STACKTOP;" +
+        "  var src = temp2;" +
+        "  var dest = cmd >> 2;" +
+        "  var stop = src + 37;" +
+        "  for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];" +
+        "  temp2 = ta >> 2;" +
+        "  ta = STACKTOP;" +
+        "  STACKTOP += 8;" +
+        "  HEAP32[ta>>2] = HEAP32[temp2];" +
+        "  HEAP32[ta+4>>2] = HEAP32[temp2+1];" +
+        "}");
+  }
+
+  public void testTransitiveDependencies1() {
+    test(
+        "function f(x) { var a = x; var b = a; x = 3; return b; }",
+        "function f(x) { var a;     var b = x; x = 3; return b; }");
+  }
+
+  public void testTransitiveDependencies2() {
+    test(
+        "function f(x) { var a = x; var b = a; var c = b; x = 3; return c; }",
+        "function f(x) { var a    ; var b = x; var c    ; x = 3; return b; }");
   }
 
   private void noInline(String input) {
