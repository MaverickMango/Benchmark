diff -r -u buggy/src/com/google/javascript/jscomp/CodeGenerator.java inducing/src/com/google/javascript/jscomp/CodeGenerator.java
--- buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:22.618150491 +0800
+++ inducing/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:22.782153489 +0800
@@ -18,7 +18,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
-import com.google.common.collect.Maps;
 import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -27,7 +26,6 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
-import java.util.Map;
 
 /**
  * CodeGenerator generates codes from a parse tree, sending it to the specified
@@ -35,8 +33,6 @@
  *
  */
 class CodeGenerator {
-  // A memoizer for formatting strings as JS strings.
-  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();
 
   private static final char[] HEX_CHARS
       = { '0', '1', '2', '3', '4', '5', '6', '7',
@@ -223,7 +219,10 @@
         break;
 
       case Token.NUMBER:
-        Preconditions.checkState(childCount == 0);
+        Preconditions.checkState(
+            childCount ==
+            ((n.getParent() != null &&
+              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
         cc.addNumber(n.getDouble());
         break;
 
@@ -353,7 +352,7 @@
           if (!Double.isNaN(d)) {
             cc.addNumber(d);
           } else {
-            addJsString(n.getString());
+            add(jsString(n.getString(), outputCharsetEncoder));
           }
         }
 
@@ -635,7 +634,7 @@
           throw new IllegalStateException(
               "Unexpected String children: " + n.getParent().toStringTree());
         }
-        addJsString(n.getString());
+        add(jsString(n.getString(), outputCharsetEncoder));
         break;
 
       case Token.DELPROP:
@@ -747,13 +746,9 @@
 
   static double getSimpleNumber(String s) {
     if (isSimpleNumber(s)) {
-      try {
-        long l = Long.parseLong(s);
-        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
-          return l;
-        }
-      } catch (NumberFormatException e) {
-        // The number was too long to parse. Fall through to NaN.
+      long l = Long.parseLong(s);
+      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
+        return l;
       }
     }
     return Double.NaN;
@@ -944,16 +939,7 @@
   }
 
   /** Outputs a js string, using the optimal (single/double) quote character */
-  void addJsString(String s) {
-    String cached = ESCAPED_JS_STRINGS.get(s);
-    if (cached == null) {
-      cached = jsString(s);
-      ESCAPED_JS_STRINGS.put(s, cached);
-    }
-    add(cached);
-  }
-
-  String jsString(String s) {
+  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -1012,7 +998,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\x00"); break;
+        case '\0': sb.append("\\0"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
@@ -1059,7 +1045,7 @@
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
-            if (c > 0x1f && c < 0x7f) {
+            if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
diff -r -u buggy/test/com/google/javascript/jscomp/CodePrinterTest.java inducing/test/com/google/javascript/jscomp/CodePrinterTest.java
--- buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:22.618150491 +0800
+++ inducing/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:22.782153489 +0800
@@ -17,7 +17,6 @@
 package com.google.javascript.jscomp;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -40,8 +39,6 @@
       DefaultPassConfig passConfig = new DefaultPassConfig(null);
       CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
-      externs.setInputId(new InputId("externs"));
-      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
@@ -712,23 +709,6 @@
         + "a.Bar = function() {\n};\n");
   }
 
-  public void testTypeAnnotationsMultipleInterface() {
-    assertTypeAnnotations("var a = {};"
-        + "/** @interface */ a.Foo1 = function(){};"
-        + "/** @interface */ a.Foo2 = function(){};"
-        + "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
-        + "a.Bar = function(){}",
-        "var a = {};\n"
-        + "/**\n * @interface\n */\n"
-        + "a.Foo1 = function() {\n};\n"
-        + "/**\n * @interface\n */\n"
-        + "a.Foo2 = function() {\n};\n"
-        + "/**\n * @extends {a.Foo1}\n"
-        + " * @extends {a.Foo2}\n"
-        + " * @interface\n */\n"
-        + "a.Bar = function() {\n};\n");
-  }
-
   public void testTypeAnnotationsMember() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){}"
@@ -1163,13 +1143,6 @@
                 "var x={\"12345678901234567\":1}");
   }
 
-  public void testObjectLit4() {
-    // More than 128 bits.
-    assertPrint(
-        "var x={\"123456789012345671234567890123456712345678901234567\":1}",
-        "var x={\"123456789012345671234567890123456712345678901234567\":1}");
-  }
-
   public void testGetter() {
     assertPrint("var x = {}", "var x={}");
     assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}");
@@ -1230,28 +1203,8 @@
   }
 
   public void testZero() {
-    assertPrint("var x ='\\0';", "var x=\"\\x00\"");
-    assertPrint("var x ='\\x00';", "var x=\"\\x00\"");
-    assertPrint("var x ='\\u0000';", "var x=\"\\x00\"");
-    assertPrint("var x ='\\u00003';", "var x=\"\\x003\"");
-  }
-
-  public void testUnicode() {
-    assertPrint("var x ='\\x0f';", "var x=\"\\u000f\"");
-    assertPrint("var x ='\\x68';", "var x=\"h\"");
-    assertPrint("var x ='\\x7f';", "var x=\"\\u007f\"");
-  }
-
-  public void testUnicodeKeyword() {
-    // keyword "if"
-    assertPrint("var \\u0069\\u0066 = 1;", "var i\\u0066=1");
-    // keyword "var"
-    assertPrint("var v\\u0061\\u0072 = 1;", "var va\\u0072=1");
-    // all are keyword "while"
-    assertPrint("var w\\u0068\\u0069\\u006C\\u0065 = 1;"
-        + "\\u0077\\u0068il\\u0065 = 2;"
-        + "\\u0077h\\u0069le = 3;",
-        "var whil\\u0065=1;whil\\u0065=2;whil\\u0065=3");
+    assertPrint("var x ='\\0';", "var x=\"\\0\"");
+    assertPrint("var x ='\\x00';", "var x=\"\\0\"");
+    assertPrint("var x ='\\u0000';", "var x=\"\\0\"");
   }
-
 }
