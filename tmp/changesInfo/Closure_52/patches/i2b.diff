diff -r -u inducing/src/com/google/javascript/jscomp/CodeGenerator.java buggy/src/com/google/javascript/jscomp/CodeGenerator.java
--- inducing/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:40:21.730934283 +0800
+++ buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:40:21.530943603 +0800
@@ -18,6 +18,7 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Maps;
 import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -26,6 +27,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.util.Map;
 
 /**
  * CodeGenerator generates codes from a parse tree, sending it to the specified
@@ -33,6 +35,8 @@
  *
  */
 class CodeGenerator {
+  // A memoizer for formatting strings as JS strings.
+  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();
 
   private static final char[] HEX_CHARS
       = { '0', '1', '2', '3', '4', '5', '6', '7',
@@ -219,10 +223,7 @@
         break;
 
       case Token.NUMBER:
-        Preconditions.checkState(
-            childCount ==
-            ((n.getParent() != null &&
-              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
+        Preconditions.checkState(childCount == 0);
         cc.addNumber(n.getDouble());
         break;
 
@@ -352,7 +353,7 @@
           if (!Double.isNaN(d)) {
             cc.addNumber(d);
           } else {
-            add(jsString(n.getString(), outputCharsetEncoder));
+            addJsString(n.getString());
           }
         }
 
@@ -634,7 +635,7 @@
           throw new IllegalStateException(
               "Unexpected String children: " + n.getParent().toStringTree());
         }
-        add(jsString(n.getString(), outputCharsetEncoder));
+        addJsString(n.getString());
         break;
 
       case Token.DELPROP:
@@ -746,9 +747,13 @@
 
   static double getSimpleNumber(String s) {
     if (isSimpleNumber(s)) {
-      long l = Long.parseLong(s);
-      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
-        return l;
+      try {
+        long l = Long.parseLong(s);
+        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
+          return l;
+        }
+      } catch (NumberFormatException e) {
+        // The number was too long to parse. Fall through to NaN.
       }
     }
     return Double.NaN;
@@ -939,7 +944,16 @@
   }
 
   /** Outputs a js string, using the optimal (single/double) quote character */
-  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {
+  void addJsString(String s) {
+    String cached = ESCAPED_JS_STRINGS.get(s);
+    if (cached == null) {
+      cached = jsString(s);
+      ESCAPED_JS_STRINGS.put(s, cached);
+    }
+    add(cached);
+  }
+
+  String jsString(String s) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -998,7 +1012,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\0"); break;
+        case '\0': sb.append("\\x00"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
@@ -1045,7 +1059,7 @@
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
-            if (c > 0x1f && c <= 0x7f) {
+            if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
diff -r -u inducing/test/com/google/javascript/jscomp/CodePrinterTest.java buggy/test/com/google/javascript/jscomp/CodePrinterTest.java
--- inducing/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:40:21.730934283 +0800
+++ buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:40:21.530943603 +0800
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -39,6 +40,8 @@
       DefaultPassConfig passConfig = new DefaultPassConfig(null);
       CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
+      externs.setInputId(new InputId("externs"));
+      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
@@ -709,6 +712,23 @@
         + "a.Bar = function() {\n};\n");
   }
 
+  public void testTypeAnnotationsMultipleInterface() {
+    assertTypeAnnotations("var a = {};"
+        + "/** @interface */ a.Foo1 = function(){};"
+        + "/** @interface */ a.Foo2 = function(){};"
+        + "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
+        + "a.Bar = function(){}",
+        "var a = {};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo1 = function() {\n};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo2 = function() {\n};\n"
+        + "/**\n * @extends {a.Foo1}\n"
+        + " * @extends {a.Foo2}\n"
+        + " * @interface\n */\n"
+        + "a.Bar = function() {\n};\n");
+  }
+
   public void testTypeAnnotationsMember() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){}"
@@ -1143,6 +1163,13 @@
                 "var x={\"12345678901234567\":1}");
   }
 
+  public void testObjectLit4() {
+    // More than 128 bits.
+    assertPrint(
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}",
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}");
+  }
+
   public void testGetter() {
     assertPrint("var x = {}", "var x={}");
     assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}");
@@ -1203,8 +1230,28 @@
   }
 
   public void testZero() {
-    assertPrint("var x ='\\0';", "var x=\"\\0\"");
-    assertPrint("var x ='\\x00';", "var x=\"\\0\"");
-    assertPrint("var x ='\\u0000';", "var x=\"\\0\"");
+    assertPrint("var x ='\\0';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\x00';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\u0000';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\u00003';", "var x=\"\\x003\"");
+  }
+
+  public void testUnicode() {
+    assertPrint("var x ='\\x0f';", "var x=\"\\u000f\"");
+    assertPrint("var x ='\\x68';", "var x=\"h\"");
+    assertPrint("var x ='\\x7f';", "var x=\"\\u007f\"");
+  }
+
+  public void testUnicodeKeyword() {
+    // keyword "if"
+    assertPrint("var \\u0069\\u0066 = 1;", "var i\\u0066=1");
+    // keyword "var"
+    assertPrint("var v\\u0061\\u0072 = 1;", "var va\\u0072=1");
+    // all are keyword "while"
+    assertPrint("var w\\u0068\\u0069\\u006C\\u0065 = 1;"
+        + "\\u0077\\u0068il\\u0065 = 2;"
+        + "\\u0077h\\u0069le = 3;",
+        "var whil\\u0065=1;whil\\u0065=2;whil\\u0065=3");
   }
+
 }
