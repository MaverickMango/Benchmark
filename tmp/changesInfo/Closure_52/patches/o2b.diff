diff -r -u original/src/com/google/javascript/jscomp/CodeGenerator.java buggy/src/com/google/javascript/jscomp/CodeGenerator.java
--- original/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-13 15:31:40.395086285 +0800
+++ buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:40:21.530943603 +0800
@@ -18,6 +18,7 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Maps;
 import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -26,6 +27,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.util.Map;
 
 /**
  * CodeGenerator generates codes from a parse tree, sending it to the specified
@@ -33,6 +35,8 @@
  *
  */
 class CodeGenerator {
+  // A memoizer for formatting strings as JS strings.
+  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();
 
   private static final char[] HEX_CHARS
       = { '0', '1', '2', '3', '4', '5', '6', '7',
@@ -219,10 +223,7 @@
         break;
 
       case Token.NUMBER:
-        Preconditions.checkState(
-            childCount ==
-            ((n.getParent() != null &&
-              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
+        Preconditions.checkState(childCount == 0);
         cc.addNumber(n.getDouble());
         break;
 
@@ -340,13 +341,20 @@
         Node body = fn.getLastChild();
 
         // Add the property name.
-        if (TokenStream.isJSIdentifier(name) &&
+        if (!n.isQuotedString() &&
+            TokenStream.isJSIdentifier(name) &&
             // do not encode literally any non-literal characters that were
             // unicode escaped.
             NodeUtil.isLatin(name)) {
           add(name);
         } else {
-          add(jsString(n.getString(), outputCharsetEncoder));
+          // Determine if the string is a simple number.
+          double d = getSimpleNumber(name);
+          if (!Double.isNaN(d)) {
+            cc.addNumber(d);
+          } else {
+            addJsString(n.getString());
+          }
         }
 
         add(parameters);
@@ -627,7 +635,7 @@
           throw new IllegalStateException(
               "Unexpected String children: " + n.getParent().toStringTree());
         }
-        add(jsString(n.getString(), outputCharsetEncoder));
+        addJsString(n.getString());
         break;
 
       case Token.DELPROP:
@@ -650,18 +658,25 @@
           if (c.getType() == Token.GET || c.getType() == Token.SET) {
             add(c);
           } else {
-            // Object literal property names don't have to be quoted if they are
-            // not JavaScript keywords
-            if (c.getType() == Token.STRING &&
-                !c.isQuotedString() &&
-                !TokenStream.isKeyword(c.getString()) &&
-                TokenStream.isJSIdentifier(c.getString()) &&
-                // do not encode literally any non-literal characters that were
-                // unicode escaped.
-                NodeUtil.isLatin(c.getString())) {
-              add(c.getString());
+            Preconditions.checkState(c.getType() == Token.STRING);
+            String key = c.getString();
+            // Object literal property names don't have to be quoted if they
+            // are not JavaScript keywords
+            if (!c.isQuotedString() &&
+                !TokenStream.isKeyword(key) &&
+                TokenStream.isJSIdentifier(key) &&
+                // do not encode literally any non-literal characters that
+                // were unicode escaped.
+                NodeUtil.isLatin(key)) {
+              add(key);
             } else {
-              addExpr(c, 1);
+              // Determine if the string is a simple number.
+              double d = getSimpleNumber(key);
+              if (!Double.isNaN(d)) {
+                cc.addNumber(d);
+              } else {
+                addExpr(c, 1);
+              }
             }
             add(":");
             addExpr(c.getFirstChild(), 1);
@@ -719,6 +734,31 @@
     cc.endSourceMapping(n);
   }
 
+  static boolean isSimpleNumber(String s) {
+    int len = s.length();
+    for (int index = 0; index < len; index++) {
+      char c = s.charAt(index);
+      if (c < '0' || c > '9') {
+        return false;
+      }
+    }
+    return len > 0;
+  }
+
+  static double getSimpleNumber(String s) {
+    if (isSimpleNumber(s)) {
+      try {
+        long l = Long.parseLong(s);
+        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
+          return l;
+        }
+      } catch (NumberFormatException e) {
+        // The number was too long to parse. Fall through to NaN.
+      }
+    }
+    return Double.NaN;
+  }
+
   /**
    * @return Whether the name is an indirect eval.
    */
@@ -904,7 +944,16 @@
   }
 
   /** Outputs a js string, using the optimal (single/double) quote character */
-  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {
+  void addJsString(String s) {
+    String cached = ESCAPED_JS_STRINGS.get(s);
+    if (cached == null) {
+      cached = jsString(s);
+      ESCAPED_JS_STRINGS.put(s, cached);
+    }
+    add(cached);
+  }
+
+  String jsString(String s) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -963,7 +1012,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\0"); break;
+        case '\0': sb.append("\\x00"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
@@ -1010,7 +1059,7 @@
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
-            if (c > 0x1f && c <= 0x7f) {
+            if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
diff -r -u original/test/com/google/javascript/jscomp/CodePrinterTest.java buggy/test/com/google/javascript/jscomp/CodePrinterTest.java
--- original/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-13 15:31:40.395086285 +0800
+++ buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:40:21.530943603 +0800
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -39,6 +40,8 @@
       DefaultPassConfig passConfig = new DefaultPassConfig(null);
       CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
+      externs.setInputId(new InputId("externs"));
+      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
@@ -709,6 +712,23 @@
         + "a.Bar = function() {\n};\n");
   }
 
+  public void testTypeAnnotationsMultipleInterface() {
+    assertTypeAnnotations("var a = {};"
+        + "/** @interface */ a.Foo1 = function(){};"
+        + "/** @interface */ a.Foo2 = function(){};"
+        + "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
+        + "a.Bar = function(){}",
+        "var a = {};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo1 = function() {\n};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo2 = function() {\n};\n"
+        + "/**\n * @extends {a.Foo1}\n"
+        + " * @extends {a.Foo2}\n"
+        + " * @interface\n */\n"
+        + "a.Bar = function() {\n};\n");
+  }
+
   public void testTypeAnnotationsMember() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){}"
@@ -1122,6 +1142,34 @@
     assertPrint("var x={1:1}", "var x={1:1}");
   }
 
+  public void testObjectLit2() {
+    assertPrint("var x={1:1}", "var x={1:1}");
+    assertPrint("var x={'1':1}", "var x={1:1}");
+    assertPrint("var x={'1.0':1}", "var x={\"1.0\":1}");
+    assertPrint("var x={1.5:1}", "var x={\"1.5\":1}");
+
+  }
+
+  public void testObjectLit3() {
+    assertPrint("var x={3E9:1}",
+                "var x={3E9:1}");
+    assertPrint("var x={'3000000000':1}", // More than 31 bits
+                "var x={3E9:1}");
+    assertPrint("var x={'3000000001':1}",
+                "var x={3000000001:1}");
+    assertPrint("var x={'6000000001':1}",  // More than 32 bits
+                "var x={6000000001:1}");
+    assertPrint("var x={\"12345678901234567\":1}",  // More than 53 bits
+                "var x={\"12345678901234567\":1}");
+  }
+
+  public void testObjectLit4() {
+    // More than 128 bits.
+    assertPrint(
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}",
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}");
+  }
+
   public void testGetter() {
     assertPrint("var x = {}", "var x={}");
     assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}");
@@ -1129,30 +1177,36 @@
       "var x = {get a() {}, get b(){}}",
       "var x={get a(){},get b(){}}");
 
-    // Valid ES5 but Rhino doesn't accept this yet.
-    // assertPrint(
-    //  "var x = {get 1() {return 1}}",
-    //  "var x={get \"1\"(){return 1}}");
-
-    // Valid ES5 but Rhino doesn't accept this yet.
-    // assertPrint(
-    //  "var x = {get \"()\"() {return 1}}",
-    //   "var x={get \"()\"(){return 1}}");
+    assertPrint(
+      "var x = {get 'a'() {return 1}}",
+      "var x={get \"a\"(){return 1}}");
+
+    assertPrint(
+      "var x = {get 1() {return 1}}",
+      "var x={get 1(){return 1}}");
+
+    assertPrint(
+      "var x = {get \"()\"() {return 1}}",
+      "var x={get \"()\"(){return 1}}");
   }
 
   public void testSetter() {
     assertPrint("var x = {}", "var x={}");
-    assertPrint("var x = {set a(x) {return 1}}", "var x={set a(x){return 1}}");
+    assertPrint(
+       "var x = {set a(y) {return 1}}",
+       "var x={set a(y){return 1}}");
+
+    assertPrint(
+      "var x = {get 'a'() {return 1}}",
+      "var x={get \"a\"(){return 1}}");
 
-    // Valid ES5 but Rhino doesn't accept this yet.
-    // assertPrint(
-    //  "var x = {set 1(x) {return 1}}",
-    //  "var x={set \"1\"(x){return 1}}");
-
-    // Valid ES5 but Rhino doesn't accept this yet.
-    // assertPrint(
-    //  "var x = {set \"(x)\"() {return 1}}",
-    //   "var x={set \"(x)\"(){return 1}}");
+    assertPrint(
+      "var x = {set 1(y) {return 1}}",
+      "var x={set 1(y){return 1}}");
+
+    assertPrint(
+      "var x = {set \"(x)\"(y) {return 1}}",
+      "var x={set \"(x)\"(y){return 1}}");
   }
 
   public void testNegCollapse() {
@@ -1176,8 +1230,28 @@
   }
 
   public void testZero() {
-    assertPrint("var x ='\\0';", "var x=\"\\0\"");
-    assertPrint("var x ='\\x00';", "var x=\"\\0\"");
-    assertPrint("var x ='\\u0000';", "var x=\"\\0\"");
+    assertPrint("var x ='\\0';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\x00';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\u0000';", "var x=\"\\x00\"");
+    assertPrint("var x ='\\u00003';", "var x=\"\\x003\"");
+  }
+
+  public void testUnicode() {
+    assertPrint("var x ='\\x0f';", "var x=\"\\u000f\"");
+    assertPrint("var x ='\\x68';", "var x=\"h\"");
+    assertPrint("var x ='\\x7f';", "var x=\"\\u007f\"");
+  }
+
+  public void testUnicodeKeyword() {
+    // keyword "if"
+    assertPrint("var \\u0069\\u0066 = 1;", "var i\\u0066=1");
+    // keyword "var"
+    assertPrint("var v\\u0061\\u0072 = 1;", "var va\\u0072=1");
+    // all are keyword "while"
+    assertPrint("var w\\u0068\\u0069\\u006C\\u0065 = 1;"
+        + "\\u0077\\u0068il\\u0065 = 2;"
+        + "\\u0077h\\u0069le = 3;",
+        "var whil\\u0065=1;whil\\u0065=2;whil\\u0065=3");
   }
+
 }
