diff -r -u inducing/src/com/google/javascript/jscomp/NodeUtil.java buggy/src/com/google/javascript/jscomp/NodeUtil.java
--- inducing/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:22.970876600 +0800
+++ buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:22.758886457 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,8 @@
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
+import com.google.javascript.rhino.jstype.FunctionType;
+import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.TernaryValue;
 
 import java.util.Arrays;
@@ -43,6 +45,10 @@
  */
 public final class NodeUtil {
 
+  static final long MAX_POSITIVE_INTEGER_NUMBER = (long)Math.pow(2, 53);
+
+  final static String JSC_PROPERTY_NAME_FN = "JSCompiler_renameProperty";
+
   // TODO(user): Eliminate this class and make all of the static methods
   // instance methods of com.google.javascript.rhino.Node.
 
@@ -65,45 +71,52 @@
    * Note: unlike getBooleanValue this function does not return UNKNOWN
    * for expressions with side-effects.
    */
-  static TernaryValue getExpressionBooleanValue(Node n) {
+  static TernaryValue getImpureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.ASSIGN:
       case Token.COMMA:
         // For ASSIGN and COMMA the value is the value of the RHS.
-        return getExpressionBooleanValue(n.getLastChild());
+        return getImpureBooleanValue(n.getLastChild());
       case Token.NOT:
-        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue value = getImpureBooleanValue(n.getLastChild());
         return value.not();
       case Token.AND: {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
       case Token.OR:  {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
       case Token.HOOK:  {
-        TernaryValue trueValue = getExpressionBooleanValue(
+        TernaryValue trueValue = getImpureBooleanValue(
             n.getFirstChild().getNext());
-        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
         } else {
           return TernaryValue.UNKNOWN;
         }
       }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // ignoring side-effects
+        return TernaryValue.TRUE;
+
       default:
-        return getBooleanValue(n);
+        return getPureBooleanValue(n);
     }
   }
 
   /**
    * Gets the boolean value of a node that represents a literal. This method
-   * effectively emulates the <code>Boolean()</code> JavaScript cast function.
+   * effectively emulates the <code>Boolean()</code> JavaScript cast function
+   * except it return UNKNOWN for known values with side-effects, use
+   * getExpressionBooleanValue if you don't care about side-effects.
    */
-  static TernaryValue getBooleanValue(Node n) {
+  static TernaryValue getPureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
@@ -111,6 +124,9 @@
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
 
+      case Token.NOT:
+        return getPureBooleanValue(n.getLastChild()).not();
+
       case Token.NULL:
       case Token.FALSE:
       case Token.VOID:
@@ -129,38 +145,41 @@
         break;
 
       case Token.TRUE:
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
       case Token.REGEXP:
         return TernaryValue.TRUE;
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        if (!mayHaveSideEffects(n)) {
+          return TernaryValue.TRUE;
+        }
     }
 
     return TernaryValue.UNKNOWN;
   }
 
-
   /**
    * Gets the value of a node as a String, or null if it cannot be converted.
    * When it returns a non-null String, this method effectively emulates the
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): Convert constant array, object, and regex literals as well.
+    // TODO(user): regex literals as well.
     switch (n.getType()) {
-      case Token.NAME:
       case Token.STRING:
         return n.getString();
 
-      case Token.NUMBER:
-        double value = n.getDouble();
-        long longValue = (long) value;
-
-        // Return "1" instead of "1.0"
-        if (longValue == value) {
-          return Long.toString(longValue);
-        } else {
-          return Double.toString(n.getDouble());
+      case Token.NAME:
+        String name = n.getString();
+        if ("undefined".equals(name)
+            || "Infinity".equals(name)
+            || "NaN".equals(name)) {
+          return name;
         }
+        break;
+
+      case Token.NUMBER:
+        return getStringValue(n.getDouble());
 
       case Token.FALSE:
       case Token.TRUE:
@@ -169,10 +188,214 @@
 
       case Token.VOID:
         return "undefined";
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? "false" : "true"; // reversed.
+        }
+        break;
+
+      case Token.ARRAYLIT:
+        return arrayToString(n);
+
+      case Token.OBJECTLIT:
+        return "[object Object]";
+    }
+    return null;
+  }
+
+  static String getStringValue(double value) {
+    long longValue = (long) value;
+
+    // Return "1" instead of "1.0"
+    if (longValue == value) {
+      return Long.toString(longValue);
+    } else {
+      return Double.toString(value);
+    }
+  }
+
+  /**
+   * When converting arrays to string using Array.prototype.toString or
+   * Array.prototype.join, the rules for conversion to String are different
+   * than converting each element individually.  Specifically, "null" and
+   * "undefined" are converted to an empty string.
+   * @param n A node that is a member of an Array.
+   * @return The string representation.
+   */
+  static String getArrayElementStringValue(Node n) {
+    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)
+        ? "" : getStringValue(n);
+  }
+
+  static String arrayToString(Node literal) {
+    Node first = literal.getFirstChild();
+    StringBuilder result = new StringBuilder();
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
+    for (Node n = first; n != null; n = n.getNext()) {
+      String childValue = getArrayElementStringValue(n);
+      if (childValue == null) {
+        return null;
+      }
+      if (n != first) {
+        result.append(',');
+      }
+      result.append(childValue);
+
+      nextSlot++;
+    }
+    return result.toString();
+  }
+
+  /**
+   * Gets the value of a node as a Number, or null if it cannot be converted.
+   * When it returns a non-null Double, this method effectively emulates the
+   * <code>Number()</code> JavaScript cast function.
+   */
+  static Double getNumberValue(Node n) {
+    switch (n.getType()) {
+      case Token.TRUE:
+        return 1.0;
+
+      case Token.FALSE:
+      case Token.NULL:
+        return 0.0;
+
+      case Token.NUMBER:
+        return n.getDouble();
+
+      case Token.VOID:
+        if (mayHaveSideEffects(n.getFirstChild())) {
+          return null;
+        } else {
+          return Double.NaN;
+        }
+
+      case Token.NAME:
+        // Check for known constants
+        String name = n.getString();
+        if (name.equals("undefined")) {
+          return Double.NaN;
+        }
+        if (name.equals("NaN")) {
+          return Double.NaN;
+        }
+        if (name.equals("Infinity")) {
+          return Double.POSITIVE_INFINITY;
+        }
+        return null;
+
+      case Token.NEG:
+        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME
+            && n.getFirstChild().getString().equals("Infinity")) {
+          return Double.NEGATIVE_INFINITY;
+        }
+        return null;
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
+        }
+        break;
+
+      case Token.STRING:
+        return getStringNumberValue(n.getString());
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        String value = getStringValue(n);
+        return value != null ? getStringNumberValue(value) : null;
     }
+
     return null;
   }
 
+  static Double getStringNumberValue(String rawJsString) {
+    if (rawJsString.contains("\u000b")) {
+      // vertical tab is not always whitespace
+      return null;
+    }
+
+    String s = trimJsWhiteSpace(rawJsString);
+    // return ScriptRuntime.toNumber(s);
+    if (s.length() == 0) {
+      return 0.0;
+    }
+
+    if (s.length() > 2
+        && s.charAt(0) == '0'
+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+      // Attempt to convert hex numbers.
+      try {
+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+      } catch (NumberFormatException e) {
+        return Double.NaN;
+      }
+    }
+
+    if (s.length() > 3
+        && (s.charAt(0) == '-' || s.charAt(0) == '+')
+        && s.charAt(1) == '0'
+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+      // hex numbers with explicit signs vary between browsers.
+      return null;
+    }
+
+    // FireFox and IE treat the "Infinity" differently. FireFox is case
+    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+    if (s.equals("infinity")
+        || s.equals("-infinity")
+        || s.equals("+infinity")) {
+      return null;
+    }
+
+    try {
+      return Double.parseDouble(s);
+    } catch (NumberFormatException e) {
+      return Double.NaN;
+    }
+  }
+
+  static String trimJsWhiteSpace(String s) {
+    int start = 0;
+    int end = s.length();
+    while (end > 0
+        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
+      end--;
+    }
+    while (start < end
+        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
+      start++;
+    }
+    return s.substring(start, end);
+  }
+
+  /**
+   * Copied from Rhino's ScriptRuntime
+   */
+  static TernaryValue isStrWhiteSpaceChar(int c) {
+    switch (c) {
+      case '\u000B': // <VT>
+        return TernaryValue.UNKNOWN;  // IE says "no", EcmaScript says "yes"
+      case ' ': // <SP>
+      case '\n': // <LF>
+      case '\r': // <CR>
+      case '\t': // <TAB>
+      case '\u00A0': // <NBSP>
+      case '\u000C': // <FF>
+      case '\u2028': // <LS>
+      case '\u2029': // <PS>
+      case '\uFEFF': // <BOM>
+        return TernaryValue.TRUE;
+      default:
+        return (Character.getType(c) == Character.SPACE_SEPARATOR)
+            ? TernaryValue.TRUE : TernaryValue.FALSE;
+    }
+  }
+
   /**
    * Gets the function's name. This method recognizes five forms:
    * <ul>
@@ -209,6 +432,43 @@
   }
 
   /**
+   * Gets the function's name. This method recognizes the forms:
+   * <ul>
+   * <li>{@code &#123;'name': function() ...&#125;}</li>
+   * <li>{@code &#123;name: function() ...&#125;}</li>
+   * <li>{@code function name() ...}</li>
+   * <li>{@code var name = function() ...}</li>
+   * <li>{@code qualified.name = function() ...}</li>
+   * <li>{@code var name2 = function name1() ...}</li>
+   * <li>{@code qualified.name2 = function name1() ...}</li>
+   * </ul>
+   *
+   * @param n a node whose type is {@link Token#FUNCTION}
+   * @return the function's name, or {@code null} if it has no name
+   */
+  public static String getNearestFunctionName(Node n) {
+    String name = getFunctionName(n);
+    if (name != null) {
+      return name;
+    }
+
+    // Check for the form { 'x' : function() { } }
+    Node parent = n.getParent();
+    switch (parent.getType()) {
+      case Token.SET:
+      case Token.GET:
+      case Token.STRING:
+        // Return the name of the literal's key.
+        return parent.getString();
+      case Token.NUMBER:
+        return getStringValue(parent);
+    }
+
+    return null;
+  }
+
+
+  /**
    * Returns true if this is an immutable value.
    */
   static boolean isImmutableValue(Node n) {
@@ -219,6 +479,8 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
+      case Token.NOT:
+        return isImmutableValue(n.getFirstChild());
       case Token.VOID:
       case Token.NEG:
         return isImmutableValue(n.getFirstChild());
@@ -259,7 +521,15 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if (child.getType() != Token.EMPTY
+              && !isLiteralValue(child, includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.REGEXP:
         // Return true only if all children are const.
         for (Node child = n.getFirstChild(); child != null;
@@ -270,6 +540,16 @@
         }
         return true;
 
+      case Token.OBJECTLIT:
+        // Return true only if all values are const.
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.FUNCTION:
         return includeFunctions && !NodeUtil.isFunctionDeclaration(n);
 
@@ -292,13 +572,34 @@
       case Token.FALSE:
         return true;
 
-      // Single operators are valid if the child is valid.
+      // Binary operators are only valid if both children are valid.
+      case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
+
+      // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
+      case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
@@ -449,6 +750,17 @@
         return true;
 
       case Token.OBJECTLIT:
+        if (checkForNewObjects) {
+          return true;
+        }
+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+          if (checkForStateChangeHelper(
+                  c.getFirstChild(), checkForNewObjects, compiler)) {
+            return true;
+          }
+        }
+        return false;
+
       case Token.ARRAYLIT:
       case Token.REGEXP:
         if (checkForNewObjects) {
@@ -497,6 +809,11 @@
         }
 
         if (isAssignmentOp(n)) {
+          Node assignTarget = n.getFirstChild();
+          if (isName(assignTarget)) {
+            return true;
+          }
+
           // Assignments will have side effects if
           // a) The RHS has side effects, or
           // b) The LHS has side effects, or
@@ -508,13 +825,32 @@
             return true;
           }
 
-          Node current = n.getFirstChild();
-          for (;
-               current.getType() == Token.GETPROP ||
-               current.getType() == Token.GETELEM;
-               current = current.getFirstChild()) { }
-
-          return !isLiteralValue(current, true);
+          if (isGet(assignTarget)) {
+            // If the object being assigned to is a local object, don't
+            // consider this a side-effect as it can't be referenced
+            // elsewhere.  Don't do this recursively as the property might
+            // be an alias of another object, unlike a literal below.
+            Node current = assignTarget.getFirstChild();
+            if (evaluatesToLocalValue(current)) {
+              return false;
+            }
+
+            // A literal value as defined by "isLiteralValue" is guaranteed
+            // not to be an alias, or any components which are aliases of
+            // other objects.
+            // If the root object is a literal don't consider this a
+            // side-effect.
+            while (isGet(current)) {
+              current = current.getFirstChild();
+            }
+
+            return !isLiteralValue(current, true);
+          } else {
+            // TODO(johnlenz): remove this code and make this an exception. This
+            // is here only for legacy reasons, the AST is not valid but
+            // preserve existing behavior.
+            return !isLiteralValue(assignTarget, true);
+          }
         }
 
         return true;
@@ -540,9 +876,10 @@
 
   static boolean constructorCallHasSideEffects(
       Node callNode, AbstractCompiler compiler) {
-    Preconditions.checkArgument(
-        callNode.getType() == Token.NEW,
-        "Expected NEW node, got " + Token.name(callNode.getType()));
+    if (callNode.getType() != Token.NEW) {
+      throw new IllegalStateException(
+          "Expected NEW node, got " + Token.name(callNode.getType()));
+    }
 
     if (callNode.isNoSideEffectsCall()) {
       return false;
@@ -563,6 +900,8 @@
   private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =
       ImmutableSet.of(
           "Object", "Array", "String", "Number", "Boolean", "RegExp", "Error");
+  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =
+      ImmutableSet.of("toString", "valueOf");
   private static final Set<String> REGEXP_METHODS =
       ImmutableSet.of("test", "exec");
   private static final Set<String> STRING_REGEXP_METHODS =
@@ -573,8 +912,7 @@
    *
    * @param callNode - function call node
    */
-  static boolean functionCallHasSideEffects(
-      Node callNode) {
+  static boolean functionCallHasSideEffects(Node callNode) {
     return functionCallHasSideEffects(callNode, null);
   }
 
@@ -587,9 +925,10 @@
    */
   static boolean functionCallHasSideEffects(
       Node callNode, @Nullable AbstractCompiler compiler) {
-    Preconditions.checkArgument(
-        callNode.getType() == Token.CALL,
-        "Expected CALL node, got " + Token.name(callNode.getType()));
+    if (callNode.getType() != Token.CALL) {
+      throw new IllegalStateException(
+          "Expected CALL node, got " + Token.name(callNode.getType()));
+    }
 
     if (callNode.isNoSideEffectsCall()) {
       return false;
@@ -604,10 +943,22 @@
         return false;
       }
     } else if (nameNode.getType() == Token.GETPROP) {
-      // Functions in the "Math" namespace have no side effects.
+      if (callNode.hasOneChild()
+          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
+                nameNode.getLastChild().getString())) {
+        return false;
+      }
+
+      if (callNode.isOnlyModifiesThisCall()
+          && evaluatesToLocalValue(nameNode.getFirstChild())) {
+        return false;
+      }
+
+      // Math.floor has no sideeffects.
+      // TODO(nicksantos): This is a terrible terrible hack, until
+      // I create a definitionprovider that understands namespacing.
       if (nameNode.getFirstChild().getType() == Token.NAME) {
-        String namespaceName = nameNode.getFirstChild().getString();
-        if (namespaceName.equals("Math")) {
+        if ("Math.floor".equals(nameNode.getQualifiedName())) {
           return false;
         }
       }
@@ -640,6 +991,14 @@
   }
 
   /**
+   * @return Whether the new has a local result.
+   */
+  static boolean newHasLocalResult(Node n) {
+    Preconditions.checkState(n.getType() == Token.NEW);
+    return n.isOnlyModifiesThisCall();
+  }
+
+  /**
    * Returns true if the current node's type implies side effects.
    *
    * This is a non-recursive version of the may have side effects
@@ -789,22 +1148,19 @@
       case Token.POS:
       case Token.NEG:    return 13;
 
-      case Token.ARRAYLIT:
       case Token.CALL:
-      case Token.EMPTY:
-      case Token.FALSE:
-      case Token.FUNCTION:
       case Token.GETELEM:
       case Token.GETPROP:
-      case Token.GET_REF:
-      case Token.IF:
-      case Token.LP:
+      // Data values
+      case Token.ARRAYLIT:
+      case Token.EMPTY:  // TODO(johnlenz): remove this.
+      case Token.FALSE:
+      case Token.FUNCTION:
       case Token.NAME:
       case Token.NULL:
       case Token.NUMBER:
       case Token.OBJECTLIT:
       case Token.REGEXP:
-      case Token.RETURN:
       case Token.STRING:
       case Token.THIS:
       case Token.TRUE:
@@ -817,9 +1173,172 @@
   }
 
   /**
+   * Apply the supplied predicate against the potential
+   * all possible result of the expression.
+   */
+  static boolean valueCheck(Node n, Predicate<Node> p) {
+    switch (n.getType()) {
+      case Token.ASSIGN:
+      case Token.COMMA:
+        return valueCheck(n.getLastChild(), p);
+      case Token.AND:
+      case Token.OR:
+        return valueCheck(n.getFirstChild(), p)
+            && valueCheck(n.getLastChild(), p);
+      case Token.HOOK:
+        return valueCheck(n.getFirstChild().getNext(), p)
+            && valueCheck(n.getLastChild(), p);
+      default:
+        return p.apply(n);
+    }
+  }
+
+  static class NumbericResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isNumericResultHelper(n);
+    }
+  }
+
+  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
+      new NumbericResultPredicate();
+
+  /**
+   * Returns true if the result of node evaluation is always a number
+   */
+  static boolean isNumericResult(Node n) {
+    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);
+  }
+
+  static boolean isNumericResultHelper(Node n) {
+    switch (n.getType()) {
+      case Token.ADD:
+        return !mayBeString(n.getFirstChild())
+            && !mayBeString(n.getLastChild());
+      case Token.BITNOT:
+      case Token.BITOR:
+      case Token.BITXOR:
+      case Token.BITAND:
+      case Token.LSH:
+      case Token.RSH:
+      case Token.URSH:
+      case Token.SUB:
+      case Token.MUL:
+      case Token.MOD:
+      case Token.DIV:
+      case Token.INC:
+      case Token.DEC:
+      case Token.POS:
+      case Token.NEG:
+      case Token.NUMBER:
+        return true;
+      case Token.NAME:
+        String name = n.getString();
+        if (name.equals("NaN")) {
+          return true;
+        }
+        if (name.equals("Infinity")) {
+          return true;
+        }
+        return false;
+      default:
+        return false;
+    }
+  }
+
+  static class BooleanResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isBooleanResultHelper(n);
+    }
+  }
+
+  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
+      new BooleanResultPredicate();
+
+  /**
+   * @return Whether the result of node evaluation is always a boolean
+   */
+  static boolean isBooleanResult(Node n) {
+    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);
+  }
+
+  static boolean isBooleanResultHelper(Node n) {
+    switch (n.getType()) {
+      // Primitives
+      case Token.TRUE:
+      case Token.FALSE:
+      // Comparisons
+      case Token.EQ:
+      case Token.NE:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.LT:
+      case Token.GT:
+      case Token.LE:
+      case Token.GE:
+      // Queryies
+      case Token.IN:
+      case Token.INSTANCEOF:
+      // Inversion
+      case Token.NOT:
+      // delete operator returns a boolean.
+      case Token.DELPROP:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  static boolean isUndefined(Node n) {
+    switch (n.getType()) {
+      case Token.VOID:
+        return true;
+      case Token.NAME:
+        return n.getString().equals("undefined");
+    }
+    return false;
+  }
+
+  static boolean isNull(Node n) {
+    return n.getType() == Token.NULL;
+  }
+
+  static boolean isNullOrUndefined(Node n) {
+    return isNull(n) || isUndefined(n);
+  }
+
+  static class MayBeStringResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
+      new MayBeStringResultPredicate();
+
+  /**
+   * @returns Whether the results is possibly a string.
+   */
+  static boolean mayBeString(Node n) {
+    return mayBeString(n, true);
+  }
+
+  static boolean mayBeString(Node n, boolean recurse) {
+    if (recurse) {
+      return valueCheck(n, MAY_BE_STRING_PREDICATE);
+    } else {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static boolean mayBeStringHelper(Node n) {
+    return !isNumericResult(n) && !isBooleanResult(n)
+        && !isUndefined(n) && !isNull(n);
+  }
+
+  /**
    * Returns true if the operator is associative.
    * e.g. (a * b) * c = a * (b * c)
-   * Note: "+" is not associative because it is also the concatentation
+   * Note: "+" is not associative because it is also the concatenation
    * for strings. e.g. "a" + (1 + 2) is not "a" + 1 + 2
    */
   static boolean isAssociative(int type) {
@@ -828,6 +1347,26 @@
       case Token.AND:
       case Token.OR:
       case Token.BITOR:
+      case Token.BITXOR:
+      case Token.BITAND:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Returns true if the operator is commutative.
+   * e.g. (a * b) * c = c * (b * a)
+   * Note 1: "+" is not commutative because it is also the concatenation
+   * for strings. e.g. "a" + (1 + 2) is not "a" + 1 + 2
+   * Note 2: only operations on literals and pure functions are commutative.
+   */
+  static boolean isCommutative(int type) {
+    switch (type) {
+      case Token.MUL:
+      case Token.BITOR:
+      case Token.BITXOR:
       case Token.BITAND:
         return true;
       default:
@@ -898,7 +1437,8 @@
    * Returns true if the shallow scope contains references to 'this' keyword
    */
   static boolean referencesThis(Node n) {
-    return containsType(n, Token.THIS, new MatchNotFunction());
+    Node start = (isFunction(n)) ? n.getLastChild() : n;
+    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);
   }
 
   /**
@@ -1148,7 +1688,10 @@
    * @return Whether the node is used as a statement.
    */
   static boolean isStatement(Node n) {
-    Node parent = n.getParent();
+    return isStatementParent(n.getParent());
+  }
+
+  static boolean isStatementParent(Node parent) {
     // It is not possible to determine definitely if a node is a statement
     // or not if it is not part of the AST.  A FUNCTION node can be
     // either part of an expression or a statement.
@@ -1187,12 +1730,40 @@
         && child == parent.getLastChild();
   }
 
+  /** Whether the node is a CATCH container BLOCK. */
+  static boolean isTryCatchNodeContainer(Node n) {
+    Node parent = n.getParent();
+    return parent.getType() == Token.TRY
+        && parent.getFirstChild().getNext() == n;
+  }
+
   /** Safely remove children while maintaining a valid node structure. */
   static void removeChild(Node parent, Node node) {
-    // Node parent = node.getParent();
-    if (isStatementBlock(parent)
-        || isSwitchCase(node)
-        || isTryFinallyNode(parent, node)) {
+    if (isTryFinallyNode(parent, node)) {
+      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {
+        // A finally can only be removed if there is a catch.
+        parent.removeChild(node);
+      } else {
+        // Otherwise only its children can be removed.
+        node.detachChildren();
+      }
+    } else if (node.getType() == Token.CATCH) {
+      // The CATCH can can only be removed if there is a finally clause.
+      Node tryNode = node.getParent().getParent();
+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
+      node.detachFromParent();
+    } else if (isTryCatchNodeContainer(node)) {
+      // The container node itself can't be removed, but the contained CATCH
+      // can if there is a 'finally' clause
+      Node tryNode = node.getParent();
+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
+      node.detachChildren();
+    } else if (node.getType() == Token.BLOCK) {
+      // Simply empty the block.  This maintains source location and
+      // "synthetic"-ness.
+      node.detachChildren();
+    } else if (isStatementBlock(parent)
+        || isSwitchCase(node)) {
       // A statement in a block can simply be removed.
       parent.removeChild(node);
     } else if (parent.getType() == Token.VAR) {
@@ -1204,10 +1775,6 @@
         // This would leave an empty VAR, remove the VAR itself.
         removeChild(parent.getParent(), parent);
       }
-    } else if (node.getType() == Token.BLOCK) {
-      // Simply empty the block.  This maintains source location and
-      // "synthetic"-ness.
-      node.detachChildren();
     } else if (parent.getType() == Token.LABEL
         && node == parent.getLastChild()) {
       // Remove the node from the parent, so it can be reused.
@@ -1227,6 +1794,17 @@
   }
 
   /**
+   * Add a finally block if one does not exist.
+   */
+  static void maybeAddFinally(Node tryNode) {
+    Preconditions.checkState(tryNode.getType() == Token.TRY);
+    if (!NodeUtil.hasFinally(tryNode)) {
+      tryNode.addChildrenToBack(new Node(Token.BLOCK)
+          .copyInformationFrom(tryNode));
+    }
+  }
+
+  /**
    * Merge a block with its parent block.
    * @return Whether the block was removed.
    */
@@ -1257,6 +1835,14 @@
   }
 
   /**
+   * @param node A node
+   * @return Whether the call is a NEW or CALL node.
+   */
+  static boolean isCallOrNew(Node node) {
+    return NodeUtil.isCall(node) || NodeUtil.isNew(node);
+  }
+
+  /**
    * Is this a FUNCTION node?
    */
   static boolean isFunction(Node n) {
@@ -1278,6 +1864,14 @@
     return node.getType() == Token.THIS;
   }
 
+
+  /**
+   * Is this an ARRAYLIT node
+   */
+  static boolean isArrayLiteral(Node node) {
+    return node.getType() == Token.ARRAYLIT;
+  }
+
   /**
    * Is this node or any of its children a CALL?
    */
@@ -1351,7 +1945,7 @@
     return isNameReferenced(
         function.getLastChild(),
         "arguments",
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
   }
 
   /**
@@ -1394,6 +1988,18 @@
 
   /**
    * @return Whether the callNode represents an expression in the form of:
+   *    x.apply(...)
+   *    x['apply'](...)
+   *  or
+   *    x.call(...)
+   *    x['call'](...)
+   */
+  static boolean isFunctionObjectCallOrApply(Node callNode) {
+    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);
+  }
+
+  /**
+   * @return Whether the callNode represents an expression in the form of:
    *    x.call(...)
    *    x['call'](...)
    * where x is a NAME node.
@@ -1417,12 +2023,41 @@
    * @param parent Parent of the node
    * @return True if n is the left hand of an assign
    */
-  static boolean isLhs(Node n, Node parent) {
+  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {
     return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||
            parent.getType() == Token.VAR;
   }
 
   /**
+   * Determines whether this node is used as an L-value. Notice that sometimes
+   * names are used as both L-values and R-values.
+   *
+   * We treat "var x;" as a pseudo-L-value, which kind of makes sense if you
+   * treat it as "assignment to 'undefined' at the top of the scope". But if
+   * we're honest with ourselves, it doesn't make sense, and we only do this
+   * because it makes sense to treat this as synactically similar to
+   * "var x = 0;".
+   *
+   * @param node The node
+   * @return True if n is an L-value.
+   */
+  static boolean isLValue(Node node) {
+    int nType = node.getType();
+    Preconditions.checkArgument(nType == Token.NAME || nType == Token.GETPROP ||
+        nType == Token.GETELEM);
+    Node parent = node.getParent();
+    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)
+        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)
+        || NodeUtil.isVar(parent)
+        || (parent.getType() == Token.FUNCTION &&
+            parent.getFirstChild() == node)
+        || parent.getType() == Token.DEC
+        || parent.getType() == Token.INC
+        || parent.getType() == Token.LP
+        || parent.getType() == Token.CATCH;
+  }
+
+  /**
    * Determines whether a node represents an object literal key
    * (e.g. key1 in {key1: value1, key2: value2}).
    *
@@ -1430,17 +2065,75 @@
    * @param parent The node's parent
    */
   static boolean isObjectLitKey(Node node, Node parent) {
-    if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) {
-      int index = 0;
-      for (Node current = parent.getFirstChild();
-           current != null;
-           current = current.getNext()) {
-        if (current == node) {
-          return index % 2 == 0;
-        }
-        index++;
+    switch (node.getType()) {
+      case Token.STRING:
+        return parent.getType() == Token.OBJECTLIT;
+      case Token.GET:
+      case Token.SET:
+        return true;
+    }
+    return false;
+  }
+
+  /**
+   * Get the name of an object literal key.
+   *
+   * @param key A node
+   */
+  static String getObjectLitKeyName(Node key) {
+    switch (key.getType()) {
+      case Token.STRING:
+      case Token.GET:
+      case Token.SET:
+        return key.getString();
+    }
+    throw new IllegalStateException("Unexpected node type: " + key);
+  }
+
+  /**
+   * @param key A OBJECTLIT key node.
+   * @return The type expected when using the key.
+   */
+  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {
+    if (valueType != null) {
+      switch (key.getType()) {
+        case Token.GET:
+          // GET must always return a function type.
+          if (valueType.isFunctionType()) {
+            FunctionType fntype = ((FunctionType) valueType);
+            valueType = fntype.getReturnType();
+          } else {
+            return null;
+          }
+          break;
+        case Token.SET:
+          if (valueType.isFunctionType()) {
+            // SET must always return a function type.
+            FunctionType fntype = ((FunctionType) valueType);
+            Node param = fntype.getParametersNode().getFirstChild();
+            // SET function must always have one parameter.
+            valueType = param.getJSType();
+          } else {
+            return null;
+          }
+          break;
       }
     }
+    return valueType;
+  }
+
+  /**
+   * Determines whether a node represents an object literal get or set key
+   * (e.g. key1 in {get key1() {}, set key2(a){}).
+   *
+   * @param node A node
+   */
+  static boolean isGetOrSetKey(Node node) {
+    switch (node.getType()) {
+      case Token.GET:
+      case Token.SET:
+        return true;
+    }
     return false;
   }
 
@@ -1616,13 +2309,14 @@
    * @param charno The source character offset from start of the line.
    * @return A NAME or GETPROP node
    */
-  public static Node newQualifiedNameNode(String name, int lineno, int charno) {
+  public static Node newQualifiedNameNode(
+      CodingConvention convention, String name, int lineno, int charno) {
     int endPos = name.indexOf('.');
     if (endPos == -1) {
-      return Node.newString(Token.NAME, name, lineno, charno);
+      return newName(convention, name, lineno, charno);
     }
-    Node node = Node.newString(Token.NAME, name.substring(0, endPos),
-                               lineno, charno);
+    Node node = newName(
+        convention, name.substring(0, endPos), lineno, charno);
     int startPos;
     do {
       startPos = endPos + 1;
@@ -1630,9 +2324,11 @@
       String part = (endPos == -1
                      ? name.substring(startPos)
                      : name.substring(startPos, endPos));
-      node = new Node(Token.GETPROP, node,
-                      Node.newString(Token.STRING, part, lineno, charno),
-                      lineno, charno);
+      Node propNode = Node.newString(Token.STRING, part, lineno, charno);
+      if (convention.isConstantKey(part)) {
+        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+      }
+      node = new Node(Token.GETPROP, node, propNode, lineno, charno);
     } while (endPos != -1);
 
     return node;
@@ -1651,9 +2347,10 @@
    *
    * @return A NAME or GETPROP node
    */
-  static Node newQualifiedNameNode(String name, Node basisNode,
+  static Node newQualifiedNameNode(
+      CodingConvention convention, String name, Node basisNode,
       String originalName) {
-    Node node = newQualifiedNameNode(name, -1, -1);
+    Node node = newQualifiedNameNode(convention, name, -1, -1);
     setDebugInformation(node, basisNode, originalName);
     return node;
   }
@@ -1661,7 +2358,7 @@
   /**
    * Gets the root node of a qualified name. Must be either NAME or THIS.
    */
-  static Node getRootOfQualifiedName(Node qName) {
+  public static Node getRootOfQualifiedName(Node qName) {
     for (Node current = qName; true;
          current = current.getFirstChild()) {
       int type = current.getType();
@@ -1686,6 +2383,15 @@
     node.putProp(Node.ORIGINALNAME_PROP, originalName);
   }
 
+  private static Node newName(
+      CodingConvention convention, String name, int lineno, int charno) {
+    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);
+    if (convention.isConstant(name)) {
+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+    }
+    return nameNode;
+  }
+
   /**
    * Creates a new node representing an *existing* name, copying over the source
    * location information from the basis node.
@@ -1696,8 +2402,12 @@
    *
    * @return The node created.
    */
-  static Node newName(String name, Node basisNode) {
+  static Node newName(
+      CodingConvention convention, String name, Node basisNode) {
     Node nameNode = Node.newString(Token.NAME, name);
+    if (convention.isConstantKey(name)) {
+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+    }
     nameNode.copyInformationFrom(basisNode);
     return nameNode;
   }
@@ -1715,8 +2425,10 @@
    *
    * @return The node created.
    */
-  static Node newName(String name, Node basisNode, String originalName) {
-    Node nameNode = newName(name, basisNode);
+  static Node newName(
+      CodingConvention convention, String name,
+      Node basisNode, String originalName) {
+    Node nameNode = newName(convention, name, basisNode);
     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);
     return nameNode;
   }
@@ -1787,7 +2499,7 @@
     visitPreOrder(
         root,
         collector,
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
     return collector.vars.values();
   }
 
@@ -1841,7 +2553,6 @@
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
-    // TODO(johnlenz): Why this instead of the more common "undefined"?
     Node node = new Node(Token.VOID, Node.newNumber(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
@@ -1915,6 +2626,8 @@
     }
   }
 
+  static final Predicate<Node> MATCH_NOT_FUNCTION = new MatchNotFunction();
+
   /**
    * A predicate for matching statements without exiting the current scope.
    */
@@ -2074,10 +2787,10 @@
     * @param fnNode The function.
     * @return The Node containing the Function parameters.
     */
-  static Node getFnParameters(Node fnNode) {
-   // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]
-   Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
-   return fnNode.getFirstChild().getNext();
+  public static Node getFunctionParameters(Node fnNode) {
+    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]
+    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
+    return fnNode.getFirstChild().getNext();
   }
 
   /**
@@ -2138,7 +2851,7 @@
   /**
    * Get the JSDocInfo for a function.
    */
-  static JSDocInfo getFunctionInfo(Node n) {
+  public static JSDocInfo getFunctionJSDocInfo(Node n) {
     Preconditions.checkState(n.getType() == Token.FUNCTION);
     JSDocInfo fnInfo = n.getJSDocInfo();
     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {
@@ -2159,10 +2872,10 @@
    * @param n The node.
    * @return The source name property on the node or its ancestors.
    */
-  static String getSourceName(Node n) {
+  public static String getSourceName(Node n) {
     String sourceName = null;
     while (sourceName == null && n != null) {
-      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
+      sourceName = n.getSourceFileName();
       n = n.getParent();
     }
     return sourceName;
@@ -2172,7 +2885,7 @@
    * A new CALL node with the "FREE_CALL" set based on call target.
    */
   static Node newCallNode(Node callTarget, Node... parameters) {
-    boolean isFreeCall = isName(callTarget);
+    boolean isFreeCall = !isGet(callTarget);
     Node call = new Node(Token.CALL, callTarget);
     call.putBooleanProp(Node.FREE_CALL, isFreeCall);
     for (Node parameter : parameters) {
@@ -2180,4 +2893,126 @@
     }
     return call;
   }
+
+  /**
+   * @return Whether the node is known to be a value that is not referenced
+   * elsewhere.
+   */
+  static boolean evaluatesToLocalValue(Node value) {
+    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());
+  }
+
+  /**
+   * @param locals A predicate to apply to unknown local values.
+   * @return Whether the node is known to be a value that is not a reference
+   *     outside the expression scope.
+   */
+  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
+    switch (value.getType()) {
+      case Token.ASSIGN:
+        // A result that is aliased by a non-local name, is the effectively the
+        // same as returning a non-local name, but this doesn't matter if the
+        // value is immutable.
+        return NodeUtil.isImmutableValue(value.getLastChild())
+            || (locals.apply(value)
+                && evaluatesToLocalValue(value.getLastChild(), locals));
+      case Token.COMMA:
+        return evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.AND:
+      case Token.OR:
+        return evaluatesToLocalValue(value.getFirstChild(), locals)
+           && evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.HOOK:
+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
+           && evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.INC:
+      case Token.DEC:
+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
+          return evaluatesToLocalValue(value.getFirstChild(), locals);
+        } else {
+          return true;
+        }
+      case Token.THIS:
+        return locals.apply(value);
+      case Token.NAME:
+        return isImmutableValue(value) || locals.apply(value);
+      case Token.GETELEM:
+      case Token.GETPROP:
+        // There is no information about the locality of object properties.
+        return locals.apply(value);
+      case Token.CALL:
+        return callHasLocalResult(value)
+            || isToStringMethodCall(value)
+            || locals.apply(value);
+      case Token.NEW:
+        return newHasLocalResult(value)
+               || locals.apply(value);
+      case Token.FUNCTION:
+      case Token.REGEXP:
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // Literals objects with non-literal children are allowed.
+        return true;
+      case Token.DELPROP:
+      case Token.IN:
+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
+        return true;
+      default:
+        // Other op force a local value:
+        //  x = '' + g (x is now an local string)
+        //  x -= g (x is now an local number)
+        if (isAssignmentOp(value)
+            || isSimpleOperator(value)
+            || isImmutableValue(value)) {
+          return true;
+        }
+
+        throw new IllegalStateException(
+            "Unexpected expression node" + value +
+            "\n parent:" + value.getParent());
+    }
+  }
+
+  /**
+   * Given the first sibling, this returns the nth
+   * sibling or null if no such sibling exists.
+   * This is like "getChildAtIndex" but returns null for non-existent indexes.
+   */
+  private static Node getNthSibling(Node first, int index) {
+    Node sibling = first;
+    while (index != 0 && sibling != null) {
+      sibling = sibling.getNext();
+      index--;
+    }
+    return sibling;
+  }
+
+  /**
+   * Given the function, this returns the nth
+   * argument or null if no such parameter exists.
+   */
+  static Node getArgumentForFunction(Node function, int index) {
+    Preconditions.checkState(isFunction(function));
+    return getNthSibling(
+        function.getFirstChild().getNext().getFirstChild(), index);
+  }
+
+  /**
+   * Given the new or call, this returns the nth
+   * argument of the call or null if no such argument exists.
+   */
+  static Node getArgumentForCallOrNew(Node call, int index) {
+    Preconditions.checkState(isCallOrNew(call));
+    return getNthSibling(
+      call.getFirstChild().getNext(), index);
+  }
+
+  private static boolean isToStringMethodCall(Node call) {
+    Node getNode = call.getFirstChild();
+    if (isGet(getNode)) {
+      Node propNode = getNode.getLastChild();
+      return isString(propNode) && "toString".equals(propNode.getString());
+    }
+    return false;
+  }
 }
diff -r -u inducing/test/com/google/javascript/jscomp/CommandLineRunnerTest.java buggy/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
--- inducing/test/com/google/javascript/jscomp/CommandLineRunnerTest.java	2023-06-12 11:40:22.970876600 +0800
+++ buggy/test/com/google/javascript/jscomp/CommandLineRunnerTest.java	2023-06-12 11:40:22.758886457 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 Google Inc.
+ * Copyright 2009 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,9 +18,12 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.rhino.Node;
 
 import junit.framework.TestCase;
@@ -42,6 +45,10 @@
   private ByteArrayOutputStream outReader = null;
   private ByteArrayOutputStream errReader = null;
 
+  // If set, this will be appended to the end of the args list.
+  // For testing args parsing.
+  private String lastArg = null;
+
   // If set to true, uses comparison by string instead of by AST.
   private boolean useStringComparison = false;
 
@@ -56,22 +63,46 @@
   private List<String> args = Lists.newArrayList();
 
   /** Externs for the test */
-  private final List<JSSourceFile> externs = Lists.newArrayList(
+  private final List<JSSourceFile> DEFAULT_EXTERNS = ImmutableList.of(
     JSSourceFile.fromCode("externs",
         "var arguments;"
-        + "/** @constructor \n * @param {...*} var_args \n "
-        + "* @return {!Array} */ "
-        + "function Array(var_args) {}\n"
+        + "/**\n"
+        + " * @constructor\n"
+        + " * @param {...*} var_args\n"
+        + " */\n"
+        + "function Function(var_args) {}\n"
+        + "/**\n"
+        + " * @param {...*} var_args\n"
+        + " * @return {*}\n"
+        + " */\n"
+        + "Function.prototype.call = function(var_args) {};"
+        + "/**\n"
+        + " * @constructor\n"
+        + " * @param {...*} var_args\n"
+        + " * @return {!Array}\n"
+        + " */\n"
+        + "function Array(var_args) {}"
+        + "/**\n"
+        + " * @param {*=} opt_begin\n"
+        + " * @param {*=} opt_end\n"
+        + " * @return {!Array}\n"
+        + " * @this {Object}\n"
+        + " */\n"
+        + "Array.prototype.slice = function(opt_begin, opt_end) {};"
         + "/** @constructor */ function Window() {}\n"
         + "/** @type {string} */ Window.prototype.name;\n"
         + "/** @type {Window} */ var window;"
         + "/** @nosideeffects */ function noSideEffects() {}")
   );
 
+  private List<JSSourceFile> externs;
+
   @Override
   public void setUp() throws Exception {
     super.setUp();
+    externs = DEFAULT_EXTERNS;
     lastCompiler = null;
+    lastArg = null;
     outReader = new ByteArrayOutputStream();
     errReader = new ByteArrayOutputStream();
     useStringComparison = false;
@@ -85,16 +116,82 @@
     super.tearDown();
   }
 
+  public void testWarningGuardOrdering1() {
+    args.add("--jscomp_error=globalThis");
+    args.add("--jscomp_off=globalThis");
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testWarningGuardOrdering2() {
+    args.add("--jscomp_off=globalThis");
+    args.add("--jscomp_error=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testWarningGuardOrdering3() {
+    args.add("--jscomp_warning=globalThis");
+    args.add("--jscomp_off=globalThis");
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testWarningGuardOrdering4() {
+    args.add("--jscomp_off=globalThis");
+    args.add("--jscomp_warning=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testCheckGlobalThisOffByDefault() {
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testCheckGlobalThisOnWithAdvancedMode() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testCheckGlobalThisOnWithErrorFlag() {
+    args.add("--jscomp_error=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
   public void testTypeCheckingOffByDefault() {
     test("function f(x) { return x; } f();",
          "function f(a) { return a; } f();");
   }
 
+  public void testReflectedMethods() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test(
+        "/** @constructor */" +
+        "function Foo() {}" +
+        "Foo.prototype.handle = function(x, y) { alert(y); };" +
+        "var x = goog.reflect.object(Foo, {handle: 1});" +
+        "for (var i in x) { x[i].call(x); }" +
+        "window['Foo'] = Foo;",
+        "function a() {}" +
+        "a.prototype.a = function(e, d) { alert(d); };" +
+        "var b = goog.c.b(a, {a: 1}),c;" +
+        "for (c in b) { b[c].call(b); }" +
+        "window.Foo = a;");
+  }
+
   public void testTypeCheckingOnWithVerbose() {
     args.add("--warning_level=VERBOSE");
     test("function f(x) { return x; } f();", TypeCheck.WRONG_ARGUMENT_COUNT);
   }
 
+  public void testTypeParsingOffByDefault() {
+    testSame("/** @return {number */ function f(a) { return a; }");
+  }
+
+  public void testTypeParsingOnWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @return {number */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+    test("/** @return {n} */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+  }
+
   public void testTypeCheckOverride1() {
     args.add("--warning_level=VERBOSE");
     args.add("--jscomp_off=checkTypes");
@@ -127,14 +224,32 @@
     testSame("x = 3;");
   }
 
-  public void testCheckUndefinedProperties() {
+  public void testCheckSymbolsOverrideForQuiet() {
+    args.add("--warning_level=QUIET");
+    args.add("--jscomp_error=undefinedVars");
+    test("x = 3;", VarCheck.UNDEFINED_VAR_ERROR);
+  }
+
+  public void testCheckUndefinedProperties1() {
     args.add("--warning_level=VERBOSE");
     args.add("--jscomp_error=missingProperties");
     test("var x = {}; var y = x.bar;", TypeCheck.INEXISTENT_PROPERTY);
   }
 
+  public void testCheckUndefinedProperties2() {
+    args.add("--warning_level=VERBOSE");
+    args.add("--jscomp_off=missingProperties");
+    test("var x = {}; var y = x.bar;", CheckGlobalNames.UNDEFINED_NAME_WARNING);
+  }
+
+  public void testCheckUndefinedProperties3() {
+    args.add("--warning_level=VERBOSE");
+    test("function f() {var x = {}; var y = x.bar;}",
+        TypeCheck.INEXISTENT_PROPERTY);
+  }
+
   public void testDuplicateParams() {
-    test("function (a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM);
+    test("function f(a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM);
     assertTrue(lastCompiler.hasHaltingErrors());
   }
 
@@ -147,7 +262,7 @@
          "/** @define {number} */ var BAR = 3;" +
          "/** @define {boolean} */ var CCC = false;" +
          "/** @define {boolean} */ var DDD = false;",
-         "var FOO = true, BAR = 5, CCC = true, DDD = true;");
+         "var FOO = !0, BAR = 5, CCC = !0, DDD = !0;");
   }
 
   public void testDefineFlag2() {
@@ -175,19 +290,36 @@
 
   public void testQuietMode() {
     args.add("--warning_level=DEFAULT");
-    test("/** @type { not a type name } */ var x;",
+    test("/** @const \n * @const */ var x;",
          RhinoErrorReporter.PARSE_ERROR);
     args.add("--warning_level=QUIET");
-    testSame("/** @type { not a type name } */ var x;");
+    testSame("/** @const \n * @const */ var x;");
   }
 
   public void testProcessClosurePrimitives() {
     test("var goog = {}; goog.provide('goog.dom');",
-         "var goog = {}; goog.dom = {};");
+         "var goog = {dom:{}};");
     args.add("--process_closure_primitives=false");
     testSame("var goog = {}; goog.provide('goog.dom');");
   }
 
+  public void testCssNameWiring() throws Exception {
+    test("var goog = {}; goog.getCssName = function() {};" +
+         "goog.setCssNameMapping = function() {};" +
+         "goog.setCssNameMapping({'goog': 'a', 'button': 'b'});" +
+         "var a = goog.getCssName('goog-button');" +
+         "var b = goog.getCssName('css-button');" +
+         "var c = goog.getCssName('goog-menu');" +
+         "var d = goog.getCssName('css-menu');",
+         "var goog = { getCssName: function() {}," +
+         "             setCssNameMapping: function() {} }," +
+         "    a = 'a-b'," +
+         "    b = 'css-b'," +
+         "    c = 'a-menu'," +
+         "    d = 'css-menu';");
+  }
+
+
   //////////////////////////////////////////////////////////////////////////////
   // Integration tests
 
@@ -204,6 +336,7 @@
 
   public void testIssue115() {
     args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    args.add("--jscomp_off=es5Strict");
     args.add("--warning_level=VERBOSE");
     test("function f() { " +
          "  var arguments = Array.prototype.slice.call(arguments, 0);" +
@@ -215,6 +348,18 @@
          "}");
   }
 
+  public void testIssue297() {
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    test("function f(p) {" +
+         " var x;" +
+         " return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);" +
+         "}",
+         "function f(b) {" +
+         " var a;" +
+         " return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);" +
+         "}");
+  }
+
   public void testDebugFlag1() {
     args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
     args.add("--debug=false");
@@ -249,6 +394,20 @@
         "throw (new function Foo() {}).$x$;");
   }
 
+  public void testBooleanFlag1() {
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    args.add("--debug");
+    test("function foo(a) {alert(a)}",
+         "function foo($a$$) {alert($a$$)}");
+  }
+
+  public void testBooleanFlag2() {
+    args.add("--debug");
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    test("function foo(a) {alert(a)}",
+         "function foo($a$$) {alert($a$$)}");
+  }
+
   public void testHelpFlag() {
     args.add("--help");
     assertFalse(
@@ -325,7 +484,7 @@
          JSModule.CIRCULAR_DEPENDENCY_ERROR);
   }
 
-  public void testSourcePruningOn() {
+  public void testSourcePruningOn1() {
     args.add("--manage_closure_dependencies=true");
     test(new String[] {
           "goog.require('beer');",
@@ -338,6 +497,70 @@
          });
   }
 
+  public void testSourcePruningOn2() {
+    args.add("--closure_entry_point=guinness");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "var guinness = {};"
+         });
+  }
+
+  public void testSourcePruningOn3() {
+    args.add("--closure_entry_point=scotch");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+  public void testSourcePruningOn4() {
+    args.add("--closure_entry_point=scotch");
+    args.add("--closure_entry_point=beer");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+  public void testSourcePruningOn5() {
+    args.add("--closure_entry_point=shiraz");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         Compiler.MISSING_ENTRY_ERROR);
+  }
+
+  public void testSourcePruningOn6() {
+    args.add("--closure_entry_point=scotch");
+    test(new String[] {
+          "goog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "",
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+
   public void testForwardDeclareDroppedTypes() {
     args.add("--manage_closure_dependencies=true");
 
@@ -360,7 +583,7 @@
            "var beer = {}; function f() {}",
            ""
          },
-         RhinoErrorReporter.PARSE_ERROR);
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
   }
 
   public void testSourceMapExpansion1() {
@@ -394,6 +617,14 @@
             lastCompiler.getModuleGraph().getRootModule()));
   }
 
+  public void testSourceMapFormat1() {
+    args.add("--js_output_file");
+    args.add("/path/to/out.js");
+    testSame("var x = 3;");
+    assertEquals(SourceMap.Format.DEFAULT,
+        lastCompiler.getOptions().sourceMapFormat);
+  }
+
   public void testCharSetExpansion() {
     testSame("");
     assertEquals("US-ASCII", lastCompiler.getOptions().outputCharset);
@@ -408,8 +639,8 @@
           "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"});
 
     StringBuilder builder = new StringBuilder();
-    lastCommandLineRunner.printModuleGraphManifestTo(
-        lastCompiler.getModuleGraph(), builder);
+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(
+        lastCompiler.getModuleGraph(), builder, true);
     assertEquals(
         "{m0}\n" +
         "i0\n" +
@@ -431,8 +662,8 @@
           "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"});
 
     StringBuilder builder = new StringBuilder();
-    lastCommandLineRunner.printModuleGraphManifestTo(
-        lastCompiler.getModuleGraph(), builder);
+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(
+        lastCompiler.getModuleGraph(), builder, true);
     assertEquals(
         "{m0}\n" +
         "i0\n" +
@@ -455,8 +686,17 @@
         0,
         new String(errReader.toByteArray()).indexOf(
             "Closure Compiler (http://code.google.com/closure/compiler)\n" +
-            "Version: HEAD\n" +
-            "Built on:"));
+            "Version: "));
+  }
+
+  public void testVersionFlag2() {
+    lastArg = "--version";
+    testSame("");
+    assertEquals(
+        0,
+        new String(errReader.toByteArray()).indexOf(
+            "Closure Compiler (http://code.google.com/closure/compiler)\n" +
+            "Version: "));
   }
 
   public void testPrintAstFlag() {
@@ -468,13 +708,102 @@
         "  node0 [label=\"BLOCK\"];\n" +
         "  node1 [label=\"SCRIPT\"];\n" +
         "  node0 -> node1 [weight=1];\n" +
-        "  node1 -> RETURN [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
-        "  node0 -> RETURN [label=\"SYN_BLOCK\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
-        "  node0 -> node1 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node1 -> RETURN [label=\"UNCOND\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node0 -> RETURN [label=\"SYN_BLOCK\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node0 -> node1 [label=\"UNCOND\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
         "}\n\n",
         new String(outReader.toByteArray()));
   }
 
+  public void testSyntheticExterns() {
+    externs = ImmutableList.of(
+        JSSourceFile.fromCode("externs", "myVar.property;"));
+    test("var theirVar = {}; var myVar = {}; var yourVar = {};",
+         VarCheck.UNDEFINED_EXTERN_VAR_ERROR);
+
+    args.add("--jscomp_off=externsValidation");
+    args.add("--warning_level=VERBOSE");
+    test("var theirVar = {}; var myVar = {}; var yourVar = {};",
+         "var theirVar={},myVar={},yourVar={};");
+
+    args.add("--jscomp_off=externsValidation");
+    args.add("--warning_level=VERBOSE");
+    test("var theirVar = {}; var myVar = {}; var myVar = {};",
+         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);
+  }
+
+  public void testGoogAssertStripping() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("goog.asserts.assert(false)",
+         "");
+    args.add("--debug");
+    test("goog.asserts.assert(false)", "goog.$asserts$.$assert$(!1)");
+  }
+
+  public void testMissingReturnCheckOnWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @return {number} */ function f() {f()} f();",
+        CheckMissingReturn.MISSING_RETURN_STATEMENT);
+  }
+
+  public void testGenerateExports() {
+    args.add("--generate_exports=true");
+    test("/** @export */ foo.prototype.x = function() {};",
+        "foo.prototype.x=function(){};"+
+        "goog.exportSymbol(\"foo.prototype.x\",foo.prototype.x);");
+  }
+
+  public void testDepreciationWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @deprecated */ function f() {}; f()",
+       CheckAccessControls.DEPRECATED_NAME);
+  }
+
+  public void testTwoParseErrors() {
+    // If parse errors are reported in different files, make
+    // sure all of them are reported.
+    Compiler compiler = compile(new String[] {
+      "var a b;",
+      "var b c;"
+    });
+    assertEquals(2, compiler.getErrors().length);
+  }
+
+  public void testES3ByDefault() {
+    test("var x = f.function", RhinoErrorReporter.PARSE_ERROR);
+  }
+
+  public void testES5() {
+    args.add("--language_in=ECMASCRIPT5");
+    test("var x = f.function", "var x = f.function");
+    test("var let", "var let");
+  }
+
+  public void testES5Strict() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    test("var x = f.function", "'use strict';var x = f.function");
+    test("var let", RhinoErrorReporter.PARSE_ERROR);
+  }
+
+  public void testES5StrictUseStrict() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    Compiler compiler = compile(new String[] {"var x = f.function"});
+    String outputSource = compiler.toSource();
+    assertEquals("'use strict'", outputSource.substring(0, 12));
+  }
+
+  public void testES5StrictUseStrictMultipleInputs() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    Compiler compiler = compile(new String[] {"var x = f.function",
+        "var y = f.function", "var z = f.function"});
+    String outputSource = compiler.toSource();
+    assertEquals("'use strict'", outputSource.substring(0, 12));
+    assertEquals(outputSource.substring(13).indexOf("'use strict'"), -1);
+  }
+
   /* Helper functions */
 
   private void testSame(String original) {
@@ -573,6 +902,10 @@
       }
     }
 
+    if (lastArg != null) {
+      args.add(lastArg);
+    }
+
     String[] argStrings = args.toArray(new String[] {});
     return new CommandLineRunner(
         argStrings,
@@ -628,8 +961,13 @@
     for (int i = 0; i < original.length; i++) {
       inputs.add(JSSourceFile.fromCode("input" + i, original[i]));
     }
-    compiler.init(externs, inputs, new CompilerOptions());
+    CompilerOptions options = new CompilerOptions();
+    // ECMASCRIPT5 is the most forgiving.
+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);
+    compiler.init(externs, inputs, options);
     Node all = compiler.parseInputs();
+    Preconditions.checkState(compiler.getErrorCount() == 0);
+    Preconditions.checkNotNull(all);
     Node n = all.getLastChild();
     return n;
   }
diff -r -u inducing/test/com/google/javascript/jscomp/NodeUtilTest.java buggy/test/com/google/javascript/jscomp/NodeUtilTest.java
--- inducing/test/com/google/javascript/jscomp/NodeUtilTest.java	2023-06-12 11:40:22.970876600 +0800
+++ buggy/test/com/google/javascript/jscomp/NodeUtilTest.java	2023-06-12 11:40:22.758886457 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,12 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.TernaryValue;
@@ -33,6 +36,8 @@
 
   private static Node parse(String js) {
     Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT5);
     Node n = compiler.parseTestCode(js);
     assertEquals(0, compiler.getErrorCount());
     return n;
@@ -99,18 +104,24 @@
     assertBooleanFalse("void foo()");
     assertBooleanUnknown("b");
     assertBooleanUnknown("-'0.0'");
+
+    // Known but getBooleanValue return false for expressions with side-effects
+    assertBooleanUnknown("{a:foo()}");
+    assertBooleanUnknown("[foo()]");
   }
 
   private void assertBooleanTrue(String val) {
-    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));
+    assertEquals(TernaryValue.TRUE, NodeUtil.getPureBooleanValue(getNode(val)));
   }
 
   private void assertBooleanFalse(String val) {
-    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));
+    assertEquals(
+        TernaryValue.FALSE, NodeUtil.getPureBooleanValue(getNode(val)));
   }
 
   private void assertBooleanUnknown(String val) {
-    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));
+    assertEquals(
+        TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val)));
   }
 
   public void testGetExpressionBooleanValue() {
@@ -167,24 +178,27 @@
     assertExpressionBooleanFalse("a?false:false");
     assertExpressionBooleanUnknown("a?true:false");
     assertExpressionBooleanUnknown("a?true:foo()");
-    
+
     assertExpressionBooleanUnknown("b");
     assertExpressionBooleanUnknown("-'0.0'");
+
+    assertExpressionBooleanTrue("{a:foo()}");
+    assertExpressionBooleanTrue("[foo()]");
   }
 
   private void assertExpressionBooleanTrue(String val) {
     assertEquals(TernaryValue.TRUE,
-        NodeUtil.getExpressionBooleanValue(getNode(val)));
+        NodeUtil.getImpureBooleanValue(getNode(val)));
   }
 
   private void assertExpressionBooleanFalse(String val) {
     assertEquals(TernaryValue.FALSE,
-        NodeUtil.getExpressionBooleanValue(getNode(val)));
+        NodeUtil.getImpureBooleanValue(getNode(val)));
   }
 
   private void assertExpressionBooleanUnknown(String val) {
     assertEquals(TernaryValue.UNKNOWN,
-        NodeUtil.getExpressionBooleanValue(getNode(val)));
+        NodeUtil.getImpureBooleanValue(getNode(val)));
   }
 
   public void testGetStringValue() {
@@ -193,8 +207,8 @@
     assertEquals("1", NodeUtil.getStringValue(getNode("1.0")));
     assertEquals("0", NodeUtil.getStringValue(getNode("'0'")));
     assertEquals(null, NodeUtil.getStringValue(getNode("/a/")));
-    assertEquals(null, NodeUtil.getStringValue(getNode("{}")));
-    assertEquals(null, NodeUtil.getStringValue(getNode("[]")));
+    assertEquals("[object Object]", NodeUtil.getStringValue(getNode("{}")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[]")));
     assertEquals("false", NodeUtil.getStringValue(getNode("false")));
     assertEquals("null", NodeUtil.getStringValue(getNode("null")));
     assertEquals("0", NodeUtil.getStringValue(getNode("0")));
@@ -202,6 +216,56 @@
     assertEquals("undefined", NodeUtil.getStringValue(getNode("undefined")));
     assertEquals("undefined", NodeUtil.getStringValue(getNode("void 0")));
     assertEquals("undefined", NodeUtil.getStringValue(getNode("void foo()")));
+
+    assertEquals("NaN", NodeUtil.getStringValue(getNode("NaN")));
+    assertEquals("Infinity", NodeUtil.getStringValue(getNode("Infinity")));
+    assertEquals(null, NodeUtil.getStringValue(getNode("x")));
+  }
+
+  public void testGetArrayStringValue() {
+    assertEquals("", NodeUtil.getStringValue(getNode("[]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("['']")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[null]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[undefined]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[void 0]")));
+    assertEquals("NaN", NodeUtil.getStringValue(getNode("[NaN]")));
+    assertEquals(",", NodeUtil.getStringValue(getNode("[,'']")));
+    assertEquals(",,", NodeUtil.getStringValue(getNode("[[''],[''],['']]")));
+    assertEquals("1,2", NodeUtil.getStringValue(getNode("[[1.0],[2.0]]")));
+    assertEquals(null, NodeUtil.getStringValue(getNode("[a]")));
+    assertEquals(null, NodeUtil.getStringValue(getNode("[1,a]")));
+  }
+
+  public void testIsObjectLiteralKey1() throws Exception {
+    testIsObjectLiteralKey(
+      parseExpr("({})"), false);
+    testIsObjectLiteralKey(
+      parseExpr("a"), false);
+    testIsObjectLiteralKey(
+      parseExpr("'a'"), false);
+    testIsObjectLiteralKey(
+      parseExpr("1"), false);
+    testIsObjectLiteralKey(
+      parseExpr("({a: 1})").getFirstChild(), true);
+    testIsObjectLiteralKey(
+      parseExpr("({1: 1})").getFirstChild(), true);
+    testIsObjectLiteralKey(
+      parseExpr("({get a(){}})").getFirstChild(), true);
+    testIsObjectLiteralKey(
+      parseExpr("({set a(b){}})").getFirstChild(), true);
+  }
+
+  private Node parseExpr(String js) {
+    Compiler compiler = new Compiler();
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);
+    compiler.initOptions(options);
+    Node root = compiler.parseTestCode(js);
+    return root.getFirstChild().getFirstChild();
+  }
+
+  private void testIsObjectLiteralKey(Node node, boolean expected) {
+    assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent()));
   }
 
   public void testGetFunctionName1() throws Exception {
@@ -340,6 +404,19 @@
     assertSideEffect(false, "-Infinity");
     assertSideEffect(false, "Infinity");
     assertSideEffect(false, "NaN");
+
+    assertSideEffect(false, "({}||[]).foo = 2;");
+    assertSideEffect(false, "(true ? {} : []).foo = 2;");
+    assertSideEffect(false, "({},[]).foo = 2;");
+  }
+
+  public void testObjectMethodSideEffects() {
+    // "toString" and "valueOf" are assumed to be side-effect free
+    assertSideEffect(false, "o.toString()");
+    assertSideEffect(false, "o.valueOf()");
+
+    // other methods depend on the extern definitions
+    assertSideEffect(true, "o.watch()");
   }
 
   public void testRegExpSideEffect() {
@@ -486,6 +563,7 @@
     Node function = NodeUtil.newFunctionNode(
         "foo", params, body, -1, -1);
     Node actual = new Node(Token.SCRIPT);
+    actual.setIsSyntheticBlock(true);
     actual.addChildToFront(function);
     String difference = expected.checkTreeEquals(actual);
     if (difference != null) {
@@ -541,15 +619,21 @@
   public void testReferencesThis() {
     assertTrue(NodeUtil.referencesThis(
         parse("this")));
-    assertTrue(NodeUtil.referencesThis(
-        parse("function foo(){}(this)")));
+    // Don't descend into functions (starts at the script node)
+    assertFalse(NodeUtil.referencesThis(
+        parse("function foo(){this}")));
+    // But starting with a function properly check for 'this'
+    Node n = parse("function foo(){this}").getFirstChild();
+    assertEquals(n.getType(), Token.FUNCTION);
+    assertTrue(NodeUtil.referencesThis(n));
     assertTrue(NodeUtil.referencesThis(
         parse("b?this:null")));
 
     assertFalse(NodeUtil.referencesThis(
         parse("a")));
-    assertFalse(NodeUtil.referencesThis(
-        parse("function foo(){}")));
+    n = parse("function foo(){}").getFirstChild();
+    assertEquals(n.getType(), Token.FUNCTION);
+    assertFalse(NodeUtil.referencesThis(n));
     assertFalse(NodeUtil.referencesThis(
         parse("(b?foo():null)")));
   }
@@ -617,10 +701,10 @@
             parse("foo();")));
     assertNodeNames(Sets.<String>newHashSet(),
         NodeUtil.getVarsDeclaredInBranch(
-            parse("function(){var foo;}")));
+            parse("function f(){var foo;}")));
     assertNodeNames(Sets.newHashSet("goo"),
         NodeUtil.getVarsDeclaredInBranch(
-            parse("var goo;function(){var foo;}")));
+            parse("var goo;function f(){var foo;}")));
   }
 
   private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) {
@@ -632,8 +716,6 @@
   }
 
   public void testIsControlStructureCodeBlock() {
-    Compiler compiler = new Compiler();
-
     Node root = parse("if (x) foo(); else boo();");
     Node ifNode = root.getFirstChild();
 
@@ -647,8 +729,6 @@
   }
 
   public void testIsFunctionExpression1() {
-    Compiler compiler = new Compiler();
-
     Node root = parse("(function foo() {})");
     Node StatementNode = root.getFirstChild();
     assertTrue(NodeUtil.isExpressionNode(StatementNode));
@@ -658,21 +738,31 @@
   }
 
   public void testIsFunctionExpression2() {
-    Compiler compiler = new Compiler();
-
     Node root = parse("function foo() {}");
     Node functionNode = root.getFirstChild();
     assertTrue(NodeUtil.isFunction(functionNode));
     assertFalse(NodeUtil.isFunctionExpression(functionNode));
   }
 
-  public void testRemoveTryChild() {
-    Compiler compiler = new Compiler();
+  public void testRemoveChildBlock() {
+    // Test removing the inner block.
+    Node actual = parse("{{x()}}");
+
+    Node outerBlockNode = actual.getFirstChild();
+    Node innerBlockNode = outerBlockNode.getFirstChild();
+    innerBlockNode.setIsSyntheticBlock(true);
 
-    Node root = parse("try {foo()} catch(e) {} finally {}");
+    NodeUtil.removeChild(outerBlockNode, innerBlockNode);
+    String expected = "{{}}";
+    String difference = parse(expected).checkTreeEquals(actual);
+    if (difference != null) {
+      assertTrue("Nodes do not match:\n" + difference, false);
+    }
+  }
 
+  public void testRemoveTryChild1() {
     // Test removing the finally clause.
-    Node actual = root.cloneTree();
+    Node actual = parse("try {foo()} catch(e) {} finally {}");
 
     Node tryNode = actual.getFirstChild();
     Node tryBlock = tryNode.getFirstChild();
@@ -685,38 +775,75 @@
     if (difference != null) {
       assertTrue("Nodes do not match:\n" + difference, false);
     }
+  }
 
+  public void testRemoveTryChild2() {
     // Test removing the try clause.
-    actual = root.cloneTree();
+    Node actual = parse("try {foo()} catch(e) {} finally {}");
 
-    tryNode = actual.getFirstChild();
-    tryBlock = tryNode.getFirstChild();
-    catchBlocks = tryNode.getFirstChild().getNext();
-    finallyBlock = tryNode.getLastChild();
+    Node tryNode = actual.getFirstChild();
+    Node tryBlock = tryNode.getFirstChild();
+    Node catchBlocks = tryNode.getFirstChild().getNext();
 
     NodeUtil.removeChild(tryNode, tryBlock);
-    expected = "try {} catch(e) {} finally {}";
-    difference = parse(expected).checkTreeEquals(actual);
+    String expected = "try {} catch(e) {} finally {}";
+    String difference = parse(expected).checkTreeEquals(actual);
     if (difference != null) {
       assertTrue("Nodes do not match:\n" + difference, false);
     }
+  }
 
+  public void testRemoveTryChild3() {
     // Test removing the catch clause.
-    actual = root.cloneTree();
+    Node actual = parse("try {foo()} catch(e) {} finally {}");
 
-    tryNode = actual.getFirstChild();
-    tryBlock = tryNode.getFirstChild();
-    catchBlocks = tryNode.getFirstChild().getNext();
+    Node tryNode = actual.getFirstChild();
+    Node tryBlock = tryNode.getFirstChild();
+    Node catchBlocks = tryNode.getFirstChild().getNext();
     Node catchBlock = catchBlocks.getFirstChild();
-    finallyBlock = tryNode.getLastChild();
+    Node finallyBlock = tryNode.getLastChild();
 
     NodeUtil.removeChild(catchBlocks, catchBlock);
-    expected = "try {foo()} finally {}";
-    difference = parse(expected).checkTreeEquals(actual);
+    String expected = "try {foo()} finally {}";
+    String difference = parse(expected).checkTreeEquals(actual);
     if (difference != null) {
       assertTrue("Nodes do not match:\n" + difference, false);
     }
+  }
+
+  public void testRemoveTryChild4() {
+    // Test removing the catch clause without a finally.
+    Node actual = parse("try {foo()} catch(e) {} finally {}");
 
+    Node tryNode = actual.getFirstChild();
+    Node tryBlock = tryNode.getFirstChild();
+    Node catchBlocks = tryNode.getFirstChild().getNext();
+    Node catchBlock = catchBlocks.getFirstChild();
+    Node finallyBlock = tryNode.getLastChild();
+
+    NodeUtil.removeChild(tryNode, catchBlocks);
+    String expected = "try {foo()} finally {}";
+    String difference = parse(expected).checkTreeEquals(actual);
+    if (difference != null) {
+      assertTrue("Nodes do not match:\n" + difference, false);
+    }
+  }
+
+  public void testRemoveTryChild5() {
+    Node actual = parse("try {foo()} catch(e) {} finally {}");
+
+    Node tryNode = actual.getFirstChild();
+    Node tryBlock = tryNode.getFirstChild();
+    Node catchBlocks = tryNode.getFirstChild().getNext();
+    Node catchBlock = catchBlocks.getFirstChild();
+    Node finallyBlock = tryNode.getLastChild();
+
+    NodeUtil.removeChild(catchBlocks, catchBlock);
+    String expected = "try {foo()} finally {}";
+    String difference = parse(expected).checkTreeEquals(actual);
+    if (difference != null) {
+      assertTrue("Nodes do not match:\n" + difference, false);
+    }
   }
 
   public void testRemoveVarChild() {
@@ -958,4 +1085,547 @@
     assertFalse(secondBreak.hasChildren());
     assertFalse(NodeUtil.isLabelName(secondBreak.getFirstChild()));
   }
+
+  public void testLocalValue1() throws Exception {
+    // Names are not known to be local.
+    assertFalse(testLocalValue("x"));
+    assertFalse(testLocalValue("x()"));
+    assertFalse(testLocalValue("this"));
+    assertFalse(testLocalValue("arguments"));
+
+    // We can't know if new objects are local unless we know
+    // that they don't alias themselves.
+    assertFalse(testLocalValue("new x()"));
+
+    // property references are assume to be non-local
+    assertFalse(testLocalValue("(new x()).y"));
+    assertFalse(testLocalValue("(new x())['y']"));
+
+    // Primitive values are local
+    assertTrue(testLocalValue("null"));
+    assertTrue(testLocalValue("undefined"));
+    assertTrue(testLocalValue("Infinity"));
+    assertTrue(testLocalValue("NaN"));
+    assertTrue(testLocalValue("1"));
+    assertTrue(testLocalValue("'a'"));
+    assertTrue(testLocalValue("true"));
+    assertTrue(testLocalValue("false"));
+    assertTrue(testLocalValue("[]"));
+    assertTrue(testLocalValue("{}"));
+
+    // The contents of arrays and objects don't matter
+    assertTrue(testLocalValue("[x]"));
+    assertTrue(testLocalValue("{'a':x}"));
+
+    // Pre-increment results in primitive number
+    assertTrue(testLocalValue("++x"));
+    assertTrue(testLocalValue("--x"));
+
+    // Post-increment, the previous value matters.
+    assertFalse(testLocalValue("x++"));
+    assertFalse(testLocalValue("x--"));
+
+    // The left side of an only assign matters if it is an alias or mutable.
+    assertTrue(testLocalValue("x=1"));
+    assertFalse(testLocalValue("x=[]"));
+    assertFalse(testLocalValue("x=y"));
+    // The right hand side of assignment opts don't matter, as they force
+    // a local result.
+    assertTrue(testLocalValue("x+=y"));
+    assertTrue(testLocalValue("x*=y"));
+    // Comparisons always result in locals, as they force a local boolean
+    // result.
+    assertTrue(testLocalValue("x==y"));
+    assertTrue(testLocalValue("x!=y"));
+    assertTrue(testLocalValue("x>y"));
+    // Only the right side of a comma matters
+    assertTrue(testLocalValue("(1,2)"));
+    assertTrue(testLocalValue("(x,1)"));
+    assertFalse(testLocalValue("(x,y)"));
+
+    // Both the operands of OR matter
+    assertTrue(testLocalValue("1||2"));
+    assertFalse(testLocalValue("x||1"));
+    assertFalse(testLocalValue("x||y"));
+    assertFalse(testLocalValue("1||y"));
+
+    // Both the operands of AND matter
+    assertTrue(testLocalValue("1&&2"));
+    assertFalse(testLocalValue("x&&1"));
+    assertFalse(testLocalValue("x&&y"));
+    assertFalse(testLocalValue("1&&y"));
+
+    // Only the results of HOOK matter
+    assertTrue(testLocalValue("x?1:2"));
+    assertFalse(testLocalValue("x?x:2"));
+    assertFalse(testLocalValue("x?1:x"));
+    assertFalse(testLocalValue("x?x:y"));
+
+    // Results of ops are local values
+    assertTrue(testLocalValue("!y"));
+    assertTrue(testLocalValue("~y"));
+    assertTrue(testLocalValue("y + 1"));
+    assertTrue(testLocalValue("y + z"));
+    assertTrue(testLocalValue("y * z"));
+
+    assertTrue(testLocalValue("'a' in x"));
+    assertTrue(testLocalValue("typeof x"));
+    assertTrue(testLocalValue("x instanceof y"));
+
+    assertTrue(testLocalValue("void x"));
+    assertTrue(testLocalValue("void 0"));
+
+    assertFalse(testLocalValue("{}.x"));
+
+    assertTrue(testLocalValue("{}.toString()"));
+    assertTrue(testLocalValue("o.toString()"));
+
+    assertFalse(testLocalValue("o.valueOf()"));
+
+    assertTrue(testLocalValue("delete a.b"));
+  }
+
+  public void testLocalValue2() {
+    Node newExpr = getNode("new x()");
+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    Preconditions.checkState(newExpr.getType() == Token.NEW);
+    Node.SideEffectFlags flags = new Node.SideEffectFlags();
+
+    flags.clearAllFlags();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    flags.clearAllFlags();
+    flags.setMutatesThis();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    flags.clearAllFlags();
+    flags.setReturnsTainted();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    flags.clearAllFlags();
+    flags.setThrows();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    flags.clearAllFlags();
+    flags.setMutatesArguments();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));
+
+    flags.clearAllFlags();
+    flags.setMutatesGlobalState();
+    newExpr.setSideEffectFlags(flags.valueOf());
+
+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));
+  }
+
+  public void testCallSideEffects() {
+    Node callExpr = getNode("new x().method()");
+    assertTrue(NodeUtil.functionCallHasSideEffects(callExpr));
+
+    Node newExpr = callExpr.getFirstChild().getFirstChild();
+    Preconditions.checkState(newExpr.getType() == Token.NEW);
+    Node.SideEffectFlags flags = new Node.SideEffectFlags();
+
+    // No side effects, local result
+    flags.clearAllFlags();
+    newExpr.setSideEffectFlags(flags.valueOf());
+    flags.clearAllFlags();
+    callExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));
+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));
+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));
+
+    // Modifies this, local result
+    flags.clearAllFlags();
+    newExpr.setSideEffectFlags(flags.valueOf());
+    flags.clearAllFlags();
+    flags.setMutatesThis();
+    callExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));
+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));
+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));
+
+    // Modifies this, non-local result
+    flags.clearAllFlags();
+    newExpr.setSideEffectFlags(flags.valueOf());
+    flags.clearAllFlags();
+    flags.setMutatesThis();
+    flags.setReturnsTainted();
+    callExpr.setSideEffectFlags(flags.valueOf());
+
+    assertFalse(NodeUtil.evaluatesToLocalValue(callExpr));
+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));
+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));
+
+    // No modifications, non-local result
+    flags.clearAllFlags();
+    newExpr.setSideEffectFlags(flags.valueOf());
+    flags.clearAllFlags();
+    flags.setReturnsTainted();
+    callExpr.setSideEffectFlags(flags.valueOf());
+
+    assertFalse(NodeUtil.evaluatesToLocalValue(callExpr));
+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));
+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));
+
+    // The new modifies global state, no side-effect call, non-local result
+    // This call could be removed, but not the new.
+    flags.clearAllFlags();
+    flags.setMutatesGlobalState();
+    newExpr.setSideEffectFlags(flags.valueOf());
+    flags.clearAllFlags();
+    callExpr.setSideEffectFlags(flags.valueOf());
+
+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));
+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));
+    assertTrue(NodeUtil.mayHaveSideEffects(callExpr));
+  }
+
+  private boolean testLocalValue(String js) {
+    return NodeUtil.evaluatesToLocalValue(getNode(js));
+  }
+
+  public void testValidDefine() {
+    assertTrue(testValidDefineValue("1"));
+    assertTrue(testValidDefineValue("-3"));
+    assertTrue(testValidDefineValue("true"));
+    assertTrue(testValidDefineValue("false"));
+    assertTrue(testValidDefineValue("'foo'"));
+
+    assertFalse(testValidDefineValue("x"));
+    assertFalse(testValidDefineValue("null"));
+    assertFalse(testValidDefineValue("undefined"));
+    assertFalse(testValidDefineValue("NaN"));
+
+    assertTrue(testValidDefineValue("!true"));
+    assertTrue(testValidDefineValue("-true"));
+    assertTrue(testValidDefineValue("1 & 8"));
+    assertTrue(testValidDefineValue("1 + 8"));
+    assertTrue(testValidDefineValue("'a' + 'b'"));
+
+    assertFalse(testValidDefineValue("1 & foo"));
+  }
+
+  private boolean testValidDefineValue(String js) {
+    Node script = parse("var test = " + js +";");
+    Node var = script.getFirstChild();
+    Node name = var.getFirstChild();
+    Node value = name.getFirstChild();
+
+    ImmutableSet<String> defines = ImmutableSet.of();
+    return NodeUtil.isValidDefineValue(value, defines);
+  }
+
+  public void testGetNumberValue() {
+    // Strings
+    assertEquals(1.0, NodeUtil.getNumberValue(getNode("'\\uFEFF1'")));
+    assertEquals(0.0, NodeUtil.getNumberValue(getNode("''")));
+    assertEquals(0.0, NodeUtil.getNumberValue(getNode("' '")));
+    assertEquals(0.0, NodeUtil.getNumberValue(getNode("' \\t'")));
+    assertEquals(0.0, NodeUtil.getNumberValue(getNode("'+0'")));
+    assertEquals(-0.0, NodeUtil.getNumberValue(getNode("'-0'")));
+    assertEquals(2.0, NodeUtil.getNumberValue(getNode("'+2'")));
+    assertEquals(-1.6, NodeUtil.getNumberValue(getNode("'-1.6'")));
+    assertEquals(16.0, NodeUtil.getNumberValue(getNode("'16'")));
+    assertEquals(16.0, NodeUtil.getNumberValue(getNode("' 16 '")));
+    assertEquals(16.0, NodeUtil.getNumberValue(getNode("' 16 '")));
+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'123e2'")));
+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'123E2'")));
+    assertEquals(1.23, NodeUtil.getNumberValue(getNode("'123e-2'")));
+    assertEquals(1.23, NodeUtil.getNumberValue(getNode("'123E-2'")));
+    assertEquals(-1.23, NodeUtil.getNumberValue(getNode("'-123e-2'")));
+    assertEquals(-1.23, NodeUtil.getNumberValue(getNode("'-123E-2'")));
+    assertEquals(1.23, NodeUtil.getNumberValue(getNode("'+123e-2'")));
+    assertEquals(1.23, NodeUtil.getNumberValue(getNode("'+123E-2'")));
+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'+123e+2'")));
+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'+123E+2'")));
+
+    assertEquals(15.0, NodeUtil.getNumberValue(getNode("'0xf'")));
+    assertEquals(15.0, NodeUtil.getNumberValue(getNode("'0xF'")));
+
+    // Chrome and rhino behavior differently from FF and IE. FF and IE
+    // consider a negative hex number to be invalid
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'-0xf'")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'-0xF'")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'+0xf'")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'+0xF'")));
+
+    assertEquals(16.0, NodeUtil.getNumberValue(getNode("'0X10'")));
+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'0X10.8'")));
+    assertEquals(77.0, NodeUtil.getNumberValue(getNode("'077'")));
+    assertEquals(-77.0, NodeUtil.getNumberValue(getNode("'-077'")));
+    assertEquals(-77.5, NodeUtil.getNumberValue(getNode("'-077.5'")));
+    assertEquals(
+        Double.NEGATIVE_INFINITY,
+        NodeUtil.getNumberValue(getNode("'-Infinity'")));
+    assertEquals(
+        Double.POSITIVE_INFINITY,
+        NodeUtil.getNumberValue(getNode("'Infinity'")));
+    assertEquals(
+        Double.POSITIVE_INFINITY,
+        NodeUtil.getNumberValue(getNode("'+Infinity'")));
+    // FireFox treats "infinity" as "Infinity", IE treats it as NaN
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'-infinity'")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'infinity'")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("'+infinity'")));
+
+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'NaN'")));
+    assertEquals(
+        Double.NaN, NodeUtil.getNumberValue(getNode("'some unknown string'")));
+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'123 blah'")));
+
+    // Literals
+    assertEquals(1.0, NodeUtil.getNumberValue(getNode("1")));
+    // "-1" is parsed as a literal
+    assertEquals(-1.0, NodeUtil.getNumberValue(getNode("-1")));
+    // "+1" is parse as an op + literal
+    assertEquals(null, NodeUtil.getNumberValue(getNode("+1")));
+    assertEquals(22.0, NodeUtil.getNumberValue(getNode("22")));
+    assertEquals(18.0, NodeUtil.getNumberValue(getNode("022")));
+    assertEquals(34.0, NodeUtil.getNumberValue(getNode("0x22")));
+
+    assertEquals(
+        1.0, NodeUtil.getNumberValue(getNode("true")));
+    assertEquals(
+        0.0, NodeUtil.getNumberValue(getNode("false")));
+    assertEquals(
+        0.0, NodeUtil.getNumberValue(getNode("null")));
+    assertEquals(
+        Double.NaN, NodeUtil.getNumberValue(getNode("void 0")));
+    assertEquals(
+        Double.NaN, NodeUtil.getNumberValue(getNode("void f")));
+    // values with side-effects are ignored.
+    assertEquals(
+        null, NodeUtil.getNumberValue(getNode("void f()")));
+    assertEquals(
+        Double.NaN, NodeUtil.getNumberValue(getNode("NaN")));
+    assertEquals(
+        Double.POSITIVE_INFINITY,
+        NodeUtil.getNumberValue(getNode("Infinity")));
+    assertEquals(
+        Double.NEGATIVE_INFINITY,
+        NodeUtil.getNumberValue(getNode("-Infinity")));
+
+    // "infinity" is not a known name.
+    assertEquals(null, NodeUtil.getNumberValue(getNode("infinity")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("-infinity")));
+
+    // getNumberValue only converts literals
+    assertEquals(null, NodeUtil.getNumberValue(getNode("x")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("x.y")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("1/2")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("1-2")));
+    assertEquals(null, NodeUtil.getNumberValue(getNode("+1")));
+  }
+
+  public void testIsNumbericResult() {
+    assertTrue(NodeUtil.isNumericResult(getNode("1")));
+    assertFalse(NodeUtil.isNumericResult(getNode("true")));
+    assertTrue(NodeUtil.isNumericResult(getNode("+true")));
+    assertTrue(NodeUtil.isNumericResult(getNode("+1")));
+    assertTrue(NodeUtil.isNumericResult(getNode("-1")));
+    assertTrue(NodeUtil.isNumericResult(getNode("-Infinity")));
+    assertTrue(NodeUtil.isNumericResult(getNode("Infinity")));
+    assertTrue(NodeUtil.isNumericResult(getNode("NaN")));
+    assertFalse(NodeUtil.isNumericResult(getNode("undefined")));
+    assertFalse(NodeUtil.isNumericResult(getNode("void 0")));
+
+    assertTrue(NodeUtil.isNumericResult(getNode("a << b")));
+    assertTrue(NodeUtil.isNumericResult(getNode("a >> b")));
+    assertTrue(NodeUtil.isNumericResult(getNode("a >>> b")));
+
+    assertFalse(NodeUtil.isNumericResult(getNode("a == b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a != b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a === b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a !== b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a < b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a > b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a <= b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a >= b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a in b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a instanceof b")));
+
+    assertFalse(NodeUtil.isNumericResult(getNode("'a'")));
+    assertFalse(NodeUtil.isNumericResult(getNode("'a'+b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a+'b'")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a+b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a()")));
+    assertFalse(NodeUtil.isNumericResult(getNode("''.a")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a.b")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a.b()")));
+    assertFalse(NodeUtil.isNumericResult(getNode("a().b()")));
+    assertFalse(NodeUtil.isNumericResult(getNode("new a()")));
+
+    // Definitely not numberic
+    assertFalse(NodeUtil.isNumericResult(getNode("([1,2])")));
+    assertFalse(NodeUtil.isNumericResult(getNode("({a:1})")));
+
+    // Recurse into the expression when necessary.
+    assertTrue(NodeUtil.isNumericResult(getNode("1 && 2")));
+    assertTrue(NodeUtil.isNumericResult(getNode("1 || 2")));
+    assertTrue(NodeUtil.isNumericResult(getNode("a ? 2 : 3")));
+    assertTrue(NodeUtil.isNumericResult(getNode("a,1")));
+    assertTrue(NodeUtil.isNumericResult(getNode("a=1")));
+  }
+
+  public void testIsBooleanResult() {
+    assertFalse(NodeUtil.isBooleanResult(getNode("1")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("true")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("+true")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("+1")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("-1")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));
+
+    assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));
+
+    assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));
+
+    assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a()")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));
+
+    // Definitely not boolean
+    assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));
+
+    // These are boolean but aren't handled yet, "false" here means "unknown".
+    assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));
+    assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));
+    assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));
+  }
+
+  public void testMayBeString() {
+    assertFalse(NodeUtil.mayBeString(getNode("1")));
+    assertFalse(NodeUtil.mayBeString(getNode("true")));
+    assertFalse(NodeUtil.mayBeString(getNode("+true")));
+    assertFalse(NodeUtil.mayBeString(getNode("+1")));
+    assertFalse(NodeUtil.mayBeString(getNode("-1")));
+    assertFalse(NodeUtil.mayBeString(getNode("-Infinity")));
+    assertFalse(NodeUtil.mayBeString(getNode("Infinity")));
+    assertFalse(NodeUtil.mayBeString(getNode("NaN")));
+    assertFalse(NodeUtil.mayBeString(getNode("undefined")));
+    assertFalse(NodeUtil.mayBeString(getNode("void 0")));
+    assertFalse(NodeUtil.mayBeString(getNode("null")));
+
+    assertFalse(NodeUtil.mayBeString(getNode("a << b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a >> b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a >>> b")));
+
+    assertFalse(NodeUtil.mayBeString(getNode("a == b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a != b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a === b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a !== b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a < b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a > b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a <= b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a >= b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a in b")));
+    assertFalse(NodeUtil.mayBeString(getNode("a instanceof b")));
+
+    assertTrue(NodeUtil.mayBeString(getNode("'a'")));
+    assertTrue(NodeUtil.mayBeString(getNode("'a'+b")));
+    assertTrue(NodeUtil.mayBeString(getNode("a+'b'")));
+    assertTrue(NodeUtil.mayBeString(getNode("a+b")));
+    assertTrue(NodeUtil.mayBeString(getNode("a()")));
+    assertTrue(NodeUtil.mayBeString(getNode("''.a")));
+    assertTrue(NodeUtil.mayBeString(getNode("a.b")));
+    assertTrue(NodeUtil.mayBeString(getNode("a.b()")));
+    assertTrue(NodeUtil.mayBeString(getNode("a().b()")));
+    assertTrue(NodeUtil.mayBeString(getNode("new a()")));
+
+    // These can't be strings but they aren't handled yet.
+    assertFalse(NodeUtil.mayBeString(getNode("1 && 2")));
+    assertFalse(NodeUtil.mayBeString(getNode("1 || 2")));
+    assertFalse(NodeUtil.mayBeString(getNode("1 ? 2 : 3")));
+    assertFalse(NodeUtil.mayBeString(getNode("1,2")));
+    assertFalse(NodeUtil.mayBeString(getNode("a=1")));
+    assertFalse(NodeUtil.mayBeString(getNode("1+1")));
+    assertFalse(NodeUtil.mayBeString(getNode("true+true")));
+    assertFalse(NodeUtil.mayBeString(getNode("null+null")));
+    assertFalse(NodeUtil.mayBeString(getNode("NaN+NaN")));
+
+    // These are not strings but they aren't primitives either
+    assertTrue(NodeUtil.mayBeString(getNode("([1,2])")));
+    assertTrue(NodeUtil.mayBeString(getNode("({a:1})")));
+    assertTrue(NodeUtil.mayBeString(getNode("({}+1)")));
+    assertTrue(NodeUtil.mayBeString(getNode("(1+{})")));
+    assertTrue(NodeUtil.mayBeString(getNode("([]+1)")));
+    assertTrue(NodeUtil.mayBeString(getNode("(1+[])")));
+  }
+
+  public void testGetNearestFunctionName() {
+    testFunctionName("function a() {}", "a");
+    testFunctionName("(function a() {})", "a");
+    testFunctionName("({a:function () {}})", "a");
+    testFunctionName("({get a() {}})", "a");
+    testFunctionName("({set a(b) {}})", "a");
+    testFunctionName("({set a(b) {}})", "a");
+    testFunctionName("({1:function () {}})", "1");
+    testFunctionName("var a = function a() {}", "a");
+    testFunctionName("var a;a = function a() {}", "a");
+    testFunctionName("var o;o.a = function a() {}", "o.a");
+    testFunctionName("this.a = function a() {}", "this.a");
+  }
+
+  static void testFunctionName(String js, String expected) {
+    assertEquals(
+        expected,
+        NodeUtil.getNearestFunctionName(getFunctionNode(js)));
+  }
+
+  static Node getFunctionNode(String js) {
+    Node root = parse(js);
+    return getFunctionNode(root);
+  }
+
+  static Node getFunctionNode(Node n) {
+    if (n.getType() == Token.FUNCTION) {
+      return n;
+    }
+    for (Node c : n.children()) {
+      Node result = getFunctionNode(c);
+      if (result != null) {
+        return result;
+      }
+    }
+    return null;
+  }
 }
