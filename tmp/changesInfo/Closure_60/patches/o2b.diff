diff -r -u original/src/com/google/javascript/jscomp/NodeUtil.java buggy/src/com/google/javascript/jscomp/NodeUtil.java
--- original/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-13 15:31:40.927088901 +0800
+++ buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:22.758886457 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,8 @@
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
+import com.google.javascript.rhino.jstype.FunctionType;
+import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.TernaryValue;
 
 import java.util.Arrays;
@@ -43,6 +45,10 @@
  */
 public final class NodeUtil {
 
+  static final long MAX_POSITIVE_INTEGER_NUMBER = (long)Math.pow(2, 53);
+
+  final static String JSC_PROPERTY_NAME_FN = "JSCompiler_renameProperty";
+
   // TODO(user): Eliminate this class and make all of the static methods
   // instance methods of com.google.javascript.rhino.Node.
 
@@ -65,45 +71,52 @@
    * Note: unlike getBooleanValue this function does not return UNKNOWN
    * for expressions with side-effects.
    */
-  static TernaryValue getExpressionBooleanValue(Node n) {
+  static TernaryValue getImpureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.ASSIGN:
       case Token.COMMA:
         // For ASSIGN and COMMA the value is the value of the RHS.
-        return getExpressionBooleanValue(n.getLastChild());
+        return getImpureBooleanValue(n.getLastChild());
       case Token.NOT:
-        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue value = getImpureBooleanValue(n.getLastChild());
         return value.not();
       case Token.AND: {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
       case Token.OR:  {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
       case Token.HOOK:  {
-        TernaryValue trueValue = getExpressionBooleanValue(
+        TernaryValue trueValue = getImpureBooleanValue(
             n.getFirstChild().getNext());
-        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
         } else {
           return TernaryValue.UNKNOWN;
         }
       }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // ignoring side-effects
+        return TernaryValue.TRUE;
+
       default:
-        return getBooleanValue(n);
+        return getPureBooleanValue(n);
     }
   }
 
   /**
    * Gets the boolean value of a node that represents a literal. This method
-   * effectively emulates the <code>Boolean()</code> JavaScript cast function.
+   * effectively emulates the <code>Boolean()</code> JavaScript cast function
+   * except it return UNKNOWN for known values with side-effects, use
+   * getExpressionBooleanValue if you don't care about side-effects.
    */
-  static TernaryValue getBooleanValue(Node n) {
+  static TernaryValue getPureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
@@ -111,6 +124,9 @@
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
 
+      case Token.NOT:
+        return getPureBooleanValue(n.getLastChild()).not();
+
       case Token.NULL:
       case Token.FALSE:
       case Token.VOID:
@@ -129,38 +145,41 @@
         break;
 
       case Token.TRUE:
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
       case Token.REGEXP:
         return TernaryValue.TRUE;
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        if (!mayHaveSideEffects(n)) {
+          return TernaryValue.TRUE;
+        }
     }
 
     return TernaryValue.UNKNOWN;
   }
 
-
   /**
    * Gets the value of a node as a String, or null if it cannot be converted.
    * When it returns a non-null String, this method effectively emulates the
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): Convert constant array, object, and regex literals as well.
+    // TODO(user): regex literals as well.
     switch (n.getType()) {
-      case Token.NAME:
       case Token.STRING:
         return n.getString();
 
-      case Token.NUMBER:
-        double value = n.getDouble();
-        long longValue = (long) value;
-
-        // Return "1" instead of "1.0"
-        if (longValue == value) {
-          return Long.toString(longValue);
-        } else {
-          return Double.toString(n.getDouble());
+      case Token.NAME:
+        String name = n.getString();
+        if ("undefined".equals(name)
+            || "Infinity".equals(name)
+            || "NaN".equals(name)) {
+          return name;
         }
+        break;
+
+      case Token.NUMBER:
+        return getStringValue(n.getDouble());
 
       case Token.FALSE:
       case Token.TRUE:
@@ -169,10 +188,214 @@
 
       case Token.VOID:
         return "undefined";
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? "false" : "true"; // reversed.
+        }
+        break;
+
+      case Token.ARRAYLIT:
+        return arrayToString(n);
+
+      case Token.OBJECTLIT:
+        return "[object Object]";
     }
     return null;
   }
 
+  static String getStringValue(double value) {
+    long longValue = (long) value;
+
+    // Return "1" instead of "1.0"
+    if (longValue == value) {
+      return Long.toString(longValue);
+    } else {
+      return Double.toString(value);
+    }
+  }
+
+  /**
+   * When converting arrays to string using Array.prototype.toString or
+   * Array.prototype.join, the rules for conversion to String are different
+   * than converting each element individually.  Specifically, "null" and
+   * "undefined" are converted to an empty string.
+   * @param n A node that is a member of an Array.
+   * @return The string representation.
+   */
+  static String getArrayElementStringValue(Node n) {
+    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)
+        ? "" : getStringValue(n);
+  }
+
+  static String arrayToString(Node literal) {
+    Node first = literal.getFirstChild();
+    StringBuilder result = new StringBuilder();
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
+    for (Node n = first; n != null; n = n.getNext()) {
+      String childValue = getArrayElementStringValue(n);
+      if (childValue == null) {
+        return null;
+      }
+      if (n != first) {
+        result.append(',');
+      }
+      result.append(childValue);
+
+      nextSlot++;
+    }
+    return result.toString();
+  }
+
+  /**
+   * Gets the value of a node as a Number, or null if it cannot be converted.
+   * When it returns a non-null Double, this method effectively emulates the
+   * <code>Number()</code> JavaScript cast function.
+   */
+  static Double getNumberValue(Node n) {
+    switch (n.getType()) {
+      case Token.TRUE:
+        return 1.0;
+
+      case Token.FALSE:
+      case Token.NULL:
+        return 0.0;
+
+      case Token.NUMBER:
+        return n.getDouble();
+
+      case Token.VOID:
+        if (mayHaveSideEffects(n.getFirstChild())) {
+          return null;
+        } else {
+          return Double.NaN;
+        }
+
+      case Token.NAME:
+        // Check for known constants
+        String name = n.getString();
+        if (name.equals("undefined")) {
+          return Double.NaN;
+        }
+        if (name.equals("NaN")) {
+          return Double.NaN;
+        }
+        if (name.equals("Infinity")) {
+          return Double.POSITIVE_INFINITY;
+        }
+        return null;
+
+      case Token.NEG:
+        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME
+            && n.getFirstChild().getString().equals("Infinity")) {
+          return Double.NEGATIVE_INFINITY;
+        }
+        return null;
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
+        }
+        break;
+
+      case Token.STRING:
+        return getStringNumberValue(n.getString());
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        String value = getStringValue(n);
+        return value != null ? getStringNumberValue(value) : null;
+    }
+
+    return null;
+  }
+
+  static Double getStringNumberValue(String rawJsString) {
+    if (rawJsString.contains("\u000b")) {
+      // vertical tab is not always whitespace
+      return null;
+    }
+
+    String s = trimJsWhiteSpace(rawJsString);
+    // return ScriptRuntime.toNumber(s);
+    if (s.length() == 0) {
+      return 0.0;
+    }
+
+    if (s.length() > 2
+        && s.charAt(0) == '0'
+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+      // Attempt to convert hex numbers.
+      try {
+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+      } catch (NumberFormatException e) {
+        return Double.NaN;
+      }
+    }
+
+    if (s.length() > 3
+        && (s.charAt(0) == '-' || s.charAt(0) == '+')
+        && s.charAt(1) == '0'
+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+      // hex numbers with explicit signs vary between browsers.
+      return null;
+    }
+
+    // FireFox and IE treat the "Infinity" differently. FireFox is case
+    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+    if (s.equals("infinity")
+        || s.equals("-infinity")
+        || s.equals("+infinity")) {
+      return null;
+    }
+
+    try {
+      return Double.parseDouble(s);
+    } catch (NumberFormatException e) {
+      return Double.NaN;
+    }
+  }
+
+  static String trimJsWhiteSpace(String s) {
+    int start = 0;
+    int end = s.length();
+    while (end > 0
+        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
+      end--;
+    }
+    while (start < end
+        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
+      start++;
+    }
+    return s.substring(start, end);
+  }
+
+  /**
+   * Copied from Rhino's ScriptRuntime
+   */
+  static TernaryValue isStrWhiteSpaceChar(int c) {
+    switch (c) {
+      case '\u000B': // <VT>
+        return TernaryValue.UNKNOWN;  // IE says "no", EcmaScript says "yes"
+      case ' ': // <SP>
+      case '\n': // <LF>
+      case '\r': // <CR>
+      case '\t': // <TAB>
+      case '\u00A0': // <NBSP>
+      case '\u000C': // <FF>
+      case '\u2028': // <LS>
+      case '\u2029': // <PS>
+      case '\uFEFF': // <BOM>
+        return TernaryValue.TRUE;
+      default:
+        return (Character.getType(c) == Character.SPACE_SEPARATOR)
+            ? TernaryValue.TRUE : TernaryValue.FALSE;
+    }
+  }
+
   /**
    * Gets the function's name. This method recognizes five forms:
    * <ul>
@@ -209,6 +432,43 @@
   }
 
   /**
+   * Gets the function's name. This method recognizes the forms:
+   * <ul>
+   * <li>{@code &#123;'name': function() ...&#125;}</li>
+   * <li>{@code &#123;name: function() ...&#125;}</li>
+   * <li>{@code function name() ...}</li>
+   * <li>{@code var name = function() ...}</li>
+   * <li>{@code qualified.name = function() ...}</li>
+   * <li>{@code var name2 = function name1() ...}</li>
+   * <li>{@code qualified.name2 = function name1() ...}</li>
+   * </ul>
+   *
+   * @param n a node whose type is {@link Token#FUNCTION}
+   * @return the function's name, or {@code null} if it has no name
+   */
+  public static String getNearestFunctionName(Node n) {
+    String name = getFunctionName(n);
+    if (name != null) {
+      return name;
+    }
+
+    // Check for the form { 'x' : function() { } }
+    Node parent = n.getParent();
+    switch (parent.getType()) {
+      case Token.SET:
+      case Token.GET:
+      case Token.STRING:
+        // Return the name of the literal's key.
+        return parent.getString();
+      case Token.NUMBER:
+        return getStringValue(parent);
+    }
+
+    return null;
+  }
+
+
+  /**
    * Returns true if this is an immutable value.
    */
   static boolean isImmutableValue(Node n) {
@@ -219,6 +479,8 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
+      case Token.NOT:
+        return isImmutableValue(n.getFirstChild());
       case Token.VOID:
       case Token.NEG:
         return isImmutableValue(n.getFirstChild());
@@ -259,7 +521,15 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if (child.getType() != Token.EMPTY
+              && !isLiteralValue(child, includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.REGEXP:
         // Return true only if all children are const.
         for (Node child = n.getFirstChild(); child != null;
@@ -270,6 +540,16 @@
         }
         return true;
 
+      case Token.OBJECTLIT:
+        // Return true only if all values are const.
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.FUNCTION:
         return includeFunctions && !NodeUtil.isFunctionDeclaration(n);
 
@@ -292,13 +572,34 @@
       case Token.FALSE:
         return true;
 
-      // Single operators are valid if the child is valid.
+      // Binary operators are only valid if both children are valid.
+      case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
+
+      // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
+      case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
@@ -449,6 +750,17 @@
         return true;
 
       case Token.OBJECTLIT:
+        if (checkForNewObjects) {
+          return true;
+        }
+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+          if (checkForStateChangeHelper(
+                  c.getFirstChild(), checkForNewObjects, compiler)) {
+            return true;
+          }
+        }
+        return false;
+
       case Token.ARRAYLIT:
       case Token.REGEXP:
         if (checkForNewObjects) {
@@ -497,6 +809,11 @@
         }
 
         if (isAssignmentOp(n)) {
+          Node assignTarget = n.getFirstChild();
+          if (isName(assignTarget)) {
+            return true;
+          }
+
           // Assignments will have side effects if
           // a) The RHS has side effects, or
           // b) The LHS has side effects, or
@@ -508,13 +825,32 @@
             return true;
           }
 
-          Node current = n.getFirstChild();
-          for (;
-               current.getType() == Token.GETPROP ||
-               current.getType() == Token.GETELEM;
-               current = current.getFirstChild()) { }
-
-          return !isLiteralValue(current, true);
+          if (isGet(assignTarget)) {
+            // If the object being assigned to is a local object, don't
+            // consider this a side-effect as it can't be referenced
+            // elsewhere.  Don't do this recursively as the property might
+            // be an alias of another object, unlike a literal below.
+            Node current = assignTarget.getFirstChild();
+            if (evaluatesToLocalValue(current)) {
+              return false;
+            }
+
+            // A literal value as defined by "isLiteralValue" is guaranteed
+            // not to be an alias, or any components which are aliases of
+            // other objects.
+            // If the root object is a literal don't consider this a
+            // side-effect.
+            while (isGet(current)) {
+              current = current.getFirstChild();
+            }
+
+            return !isLiteralValue(current, true);
+          } else {
+            // TODO(johnlenz): remove this code and make this an exception. This
+            // is here only for legacy reasons, the AST is not valid but
+            // preserve existing behavior.
+            return !isLiteralValue(assignTarget, true);
+          }
         }
 
         return true;
@@ -540,9 +876,10 @@
 
   static boolean constructorCallHasSideEffects(
       Node callNode, AbstractCompiler compiler) {
-    Preconditions.checkArgument(
-        callNode.getType() == Token.NEW,
-        "Expected NEW node, got " + Token.name(callNode.getType()));
+    if (callNode.getType() != Token.NEW) {
+      throw new IllegalStateException(
+          "Expected NEW node, got " + Token.name(callNode.getType()));
+    }
 
     if (callNode.isNoSideEffectsCall()) {
       return false;
@@ -563,6 +900,8 @@
   private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =
       ImmutableSet.of(
           "Object", "Array", "String", "Number", "Boolean", "RegExp", "Error");
+  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =
+      ImmutableSet.of("toString", "valueOf");
   private static final Set<String> REGEXP_METHODS =
       ImmutableSet.of("test", "exec");
   private static final Set<String> STRING_REGEXP_METHODS =
@@ -573,8 +912,7 @@
    *
    * @param callNode - function call node
    */
-  static boolean functionCallHasSideEffects(
-      Node callNode) {
+  static boolean functionCallHasSideEffects(Node callNode) {
     return functionCallHasSideEffects(callNode, null);
   }
 
@@ -587,9 +925,10 @@
    */
   static boolean functionCallHasSideEffects(
       Node callNode, @Nullable AbstractCompiler compiler) {
-    Preconditions.checkArgument(
-        callNode.getType() == Token.CALL,
-        "Expected CALL node, got " + Token.name(callNode.getType()));
+    if (callNode.getType() != Token.CALL) {
+      throw new IllegalStateException(
+          "Expected CALL node, got " + Token.name(callNode.getType()));
+    }
 
     if (callNode.isNoSideEffectsCall()) {
       return false;
@@ -604,10 +943,22 @@
         return false;
       }
     } else if (nameNode.getType() == Token.GETPROP) {
-      // Functions in the "Math" namespace have no side effects.
+      if (callNode.hasOneChild()
+          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
+                nameNode.getLastChild().getString())) {
+        return false;
+      }
+
+      if (callNode.isOnlyModifiesThisCall()
+          && evaluatesToLocalValue(nameNode.getFirstChild())) {
+        return false;
+      }
+
+      // Math.floor has no sideeffects.
+      // TODO(nicksantos): This is a terrible terrible hack, until
+      // I create a definitionprovider that understands namespacing.
       if (nameNode.getFirstChild().getType() == Token.NAME) {
-        String namespaceName = nameNode.getFirstChild().getString();
-        if (namespaceName.equals("Math")) {
+        if ("Math.floor".equals(nameNode.getQualifiedName())) {
           return false;
         }
       }
@@ -632,6 +983,22 @@
   }
 
   /**
+   * @return Whether the call has a local result.
+   */
+  static boolean callHasLocalResult(Node n) {
+    Preconditions.checkState(n.getType() == Token.CALL);
+    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;
+  }
+
+  /**
+   * @return Whether the new has a local result.
+   */
+  static boolean newHasLocalResult(Node n) {
+    Preconditions.checkState(n.getType() == Token.NEW);
+    return n.isOnlyModifiesThisCall();
+  }
+
+  /**
    * Returns true if the current node's type implies side effects.
    *
    * This is a non-recursive version of the may have side effects
@@ -781,22 +1148,19 @@
       case Token.POS:
       case Token.NEG:    return 13;
 
-      case Token.ARRAYLIT:
       case Token.CALL:
-      case Token.EMPTY:
-      case Token.FALSE:
-      case Token.FUNCTION:
       case Token.GETELEM:
       case Token.GETPROP:
-      case Token.GET_REF:
-      case Token.IF:
-      case Token.LP:
+      // Data values
+      case Token.ARRAYLIT:
+      case Token.EMPTY:  // TODO(johnlenz): remove this.
+      case Token.FALSE:
+      case Token.FUNCTION:
       case Token.NAME:
       case Token.NULL:
       case Token.NUMBER:
       case Token.OBJECTLIT:
       case Token.REGEXP:
-      case Token.RETURN:
       case Token.STRING:
       case Token.THIS:
       case Token.TRUE:
@@ -809,9 +1173,172 @@
   }
 
   /**
+   * Apply the supplied predicate against the potential
+   * all possible result of the expression.
+   */
+  static boolean valueCheck(Node n, Predicate<Node> p) {
+    switch (n.getType()) {
+      case Token.ASSIGN:
+      case Token.COMMA:
+        return valueCheck(n.getLastChild(), p);
+      case Token.AND:
+      case Token.OR:
+        return valueCheck(n.getFirstChild(), p)
+            && valueCheck(n.getLastChild(), p);
+      case Token.HOOK:
+        return valueCheck(n.getFirstChild().getNext(), p)
+            && valueCheck(n.getLastChild(), p);
+      default:
+        return p.apply(n);
+    }
+  }
+
+  static class NumbericResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isNumericResultHelper(n);
+    }
+  }
+
+  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
+      new NumbericResultPredicate();
+
+  /**
+   * Returns true if the result of node evaluation is always a number
+   */
+  static boolean isNumericResult(Node n) {
+    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);
+  }
+
+  static boolean isNumericResultHelper(Node n) {
+    switch (n.getType()) {
+      case Token.ADD:
+        return !mayBeString(n.getFirstChild())
+            && !mayBeString(n.getLastChild());
+      case Token.BITNOT:
+      case Token.BITOR:
+      case Token.BITXOR:
+      case Token.BITAND:
+      case Token.LSH:
+      case Token.RSH:
+      case Token.URSH:
+      case Token.SUB:
+      case Token.MUL:
+      case Token.MOD:
+      case Token.DIV:
+      case Token.INC:
+      case Token.DEC:
+      case Token.POS:
+      case Token.NEG:
+      case Token.NUMBER:
+        return true;
+      case Token.NAME:
+        String name = n.getString();
+        if (name.equals("NaN")) {
+          return true;
+        }
+        if (name.equals("Infinity")) {
+          return true;
+        }
+        return false;
+      default:
+        return false;
+    }
+  }
+
+  static class BooleanResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isBooleanResultHelper(n);
+    }
+  }
+
+  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
+      new BooleanResultPredicate();
+
+  /**
+   * @return Whether the result of node evaluation is always a boolean
+   */
+  static boolean isBooleanResult(Node n) {
+    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);
+  }
+
+  static boolean isBooleanResultHelper(Node n) {
+    switch (n.getType()) {
+      // Primitives
+      case Token.TRUE:
+      case Token.FALSE:
+      // Comparisons
+      case Token.EQ:
+      case Token.NE:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.LT:
+      case Token.GT:
+      case Token.LE:
+      case Token.GE:
+      // Queryies
+      case Token.IN:
+      case Token.INSTANCEOF:
+      // Inversion
+      case Token.NOT:
+      // delete operator returns a boolean.
+      case Token.DELPROP:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  static boolean isUndefined(Node n) {
+    switch (n.getType()) {
+      case Token.VOID:
+        return true;
+      case Token.NAME:
+        return n.getString().equals("undefined");
+    }
+    return false;
+  }
+
+  static boolean isNull(Node n) {
+    return n.getType() == Token.NULL;
+  }
+
+  static boolean isNullOrUndefined(Node n) {
+    return isNull(n) || isUndefined(n);
+  }
+
+  static class MayBeStringResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
+      new MayBeStringResultPredicate();
+
+  /**
+   * @returns Whether the results is possibly a string.
+   */
+  static boolean mayBeString(Node n) {
+    return mayBeString(n, true);
+  }
+
+  static boolean mayBeString(Node n, boolean recurse) {
+    if (recurse) {
+      return valueCheck(n, MAY_BE_STRING_PREDICATE);
+    } else {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static boolean mayBeStringHelper(Node n) {
+    return !isNumericResult(n) && !isBooleanResult(n)
+        && !isUndefined(n) && !isNull(n);
+  }
+
+  /**
    * Returns true if the operator is associative.
    * e.g. (a * b) * c = a * (b * c)
-   * Note: "+" is not associative because it is also the concatentation
+   * Note: "+" is not associative because it is also the concatenation
    * for strings. e.g. "a" + (1 + 2) is not "a" + 1 + 2
    */
   static boolean isAssociative(int type) {
@@ -820,6 +1347,26 @@
       case Token.AND:
       case Token.OR:
       case Token.BITOR:
+      case Token.BITXOR:
+      case Token.BITAND:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Returns true if the operator is commutative.
+   * e.g. (a * b) * c = c * (b * a)
+   * Note 1: "+" is not commutative because it is also the concatenation
+   * for strings. e.g. "a" + (1 + 2) is not "a" + 1 + 2
+   * Note 2: only operations on literals and pure functions are commutative.
+   */
+  static boolean isCommutative(int type) {
+    switch (type) {
+      case Token.MUL:
+      case Token.BITOR:
+      case Token.BITXOR:
       case Token.BITAND:
         return true;
       default:
@@ -890,7 +1437,8 @@
    * Returns true if the shallow scope contains references to 'this' keyword
    */
   static boolean referencesThis(Node n) {
-    return containsType(n, Token.THIS, new MatchNotFunction());
+    Node start = (isFunction(n)) ? n.getLastChild() : n;
+    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);
   }
 
   /**
@@ -1140,7 +1688,10 @@
    * @return Whether the node is used as a statement.
    */
   static boolean isStatement(Node n) {
-    Node parent = n.getParent();
+    return isStatementParent(n.getParent());
+  }
+
+  static boolean isStatementParent(Node parent) {
     // It is not possible to determine definitely if a node is a statement
     // or not if it is not part of the AST.  A FUNCTION node can be
     // either part of an expression or a statement.
@@ -1179,12 +1730,40 @@
         && child == parent.getLastChild();
   }
 
+  /** Whether the node is a CATCH container BLOCK. */
+  static boolean isTryCatchNodeContainer(Node n) {
+    Node parent = n.getParent();
+    return parent.getType() == Token.TRY
+        && parent.getFirstChild().getNext() == n;
+  }
+
   /** Safely remove children while maintaining a valid node structure. */
   static void removeChild(Node parent, Node node) {
-    // Node parent = node.getParent();
-    if (isStatementBlock(parent)
-        || isSwitchCase(node)
-        || isTryFinallyNode(parent, node)) {
+    if (isTryFinallyNode(parent, node)) {
+      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {
+        // A finally can only be removed if there is a catch.
+        parent.removeChild(node);
+      } else {
+        // Otherwise only its children can be removed.
+        node.detachChildren();
+      }
+    } else if (node.getType() == Token.CATCH) {
+      // The CATCH can can only be removed if there is a finally clause.
+      Node tryNode = node.getParent().getParent();
+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
+      node.detachFromParent();
+    } else if (isTryCatchNodeContainer(node)) {
+      // The container node itself can't be removed, but the contained CATCH
+      // can if there is a 'finally' clause
+      Node tryNode = node.getParent();
+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
+      node.detachChildren();
+    } else if (node.getType() == Token.BLOCK) {
+      // Simply empty the block.  This maintains source location and
+      // "synthetic"-ness.
+      node.detachChildren();
+    } else if (isStatementBlock(parent)
+        || isSwitchCase(node)) {
       // A statement in a block can simply be removed.
       parent.removeChild(node);
     } else if (parent.getType() == Token.VAR) {
@@ -1196,10 +1775,6 @@
         // This would leave an empty VAR, remove the VAR itself.
         removeChild(parent.getParent(), parent);
       }
-    } else if (node.getType() == Token.BLOCK) {
-      // Simply empty the block.  This maintains source location and
-      // "synthetic"-ness.
-      node.detachChildren();
     } else if (parent.getType() == Token.LABEL
         && node == parent.getLastChild()) {
       // Remove the node from the parent, so it can be reused.
@@ -1219,6 +1794,17 @@
   }
 
   /**
+   * Add a finally block if one does not exist.
+   */
+  static void maybeAddFinally(Node tryNode) {
+    Preconditions.checkState(tryNode.getType() == Token.TRY);
+    if (!NodeUtil.hasFinally(tryNode)) {
+      tryNode.addChildrenToBack(new Node(Token.BLOCK)
+          .copyInformationFrom(tryNode));
+    }
+  }
+
+  /**
    * Merge a block with its parent block.
    * @return Whether the block was removed.
    */
@@ -1249,6 +1835,14 @@
   }
 
   /**
+   * @param node A node
+   * @return Whether the call is a NEW or CALL node.
+   */
+  static boolean isCallOrNew(Node node) {
+    return NodeUtil.isCall(node) || NodeUtil.isNew(node);
+  }
+
+  /**
    * Is this a FUNCTION node?
    */
   static boolean isFunction(Node n) {
@@ -1270,6 +1864,14 @@
     return node.getType() == Token.THIS;
   }
 
+
+  /**
+   * Is this an ARRAYLIT node
+   */
+  static boolean isArrayLiteral(Node node) {
+    return node.getType() == Token.ARRAYLIT;
+  }
+
   /**
    * Is this node or any of its children a CALL?
    */
@@ -1343,7 +1945,7 @@
     return isNameReferenced(
         function.getLastChild(),
         "arguments",
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
   }
 
   /**
@@ -1386,6 +1988,18 @@
 
   /**
    * @return Whether the callNode represents an expression in the form of:
+   *    x.apply(...)
+   *    x['apply'](...)
+   *  or
+   *    x.call(...)
+   *    x['call'](...)
+   */
+  static boolean isFunctionObjectCallOrApply(Node callNode) {
+    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);
+  }
+
+  /**
+   * @return Whether the callNode represents an expression in the form of:
    *    x.call(...)
    *    x['call'](...)
    * where x is a NAME node.
@@ -1409,12 +2023,41 @@
    * @param parent Parent of the node
    * @return True if n is the left hand of an assign
    */
-  static boolean isLhs(Node n, Node parent) {
+  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {
     return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||
            parent.getType() == Token.VAR;
   }
 
   /**
+   * Determines whether this node is used as an L-value. Notice that sometimes
+   * names are used as both L-values and R-values.
+   *
+   * We treat "var x;" as a pseudo-L-value, which kind of makes sense if you
+   * treat it as "assignment to 'undefined' at the top of the scope". But if
+   * we're honest with ourselves, it doesn't make sense, and we only do this
+   * because it makes sense to treat this as synactically similar to
+   * "var x = 0;".
+   *
+   * @param node The node
+   * @return True if n is an L-value.
+   */
+  static boolean isLValue(Node node) {
+    int nType = node.getType();
+    Preconditions.checkArgument(nType == Token.NAME || nType == Token.GETPROP ||
+        nType == Token.GETELEM);
+    Node parent = node.getParent();
+    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)
+        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)
+        || NodeUtil.isVar(parent)
+        || (parent.getType() == Token.FUNCTION &&
+            parent.getFirstChild() == node)
+        || parent.getType() == Token.DEC
+        || parent.getType() == Token.INC
+        || parent.getType() == Token.LP
+        || parent.getType() == Token.CATCH;
+  }
+
+  /**
    * Determines whether a node represents an object literal key
    * (e.g. key1 in {key1: value1, key2: value2}).
    *
@@ -1422,17 +2065,75 @@
    * @param parent The node's parent
    */
   static boolean isObjectLitKey(Node node, Node parent) {
-    if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) {
-      int index = 0;
-      for (Node current = parent.getFirstChild();
-           current != null;
-           current = current.getNext()) {
-        if (current == node) {
-          return index % 2 == 0;
-        }
-        index++;
+    switch (node.getType()) {
+      case Token.STRING:
+        return parent.getType() == Token.OBJECTLIT;
+      case Token.GET:
+      case Token.SET:
+        return true;
+    }
+    return false;
+  }
+
+  /**
+   * Get the name of an object literal key.
+   *
+   * @param key A node
+   */
+  static String getObjectLitKeyName(Node key) {
+    switch (key.getType()) {
+      case Token.STRING:
+      case Token.GET:
+      case Token.SET:
+        return key.getString();
+    }
+    throw new IllegalStateException("Unexpected node type: " + key);
+  }
+
+  /**
+   * @param key A OBJECTLIT key node.
+   * @return The type expected when using the key.
+   */
+  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {
+    if (valueType != null) {
+      switch (key.getType()) {
+        case Token.GET:
+          // GET must always return a function type.
+          if (valueType.isFunctionType()) {
+            FunctionType fntype = ((FunctionType) valueType);
+            valueType = fntype.getReturnType();
+          } else {
+            return null;
+          }
+          break;
+        case Token.SET:
+          if (valueType.isFunctionType()) {
+            // SET must always return a function type.
+            FunctionType fntype = ((FunctionType) valueType);
+            Node param = fntype.getParametersNode().getFirstChild();
+            // SET function must always have one parameter.
+            valueType = param.getJSType();
+          } else {
+            return null;
+          }
+          break;
       }
     }
+    return valueType;
+  }
+
+  /**
+   * Determines whether a node represents an object literal get or set key
+   * (e.g. key1 in {get key1() {}, set key2(a){}).
+   *
+   * @param node A node
+   */
+  static boolean isGetOrSetKey(Node node) {
+    switch (node.getType()) {
+      case Token.GET:
+      case Token.SET:
+        return true;
+    }
     return false;
   }
 
@@ -1608,13 +2309,14 @@
    * @param charno The source character offset from start of the line.
    * @return A NAME or GETPROP node
    */
-  public static Node newQualifiedNameNode(String name, int lineno, int charno) {
+  public static Node newQualifiedNameNode(
+      CodingConvention convention, String name, int lineno, int charno) {
     int endPos = name.indexOf('.');
     if (endPos == -1) {
-      return Node.newString(Token.NAME, name, lineno, charno);
+      return newName(convention, name, lineno, charno);
     }
-    Node node = Node.newString(Token.NAME, name.substring(0, endPos),
-                               lineno, charno);
+    Node node = newName(
+        convention, name.substring(0, endPos), lineno, charno);
     int startPos;
     do {
       startPos = endPos + 1;
@@ -1622,9 +2324,11 @@
       String part = (endPos == -1
                      ? name.substring(startPos)
                      : name.substring(startPos, endPos));
-      node = new Node(Token.GETPROP, node,
-                      Node.newString(Token.STRING, part, lineno, charno),
-                      lineno, charno);
+      Node propNode = Node.newString(Token.STRING, part, lineno, charno);
+      if (convention.isConstantKey(part)) {
+        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+      }
+      node = new Node(Token.GETPROP, node, propNode, lineno, charno);
     } while (endPos != -1);
 
     return node;
@@ -1643,9 +2347,10 @@
    *
    * @return A NAME or GETPROP node
    */
-  static Node newQualifiedNameNode(String name, Node basisNode,
+  static Node newQualifiedNameNode(
+      CodingConvention convention, String name, Node basisNode,
       String originalName) {
-    Node node = newQualifiedNameNode(name, -1, -1);
+    Node node = newQualifiedNameNode(convention, name, -1, -1);
     setDebugInformation(node, basisNode, originalName);
     return node;
   }
@@ -1653,7 +2358,7 @@
   /**
    * Gets the root node of a qualified name. Must be either NAME or THIS.
    */
-  static Node getRootOfQualifiedName(Node qName) {
+  public static Node getRootOfQualifiedName(Node qName) {
     for (Node current = qName; true;
          current = current.getFirstChild()) {
       int type = current.getType();
@@ -1678,6 +2383,15 @@
     node.putProp(Node.ORIGINALNAME_PROP, originalName);
   }
 
+  private static Node newName(
+      CodingConvention convention, String name, int lineno, int charno) {
+    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);
+    if (convention.isConstant(name)) {
+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+    }
+    return nameNode;
+  }
+
   /**
    * Creates a new node representing an *existing* name, copying over the source
    * location information from the basis node.
@@ -1688,8 +2402,12 @@
    *
    * @return The node created.
    */
-  static Node newName(String name, Node basisNode) {
+  static Node newName(
+      CodingConvention convention, String name, Node basisNode) {
     Node nameNode = Node.newString(Token.NAME, name);
+    if (convention.isConstantKey(name)) {
+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+    }
     nameNode.copyInformationFrom(basisNode);
     return nameNode;
   }
@@ -1707,8 +2425,10 @@
    *
    * @return The node created.
    */
-  static Node newName(String name, Node basisNode, String originalName) {
-    Node nameNode = newName(name, basisNode);
+  static Node newName(
+      CodingConvention convention, String name,
+      Node basisNode, String originalName) {
+    Node nameNode = newName(convention, name, basisNode);
     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);
     return nameNode;
   }
@@ -1779,7 +2499,7 @@
     visitPreOrder(
         root,
         collector,
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
     return collector.vars.values();
   }
 
@@ -1833,7 +2553,6 @@
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
-    // TODO(johnlenz): Why this instead of the more common "undefined"?
     Node node = new Node(Token.VOID, Node.newNumber(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
@@ -1907,6 +2626,8 @@
     }
   }
 
+  static final Predicate<Node> MATCH_NOT_FUNCTION = new MatchNotFunction();
+
   /**
    * A predicate for matching statements without exiting the current scope.
    */
@@ -2066,10 +2787,10 @@
     * @param fnNode The function.
     * @return The Node containing the Function parameters.
     */
-  static Node getFnParameters(Node fnNode) {
-   // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]
-   Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
-   return fnNode.getFirstChild().getNext();
+  public static Node getFunctionParameters(Node fnNode) {
+    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]
+    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
+    return fnNode.getFirstChild().getNext();
   }
 
   /**
@@ -2130,7 +2851,7 @@
   /**
    * Get the JSDocInfo for a function.
    */
-  static JSDocInfo getFunctionInfo(Node n) {
+  public static JSDocInfo getFunctionJSDocInfo(Node n) {
     Preconditions.checkState(n.getType() == Token.FUNCTION);
     JSDocInfo fnInfo = n.getJSDocInfo();
     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {
@@ -2151,10 +2872,10 @@
    * @param n The node.
    * @return The source name property on the node or its ancestors.
    */
-  static String getSourceName(Node n) {
+  public static String getSourceName(Node n) {
     String sourceName = null;
     while (sourceName == null && n != null) {
-      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
+      sourceName = n.getSourceFileName();
       n = n.getParent();
     }
     return sourceName;
@@ -2164,7 +2885,7 @@
    * A new CALL node with the "FREE_CALL" set based on call target.
    */
   static Node newCallNode(Node callTarget, Node... parameters) {
-    boolean isFreeCall = isName(callTarget);
+    boolean isFreeCall = !isGet(callTarget);
     Node call = new Node(Token.CALL, callTarget);
     call.putBooleanProp(Node.FREE_CALL, isFreeCall);
     for (Node parameter : parameters) {
@@ -2172,4 +2893,126 @@
     }
     return call;
   }
+
+  /**
+   * @return Whether the node is known to be a value that is not referenced
+   * elsewhere.
+   */
+  static boolean evaluatesToLocalValue(Node value) {
+    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());
+  }
+
+  /**
+   * @param locals A predicate to apply to unknown local values.
+   * @return Whether the node is known to be a value that is not a reference
+   *     outside the expression scope.
+   */
+  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
+    switch (value.getType()) {
+      case Token.ASSIGN:
+        // A result that is aliased by a non-local name, is the effectively the
+        // same as returning a non-local name, but this doesn't matter if the
+        // value is immutable.
+        return NodeUtil.isImmutableValue(value.getLastChild())
+            || (locals.apply(value)
+                && evaluatesToLocalValue(value.getLastChild(), locals));
+      case Token.COMMA:
+        return evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.AND:
+      case Token.OR:
+        return evaluatesToLocalValue(value.getFirstChild(), locals)
+           && evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.HOOK:
+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
+           && evaluatesToLocalValue(value.getLastChild(), locals);
+      case Token.INC:
+      case Token.DEC:
+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
+          return evaluatesToLocalValue(value.getFirstChild(), locals);
+        } else {
+          return true;
+        }
+      case Token.THIS:
+        return locals.apply(value);
+      case Token.NAME:
+        return isImmutableValue(value) || locals.apply(value);
+      case Token.GETELEM:
+      case Token.GETPROP:
+        // There is no information about the locality of object properties.
+        return locals.apply(value);
+      case Token.CALL:
+        return callHasLocalResult(value)
+            || isToStringMethodCall(value)
+            || locals.apply(value);
+      case Token.NEW:
+        return newHasLocalResult(value)
+               || locals.apply(value);
+      case Token.FUNCTION:
+      case Token.REGEXP:
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // Literals objects with non-literal children are allowed.
+        return true;
+      case Token.DELPROP:
+      case Token.IN:
+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
+        return true;
+      default:
+        // Other op force a local value:
+        //  x = '' + g (x is now an local string)
+        //  x -= g (x is now an local number)
+        if (isAssignmentOp(value)
+            || isSimpleOperator(value)
+            || isImmutableValue(value)) {
+          return true;
+        }
+
+        throw new IllegalStateException(
+            "Unexpected expression node" + value +
+            "\n parent:" + value.getParent());
+    }
+  }
+
+  /**
+   * Given the first sibling, this returns the nth
+   * sibling or null if no such sibling exists.
+   * This is like "getChildAtIndex" but returns null for non-existent indexes.
+   */
+  private static Node getNthSibling(Node first, int index) {
+    Node sibling = first;
+    while (index != 0 && sibling != null) {
+      sibling = sibling.getNext();
+      index--;
+    }
+    return sibling;
+  }
+
+  /**
+   * Given the function, this returns the nth
+   * argument or null if no such parameter exists.
+   */
+  static Node getArgumentForFunction(Node function, int index) {
+    Preconditions.checkState(isFunction(function));
+    return getNthSibling(
+        function.getFirstChild().getNext().getFirstChild(), index);
+  }
+
+  /**
+   * Given the new or call, this returns the nth
+   * argument of the call or null if no such argument exists.
+   */
+  static Node getArgumentForCallOrNew(Node call, int index) {
+    Preconditions.checkState(isCallOrNew(call));
+    return getNthSibling(
+      call.getFirstChild().getNext(), index);
+  }
+
+  private static boolean isToStringMethodCall(Node call) {
+    Node getNode = call.getFirstChild();
+    if (isGet(getNode)) {
+      Node propNode = getNode.getLastChild();
+      return isString(propNode) && "toString".equals(propNode.getString());
+    }
+    return false;
+  }
 }
diff -r -u original/test/com/google/javascript/jscomp/CommandLineRunnerTest.java buggy/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
--- original/test/com/google/javascript/jscomp/CommandLineRunnerTest.java	2023-06-13 15:31:40.927088901 +0800
+++ buggy/test/com/google/javascript/jscomp/CommandLineRunnerTest.java	2023-06-12 11:40:22.758886457 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 Google Inc.
+ * Copyright 2009 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,9 +18,12 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.rhino.Node;
 
 import junit.framework.TestCase;
@@ -42,6 +45,10 @@
   private ByteArrayOutputStream outReader = null;
   private ByteArrayOutputStream errReader = null;
 
+  // If set, this will be appended to the end of the args list.
+  // For testing args parsing.
+  private String lastArg = null;
+
   // If set to true, uses comparison by string instead of by AST.
   private boolean useStringComparison = false;
 
@@ -56,22 +63,46 @@
   private List<String> args = Lists.newArrayList();
 
   /** Externs for the test */
-  private final List<JSSourceFile> externs = Lists.newArrayList(
+  private final List<JSSourceFile> DEFAULT_EXTERNS = ImmutableList.of(
     JSSourceFile.fromCode("externs",
         "var arguments;"
-        + "/** @constructor \n * @param {...*} var_args \n "
-        + "* @return {!Array} */ "
-        + "function Array(var_args) {}\n"
+        + "/**\n"
+        + " * @constructor\n"
+        + " * @param {...*} var_args\n"
+        + " */\n"
+        + "function Function(var_args) {}\n"
+        + "/**\n"
+        + " * @param {...*} var_args\n"
+        + " * @return {*}\n"
+        + " */\n"
+        + "Function.prototype.call = function(var_args) {};"
+        + "/**\n"
+        + " * @constructor\n"
+        + " * @param {...*} var_args\n"
+        + " * @return {!Array}\n"
+        + " */\n"
+        + "function Array(var_args) {}"
+        + "/**\n"
+        + " * @param {*=} opt_begin\n"
+        + " * @param {*=} opt_end\n"
+        + " * @return {!Array}\n"
+        + " * @this {Object}\n"
+        + " */\n"
+        + "Array.prototype.slice = function(opt_begin, opt_end) {};"
         + "/** @constructor */ function Window() {}\n"
         + "/** @type {string} */ Window.prototype.name;\n"
         + "/** @type {Window} */ var window;"
         + "/** @nosideeffects */ function noSideEffects() {}")
   );
 
+  private List<JSSourceFile> externs;
+
   @Override
   public void setUp() throws Exception {
     super.setUp();
+    externs = DEFAULT_EXTERNS;
     lastCompiler = null;
+    lastArg = null;
     outReader = new ByteArrayOutputStream();
     errReader = new ByteArrayOutputStream();
     useStringComparison = false;
@@ -85,16 +116,82 @@
     super.tearDown();
   }
 
+  public void testWarningGuardOrdering1() {
+    args.add("--jscomp_error=globalThis");
+    args.add("--jscomp_off=globalThis");
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testWarningGuardOrdering2() {
+    args.add("--jscomp_off=globalThis");
+    args.add("--jscomp_error=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testWarningGuardOrdering3() {
+    args.add("--jscomp_warning=globalThis");
+    args.add("--jscomp_off=globalThis");
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testWarningGuardOrdering4() {
+    args.add("--jscomp_off=globalThis");
+    args.add("--jscomp_warning=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testCheckGlobalThisOffByDefault() {
+    testSame("function f() { this.a = 3; }");
+  }
+
+  public void testCheckGlobalThisOnWithAdvancedMode() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
+  public void testCheckGlobalThisOnWithErrorFlag() {
+    args.add("--jscomp_error=globalThis");
+    test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS);
+  }
+
   public void testTypeCheckingOffByDefault() {
     test("function f(x) { return x; } f();",
          "function f(a) { return a; } f();");
   }
 
+  public void testReflectedMethods() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test(
+        "/** @constructor */" +
+        "function Foo() {}" +
+        "Foo.prototype.handle = function(x, y) { alert(y); };" +
+        "var x = goog.reflect.object(Foo, {handle: 1});" +
+        "for (var i in x) { x[i].call(x); }" +
+        "window['Foo'] = Foo;",
+        "function a() {}" +
+        "a.prototype.a = function(e, d) { alert(d); };" +
+        "var b = goog.c.b(a, {a: 1}),c;" +
+        "for (c in b) { b[c].call(b); }" +
+        "window.Foo = a;");
+  }
+
   public void testTypeCheckingOnWithVerbose() {
     args.add("--warning_level=VERBOSE");
     test("function f(x) { return x; } f();", TypeCheck.WRONG_ARGUMENT_COUNT);
   }
 
+  public void testTypeParsingOffByDefault() {
+    testSame("/** @return {number */ function f(a) { return a; }");
+  }
+
+  public void testTypeParsingOnWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @return {number */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+    test("/** @return {n} */ function f(a) { return a; }",
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
+  }
+
   public void testTypeCheckOverride1() {
     args.add("--warning_level=VERBOSE");
     args.add("--jscomp_off=checkTypes");
@@ -127,14 +224,32 @@
     testSame("x = 3;");
   }
 
-  public void testCheckUndefinedProperties() {
+  public void testCheckSymbolsOverrideForQuiet() {
+    args.add("--warning_level=QUIET");
+    args.add("--jscomp_error=undefinedVars");
+    test("x = 3;", VarCheck.UNDEFINED_VAR_ERROR);
+  }
+
+  public void testCheckUndefinedProperties1() {
     args.add("--warning_level=VERBOSE");
     args.add("--jscomp_error=missingProperties");
     test("var x = {}; var y = x.bar;", TypeCheck.INEXISTENT_PROPERTY);
   }
 
+  public void testCheckUndefinedProperties2() {
+    args.add("--warning_level=VERBOSE");
+    args.add("--jscomp_off=missingProperties");
+    test("var x = {}; var y = x.bar;", CheckGlobalNames.UNDEFINED_NAME_WARNING);
+  }
+
+  public void testCheckUndefinedProperties3() {
+    args.add("--warning_level=VERBOSE");
+    test("function f() {var x = {}; var y = x.bar;}",
+        TypeCheck.INEXISTENT_PROPERTY);
+  }
+
   public void testDuplicateParams() {
-    test("function (a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM);
+    test("function f(a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM);
     assertTrue(lastCompiler.hasHaltingErrors());
   }
 
@@ -147,7 +262,7 @@
          "/** @define {number} */ var BAR = 3;" +
          "/** @define {boolean} */ var CCC = false;" +
          "/** @define {boolean} */ var DDD = false;",
-         "var FOO = true, BAR = 5, CCC = true, DDD = true;");
+         "var FOO = !0, BAR = 5, CCC = !0, DDD = !0;");
   }
 
   public void testDefineFlag2() {
@@ -175,19 +290,36 @@
 
   public void testQuietMode() {
     args.add("--warning_level=DEFAULT");
-    test("/** @type { not a type name } */ var x;",
+    test("/** @const \n * @const */ var x;",
          RhinoErrorReporter.PARSE_ERROR);
     args.add("--warning_level=QUIET");
-    testSame("/** @type { not a type name } */ var x;");
+    testSame("/** @const \n * @const */ var x;");
   }
 
   public void testProcessClosurePrimitives() {
     test("var goog = {}; goog.provide('goog.dom');",
-         "var goog = {}; goog.dom = {};");
+         "var goog = {dom:{}};");
     args.add("--process_closure_primitives=false");
     testSame("var goog = {}; goog.provide('goog.dom');");
   }
 
+  public void testCssNameWiring() throws Exception {
+    test("var goog = {}; goog.getCssName = function() {};" +
+         "goog.setCssNameMapping = function() {};" +
+         "goog.setCssNameMapping({'goog': 'a', 'button': 'b'});" +
+         "var a = goog.getCssName('goog-button');" +
+         "var b = goog.getCssName('css-button');" +
+         "var c = goog.getCssName('goog-menu');" +
+         "var d = goog.getCssName('css-menu');",
+         "var goog = { getCssName: function() {}," +
+         "             setCssNameMapping: function() {} }," +
+         "    a = 'a-b'," +
+         "    b = 'css-b'," +
+         "    c = 'a-menu'," +
+         "    d = 'css-menu';");
+  }
+
+
   //////////////////////////////////////////////////////////////////////////////
   // Integration tests
 
@@ -204,6 +336,7 @@
 
   public void testIssue115() {
     args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    args.add("--jscomp_off=es5Strict");
     args.add("--warning_level=VERBOSE");
     test("function f() { " +
          "  var arguments = Array.prototype.slice.call(arguments, 0);" +
@@ -215,6 +348,18 @@
          "}");
   }
 
+  public void testIssue297() {
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    test("function f(p) {" +
+         " var x;" +
+         " return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);" +
+         "}",
+         "function f(b) {" +
+         " var a;" +
+         " return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);" +
+         "}");
+  }
+
   public void testDebugFlag1() {
     args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
     args.add("--debug=false");
@@ -249,6 +394,20 @@
         "throw (new function Foo() {}).$x$;");
   }
 
+  public void testBooleanFlag1() {
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    args.add("--debug");
+    test("function foo(a) {alert(a)}",
+         "function foo($a$$) {alert($a$$)}");
+  }
+
+  public void testBooleanFlag2() {
+    args.add("--debug");
+    args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
+    test("function foo(a) {alert(a)}",
+         "function foo($a$$) {alert($a$$)}");
+  }
+
   public void testHelpFlag() {
     args.add("--help");
     assertFalse(
@@ -325,7 +484,7 @@
          JSModule.CIRCULAR_DEPENDENCY_ERROR);
   }
 
-  public void testSourcePruningOn() {
+  public void testSourcePruningOn1() {
     args.add("--manage_closure_dependencies=true");
     test(new String[] {
           "goog.require('beer');",
@@ -338,6 +497,70 @@
          });
   }
 
+  public void testSourcePruningOn2() {
+    args.add("--closure_entry_point=guinness");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "var guinness = {};"
+         });
+  }
+
+  public void testSourcePruningOn3() {
+    args.add("--closure_entry_point=scotch");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+  public void testSourcePruningOn4() {
+    args.add("--closure_entry_point=scotch");
+    args.add("--closure_entry_point=beer");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+  public void testSourcePruningOn5() {
+    args.add("--closure_entry_point=shiraz");
+    test(new String[] {
+          "goog.provide('guinness');\ngoog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         Compiler.MISSING_ENTRY_ERROR);
+  }
+
+  public void testSourcePruningOn6() {
+    args.add("--closure_entry_point=scotch");
+    test(new String[] {
+          "goog.require('beer');",
+          "goog.provide('beer');",
+          "goog.provide('scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {};",
+           "",
+           "var scotch = {}, x = 3;",
+         });
+  }
+
+
   public void testForwardDeclareDroppedTypes() {
     args.add("--manage_closure_dependencies=true");
 
@@ -360,7 +583,7 @@
            "var beer = {}; function f() {}",
            ""
          },
-         RhinoErrorReporter.PARSE_ERROR);
+         RhinoErrorReporter.TYPE_PARSE_ERROR);
   }
 
   public void testSourceMapExpansion1() {
@@ -394,6 +617,14 @@
             lastCompiler.getModuleGraph().getRootModule()));
   }
 
+  public void testSourceMapFormat1() {
+    args.add("--js_output_file");
+    args.add("/path/to/out.js");
+    testSame("var x = 3;");
+    assertEquals(SourceMap.Format.DEFAULT,
+        lastCompiler.getOptions().sourceMapFormat);
+  }
+
   public void testCharSetExpansion() {
     testSame("");
     assertEquals("US-ASCII", lastCompiler.getOptions().outputCharset);
@@ -408,8 +639,8 @@
           "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"});
 
     StringBuilder builder = new StringBuilder();
-    lastCommandLineRunner.printModuleGraphManifestTo(
-        lastCompiler.getModuleGraph(), builder);
+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(
+        lastCompiler.getModuleGraph(), builder, true);
     assertEquals(
         "{m0}\n" +
         "i0\n" +
@@ -431,8 +662,8 @@
           "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"});
 
     StringBuilder builder = new StringBuilder();
-    lastCommandLineRunner.printModuleGraphManifestTo(
-        lastCompiler.getModuleGraph(), builder);
+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(
+        lastCompiler.getModuleGraph(), builder, true);
     assertEquals(
         "{m0}\n" +
         "i0\n" +
@@ -455,8 +686,17 @@
         0,
         new String(errReader.toByteArray()).indexOf(
             "Closure Compiler (http://code.google.com/closure/compiler)\n" +
-            "Version: HEAD\n" +
-            "Built on:"));
+            "Version: "));
+  }
+
+  public void testVersionFlag2() {
+    lastArg = "--version";
+    testSame("");
+    assertEquals(
+        0,
+        new String(errReader.toByteArray()).indexOf(
+            "Closure Compiler (http://code.google.com/closure/compiler)\n" +
+            "Version: "));
   }
 
   public void testPrintAstFlag() {
@@ -468,13 +708,102 @@
         "  node0 [label=\"BLOCK\"];\n" +
         "  node1 [label=\"SCRIPT\"];\n" +
         "  node0 -> node1 [weight=1];\n" +
-        "  node1 -> RETURN [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
-        "  node0 -> RETURN [label=\"SYN_BLOCK\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
-        "  node0 -> node1 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node1 -> RETURN [label=\"UNCOND\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node0 -> RETURN [label=\"SYN_BLOCK\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
+        "  node0 -> node1 [label=\"UNCOND\", " +
+            "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" +
         "}\n\n",
         new String(outReader.toByteArray()));
   }
 
+  public void testSyntheticExterns() {
+    externs = ImmutableList.of(
+        JSSourceFile.fromCode("externs", "myVar.property;"));
+    test("var theirVar = {}; var myVar = {}; var yourVar = {};",
+         VarCheck.UNDEFINED_EXTERN_VAR_ERROR);
+
+    args.add("--jscomp_off=externsValidation");
+    args.add("--warning_level=VERBOSE");
+    test("var theirVar = {}; var myVar = {}; var yourVar = {};",
+         "var theirVar={},myVar={},yourVar={};");
+
+    args.add("--jscomp_off=externsValidation");
+    args.add("--warning_level=VERBOSE");
+    test("var theirVar = {}; var myVar = {}; var myVar = {};",
+         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);
+  }
+
+  public void testGoogAssertStripping() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("goog.asserts.assert(false)",
+         "");
+    args.add("--debug");
+    test("goog.asserts.assert(false)", "goog.$asserts$.$assert$(!1)");
+  }
+
+  public void testMissingReturnCheckOnWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @return {number} */ function f() {f()} f();",
+        CheckMissingReturn.MISSING_RETURN_STATEMENT);
+  }
+
+  public void testGenerateExports() {
+    args.add("--generate_exports=true");
+    test("/** @export */ foo.prototype.x = function() {};",
+        "foo.prototype.x=function(){};"+
+        "goog.exportSymbol(\"foo.prototype.x\",foo.prototype.x);");
+  }
+
+  public void testDepreciationWithVerbose() {
+    args.add("--warning_level=VERBOSE");
+    test("/** @deprecated */ function f() {}; f()",
+       CheckAccessControls.DEPRECATED_NAME);
+  }
+
+  public void testTwoParseErrors() {
+    // If parse errors are reported in different files, make
+    // sure all of them are reported.
+    Compiler compiler = compile(new String[] {
+      "var a b;",
+      "var b c;"
+    });
+    assertEquals(2, compiler.getErrors().length);
+  }
+
+  public void testES3ByDefault() {
+    test("var x = f.function", RhinoErrorReporter.PARSE_ERROR);
+  }
+
+  public void testES5() {
+    args.add("--language_in=ECMASCRIPT5");
+    test("var x = f.function", "var x = f.function");
+    test("var let", "var let");
+  }
+
+  public void testES5Strict() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    test("var x = f.function", "'use strict';var x = f.function");
+    test("var let", RhinoErrorReporter.PARSE_ERROR);
+  }
+
+  public void testES5StrictUseStrict() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    Compiler compiler = compile(new String[] {"var x = f.function"});
+    String outputSource = compiler.toSource();
+    assertEquals("'use strict'", outputSource.substring(0, 12));
+  }
+
+  public void testES5StrictUseStrictMultipleInputs() {
+    args.add("--language_in=ECMASCRIPT5_STRICT");
+    Compiler compiler = compile(new String[] {"var x = f.function",
+        "var y = f.function", "var z = f.function"});
+    String outputSource = compiler.toSource();
+    assertEquals("'use strict'", outputSource.substring(0, 12));
+    assertEquals(outputSource.substring(13).indexOf("'use strict'"), -1);
+  }
+
   /* Helper functions */
 
   private void testSame(String original) {
@@ -573,6 +902,10 @@
       }
     }
 
+    if (lastArg != null) {
+      args.add(lastArg);
+    }
+
     String[] argStrings = args.toArray(new String[] {});
     return new CommandLineRunner(
         argStrings,
@@ -628,8 +961,13 @@
     for (int i = 0; i < original.length; i++) {
       inputs.add(JSSourceFile.fromCode("input" + i, original[i]));
     }
-    compiler.init(externs, inputs, new CompilerOptions());
+    CompilerOptions options = new CompilerOptions();
+    // ECMASCRIPT5 is the most forgiving.
+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);
+    compiler.init(externs, inputs, options);
     Node all = compiler.parseInputs();
+    Preconditions.checkState(compiler.getErrorCount() == 0);
+    Preconditions.checkNotNull(all);
     Node n = all.getLastChild();
     return n;
   }
Only in buggy/test/com/google/javascript/jscomp: NodeUtilTest.java
