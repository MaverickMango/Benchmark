diff -r -u buggy/src/com/google/javascript/jscomp/NodeUtil.java inducing/src/com/google/javascript/jscomp/NodeUtil.java
--- buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:34:27.954248026 +0800
+++ inducing/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:34:28.114250949 +0800
@@ -69,52 +69,45 @@
    * Note: unlike getBooleanValue this function does not return UNKNOWN
    * for expressions with side-effects.
    */
-  static TernaryValue getImpureBooleanValue(Node n) {
+  static TernaryValue getExpressionBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.ASSIGN:
       case Token.COMMA:
         // For ASSIGN and COMMA the value is the value of the RHS.
-        return getImpureBooleanValue(n.getLastChild());
+        return getExpressionBooleanValue(n.getLastChild());
       case Token.NOT:
-        TernaryValue value = getImpureBooleanValue(n.getLastChild());
+        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
         return value.not();
       case Token.AND: {
-        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
+        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
       case Token.OR:  {
-        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
+        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
       case Token.HOOK:  {
-        TernaryValue trueValue = getImpureBooleanValue(
+        TernaryValue trueValue = getExpressionBooleanValue(
             n.getFirstChild().getNext());
-        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
+        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
         } else {
           return TernaryValue.UNKNOWN;
         }
       }
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
-        // ignoring side-effects
-        return TernaryValue.TRUE;
-
       default:
-        return getPureBooleanValue(n);
+        return getBooleanValue(n);
     }
   }
 
   /**
    * Gets the boolean value of a node that represents a literal. This method
-   * effectively emulates the <code>Boolean()</code> JavaScript cast function
-   * except it return UNKNOWN for known values with side-effects, use
-   * getExpressionBooleanValue if you don't care about side-effects.
+   * effectively emulates the <code>Boolean()</code> JavaScript cast function.
    */
-  static TernaryValue getPureBooleanValue(Node n) {
+  static TernaryValue getBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
@@ -122,9 +115,6 @@
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
 
-      case Token.NOT:
-        return getPureBooleanValue(n.getLastChild()).not();
-
       case Token.NULL:
       case Token.FALSE:
       case Token.VOID:
@@ -143,14 +133,10 @@
         break;
 
       case Token.TRUE:
-      case Token.REGEXP:
-        return TernaryValue.TRUE;
-
       case Token.ARRAYLIT:
       case Token.OBJECTLIT:
-        if (!mayHaveSideEffects(n)) {
-          return TernaryValue.TRUE;
-        }
+      case Token.REGEXP:
+        return TernaryValue.TRUE;
     }
 
     return TernaryValue.UNKNOWN;
@@ -163,7 +149,7 @@
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): regex literals as well.
+    // TODO(user): Convert constant array, object, and regex literals as well.
     switch (n.getType()) {
       case Token.STRING:
         return n.getString();
@@ -195,57 +181,11 @@
 
       case Token.VOID:
         return "undefined";
-
-      case Token.NOT:
-        TernaryValue child = getPureBooleanValue(n.getFirstChild());
-        if (child != TernaryValue.UNKNOWN) {
-          return child.toBoolean(true) ? "false" : "true"; // reversed.
-        }
-        break;
-
-      case Token.ARRAYLIT:
-        return arrayToString(n);
-
-      case Token.OBJECTLIT:
-        return "[object Object]";
     }
     return null;
   }
 
   /**
-   * When converting arrays to string using Array.prototype.toString or
-   * Array.prototype.join, the rules for conversion to String are different
-   * than converting each element individually.  Specifically, "null" and
-   * "undefined" are converted to an empty string.
-   * @param n A node that is a member of an Array.
-   * @return The string representation.
-   */
-  static String getArrayElementStringValue(Node n) {
-    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)
-        ? "" : getStringValue(n);
-  }
-
-  static String arrayToString(Node literal) {
-    Node first = literal.getFirstChild();
-    StringBuilder result = new StringBuilder();
-    int nextSlot = 0;
-    int nextSkipSlot = 0;
-    for (Node n = first; n != null; n = n.getNext()) {
-      String childValue = getArrayElementStringValue(n);
-      if (childValue == null) {
-        return null;
-      }
-      if (n != first) {
-        result.append(',');
-      }
-      result.append(childValue);
-
-      nextSlot++;
-    }
-    return result.toString();
-  }
-
-  /**
    * Gets the value of a node as a Number, or null if it cannot be converted.
    * When it returns a non-null Double, this method effectively emulates the
    * <code>Number()</code> JavaScript cast function.
@@ -290,64 +230,48 @@
         }
         return null;
 
-      case Token.NOT:
-        TernaryValue child = getPureBooleanValue(n.getFirstChild());
-        if (child != TernaryValue.UNKNOWN) {
-          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
-        }
-        break;
-
       case Token.STRING:
-        return getStringNumberValue(n.getString());
-
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
-        String value = getStringValue(n);
-        return value != null ? getStringNumberValue(value) : null;
-    }
+        String s = trimJsWhiteSpace(n.getString());
+        // return ScriptRuntime.toNumber(s);
+        if (s.length() == 0) {
+          return 0.0;
+        }
 
-    return null;
-  }
+        if (s.length() > 2
+            && s.charAt(0) == '0'
+            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+          // Attempt to convert hex numbers.
+          try {
+            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+          } catch (NumberFormatException e) {
+            return Double.NaN;
+          }
+        }
 
-  static Double getStringNumberValue(String rawJsString) {
-    String s = trimJsWhiteSpace(rawJsString);
-    // return ScriptRuntime.toNumber(s);
-    if (s.length() == 0) {
-      return 0.0;
-    }
-
-    if (s.length() > 2
-        && s.charAt(0) == '0'
-        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
-      // Attempt to convert hex numbers.
-      try {
-        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
-      } catch (NumberFormatException e) {
-        return Double.NaN;
-      }
-    }
+        if (s.length() > 3
+            && (s.charAt(0) == '-' || s.charAt(0) == '+')
+            && s.charAt(1) == '0'
+            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+          // hex numbers with explicit signs vary between browsers.
+          return null;
+        }
 
-    if (s.length() > 3
-        && (s.charAt(0) == '-' || s.charAt(0) == '+')
-        && s.charAt(1) == '0'
-        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
-      // hex numbers with explicit signs vary between browsers.
-      return null;
-    }
+        // FireFox and IE treat the "Infinity" differently. FireFox is case
+        // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+        if (s.equals("infinity")
+            || s.equals("-infinity")
+            || s.equals("+infinity")) {
+          return null;
+        }
 
-    // FireFox and IE treat the "Infinity" differently. FireFox is case
-    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
-    if (s.equals("infinity")
-        || s.equals("-infinity")
-        || s.equals("+infinity")) {
-      return null;
+        try {
+          return Double.parseDouble(s);
+        } catch (NumberFormatException e) {
+          return Double.NaN;
+        }
     }
 
-    try {
-      return Double.parseDouble(s);
-    } catch (NumberFormatException e) {
-      return Double.NaN;
-    }
+    return null;
   }
 
   static String trimJsWhiteSpace(String s) {
@@ -466,8 +390,6 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
-      case Token.NOT:
-        return isImmutableValue(n.getFirstChild());
       case Token.VOID:
       case Token.NEG:
         return isImmutableValue(n.getFirstChild());
@@ -508,15 +430,6 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
-        for (Node child = n.getFirstChild(); child != null;
-             child = child.getNext()) {
-          if (child.getType() != Token.EMPTY
-              && !isLiteralValue(child, includeFunctions)) {
-            return false;
-          }
-        }
-        return true;
-
       case Token.REGEXP:
         // Return true only if all children are const.
         for (Node child = n.getFirstChild(); child != null;
@@ -1149,6 +1062,7 @@
       case Token.NUMBER:
       case Token.OBJECTLIT:
       case Token.REGEXP:
+      case Token.RETURN:
       case Token.STRING:
       case Token.THIS:
       case Token.TRUE:
@@ -1161,47 +1075,12 @@
   }
 
   /**
-   * Apply the supplied predicate against the potential
-   * all possible result of the expression.
-   */
-  static boolean valueCheck(Node n, Predicate<Node> p) {
-    switch (n.getType()) {
-      case Token.ASSIGN:
-      case Token.COMMA:
-        return valueCheck(n.getLastChild(), p);
-      case Token.AND:
-      case Token.OR:
-        return valueCheck(n.getFirstChild(), p)
-            && valueCheck(n.getLastChild(), p);
-      case Token.HOOK:
-        return valueCheck(n.getFirstChild().getNext(), p)
-            && valueCheck(n.getLastChild(), p);
-      default:
-        return p.apply(n);
-    }
-  }
-
-  static class NumbericResultPredicate implements Predicate<Node> {
-    public boolean apply(Node n) {
-      return isNumericResultHelper(n);
-    }
-  }
-
-  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
-      new NumbericResultPredicate();
-
-  /**
    * Returns true if the result of node evaluation is always a number
    */
   static boolean isNumericResult(Node n) {
-    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);
-  }
-
-  static boolean isNumericResultHelper(Node n) {
     switch (n.getType()) {
-      case Token.ADD:
-        return !mayBeString(n.getFirstChild())
-            && !mayBeString(n.getLastChild());
+      // NOTE: ADD is deliberately excluded as it may produce
+      // a string.
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
@@ -1233,23 +1112,12 @@
     }
   }
 
-  static class BooleanResultPredicate implements Predicate<Node> {
-    public boolean apply(Node n) {
-      return isBooleanResultHelper(n);
-    }
-  }
-
-  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
-      new BooleanResultPredicate();
-
   /**
    * @return Whether the result of node evaluation is always a boolean
    */
   static boolean isBooleanResult(Node n) {
-    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);
-  }
-
-  static boolean isBooleanResultHelper(Node n) {
+    // TODO(johnlenz): Add a recursive option to recurse into
+    // AND, OR, HOOK, COMMA and ASSIGN, like "getExpressionBooleanValue".
     switch (n.getType()) {
       // Primitives
       case Token.TRUE:
@@ -1268,8 +1136,6 @@
       case Token.INSTANCEOF:
       // Inversion
       case Token.NOT:
-      // delete operator returns a boolean.
-      case Token.DELPROP:
         return true;
       default:
         return false;
@@ -1290,35 +1156,10 @@
     return n.getType() == Token.NULL;
   }
 
-  static boolean isNullOrUndefined(Node n) {
-    return isNull(n) || isUndefined(n);
-  }
-
-  static class MayBeStringResultPredicate implements Predicate<Node> {
-    public boolean apply(Node n) {
-      return mayBeStringHelper(n);
-    }
-  }
-
-  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
-      new MayBeStringResultPredicate();
-
   /**
    * @returns Whether the results is possibly a string.
    */
   static boolean mayBeString(Node n) {
-    return mayBeString(n, true);
-  }
-
-  static boolean mayBeString(Node n, boolean recurse) {
-    if (recurse) {
-      return valueCheck(n, MAY_BE_STRING_PREDICATE);
-    } else {
-      return mayBeStringHelper(n);
-    }
-  }
-
-  static boolean mayBeStringHelper(Node n) {
     return !isNumericResult(n) && !isBooleanResult(n)
         && !isUndefined(n) && !isNull(n);
   }
@@ -1675,10 +1516,7 @@
    * @return Whether the node is used as a statement.
    */
   static boolean isStatement(Node n) {
-    return isStatementParent(n.getParent());
-  }
-
-  static boolean isStatementParent(Node parent) {
+    Node parent = n.getParent();
     // It is not possible to determine definitely if a node is a statement
     // or not if it is not part of the AST.  A FUNCTION node can be
     // either part of an expression or a statement.
@@ -1851,14 +1689,6 @@
     return node.getType() == Token.THIS;
   }
 
-
-  /**
-   * Is this an ARRAYLIT node
-   */
-  static boolean isArrayLiteral(Node node) {
-    return node.getType() == Token.ARRAYLIT;
-  }
-
   /**
    * Is this node or any of its children a CALL?
    */
@@ -2514,6 +2344,7 @@
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
+    // TODO(johnlenz): Why this instead of the more common "undefined"?
     Node node = new Node(Token.VOID, Node.newNumber(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
@@ -2912,7 +2743,6 @@
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
-      case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
diff -r -u buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java inducing/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
--- buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-12 11:34:27.978248464 +0800
+++ inducing/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-12 11:34:28.114250949 +0800
@@ -27,9 +27,8 @@
 import java.util.Set;
 
 /**
- * Tests for {@link PeepholeFoldConstants} in isolation. Tests for
- * the interaction of multiple peephole passes are in
- * {@link PeepholeIntegrationTest}.
+ * Tests for PeepholeFoldConstants in isolation. Tests for the interaction of
+ * multiple peephole passes are in PeepholeIntegrationTest.
  */
 public class PeepholeFoldConstantsTest extends CompilerTestCase {
 
@@ -219,8 +218,6 @@
 
   public void testFoldLogicalOp() {
     fold("x = true && x", "x = x");
-    foldSame("x = [foo()] && x");
-
     fold("x = false && x", "x = false");
     fold("x = true || x", "x = true");
     fold("x = false || x", "x = x");
@@ -424,7 +421,7 @@
     fold("x = foo() + 'a' + 2", "x = foo()+\"a2\"");
     fold("x = '' + null", "x = \"null\"");
     fold("x = true + '' + false", "x = \"truefalse\"");
-    fold("x = '' + []", "x = ''");      // cannot fold (but nice if we can)
+    fold("x = '' + []", "x = \"\"+[]");      // cannot fold (but nice if we can)
   }
 
   public void testFoldConstructor() {
@@ -469,10 +466,6 @@
     foldSame("x = 'abcdef'.indexOf([1,2])");
   }
 
-  public void testStringJoinAddSparse() {
-    fold("x = [,,'a'].join(',')", "x = ',,a'");
-  }
-
   public void testStringJoinAdd() {
     fold("x = ['a', 'b', 'c'].join('')", "x = \"abc\"");
     fold("x = [].join(',')", "x = \"\"");
@@ -511,12 +504,6 @@
 
     fold("x = [1,2,3].join('abcdef')",
          "x = '1abcdef2abcdef3'");
-
-    fold("x = [1,2].join()", "x = '1,2'");
-    fold("x = [null,undefined,''].join(',')", "x = ',,'");
-    fold("x = [null,undefined,0].join(',')", "x = ',,0'");
-    // This can be folded but we don't currently.
-    foldSame("x = [[1,2],[3,4]].join()"); // would like: "x = '1,2,3,4'"
   }
 
   public void testStringJoinAdd_b1992789() {
@@ -557,11 +544,11 @@
     fold("x = 2.25 * 3", "x = 6.75");
     fold("z = x * y", "z = x * y");
     fold("x = y * 5", "x = y * 5");
-    fold("x = 1 / 0", "x = 1 / 0");
+    fold("x = 1 / 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
     fold("x = 3 % 2", "x = 1");
     fold("x = 3 % -2", "x = 1");
     fold("x = -1 % 3", "x = -1");
-    fold("x = 1 % 0", "x = 1 % 0");
+    fold("x = 1 % 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
   }
 
   public void testFoldArithmetic2() {
@@ -697,7 +684,6 @@
   }
 
   public void testFoldGetElem() {
-    fold("x = [,10][0]", "x = void 0");
     fold("x = [10, 20][0]", "x = 10");
     fold("x = [10, 20][1]", "x = 20");
     fold("x = [10, 20][0.5]", "",
@@ -716,7 +702,7 @@
 
   public void testFoldLeft() {
     foldSame("(+x - 1) + 2"); // not yet
-    fold("(+x + 1) + 2", "+x + 3");
+    foldSame("(+x + 1) + 2"); // not yet
   }
 
   public void testFoldArrayLength() {
@@ -725,9 +711,6 @@
     fold("x = [1,2,3].length", "x = 3");
     fold("x = [a,b].length", "x = 2");
 
-    // Not handled yet
-    fold("x = [,,1].length", "x = 3");
-
     // Cannot fold
     fold("x = [foo(), 0].length", "x = [foo(),0].length");
     fold("x = y.length", "x = y.length");
@@ -768,8 +751,6 @@
     fold("'' instanceof String", "false");
     fold("true instanceof Object", "false");
     fold("true instanceof Boolean", "false");
-    fold("!0 instanceof Object", "false");
-    fold("!0 instanceof Boolean", "false");
     fold("false instanceof Object", "false");
     fold("null instanceof Object", "false");
     fold("undefined instanceof Object", "false");
@@ -868,8 +849,6 @@
   public void testFoldLeftChildConcat() {
     foldSame("x +5 + \"1\"");
     fold("x+\"5\" + \"1\"", "x + \"51\"");
-    // fold("\"a\"+(c+\"b\")","\"a\"+c+\"b\"");
-    fold("\"a\"+(\"b\"+c)","\"ab\"+c");
   }
 
   public void testFoldLeftChildOp() {
@@ -921,73 +900,6 @@
     fold("x/false", "x/0");  // should we add an error check? :)
   }
 
-  public void testNotFoldBackToTrueFalse() {
-    foldSame("!0");
-    foldSame("!1");
-    fold("!3", "false");
-  }
-
-  public void testFoldBangConstants() {
-    fold("1 + !0", "2");
-    fold("1 + !1", "1");
-    fold("'a ' + !1", "'a false'");
-    fold("'a ' + !0", "'a true'");
-  }
-
-  public void testFoldMixed() {
-    fold("''+[1]", "'1'");
-    foldSame("false+[]"); // would like: "\"false\""
-  }
-
-  public void testFoldVoid() {
-    foldSame("void 0");
-    fold("void 1", "void 0");
-    fold("void x", "void 0");
-    fold("void x()", "void x()");
-  }
-
-  public void testJoinBug() {
-    fold("var x = [].join();", "var x = '';");
-    fold("var x = [x].join();", "var x = '' + x;");
-    foldSame("var x = [x,y].join();");
-    foldSame("var x = [x,y,z].join();");
-
-    foldSame("shape['matrix'] = [\n" +
-            "    Number(headingCos2).toFixed(4),\n" +
-            "    Number(-headingSin2).toFixed(4),\n" +
-            "    Number(headingSin2 * yScale).toFixed(4),\n" +
-            "    Number(headingCos2 * yScale).toFixed(4),\n" +
-            "    0,\n" +
-            "    0\n" +
-            "  ].join()");
-  }
-
-  public void testToUpper() {
-    fold("'a'.toUpperCase()", "'A'");
-    fold("'A'.toUpperCase()", "'A'");
-    fold("'aBcDe'.toUpperCase()", "'ABCDE'");
-  }
-
-  public void testToLower() {
-    fold("'A'.toLowerCase()", "'a'");
-    fold("'a'.toLowerCase()", "'a'");
-    fold("'aBcDe'.toLowerCase()", "'abcde'");
-  }
-
-  public void testObjectLiteral() {
-    test("(!{})", "false");
-    test("(!{a:1})", "false");
-    testSame("(!{a:foo()})");
-    testSame("(!{'a':foo()})");
-  }
-
-  public void testArrayLiteral() {
-    test("(![])", "false");
-    test("(![1])", "false");
-    test("(![a])", "false");
-    testSame("(![foo()])");
-  }
-
   private static final List<String> LITERAL_OPERANDS =
       ImmutableList.of(
           "null",
@@ -1092,7 +1004,7 @@
 
   private void assertSameResultsOrUncollapsed(String exprA, String exprB) {
     String resultA = process(exprA);
-    String resultB = process(exprB);  // TODO: why is nothing done with this?
+    String resultB = process(exprB);
     if (resultA.equals(print(exprA))) {
       foldSame(exprA);
       foldSame(exprB);
