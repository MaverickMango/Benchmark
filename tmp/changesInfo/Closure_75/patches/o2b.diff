diff -r -u original/src/com/google/javascript/jscomp/NodeUtil.java buggy/src/com/google/javascript/jscomp/NodeUtil.java
--- original/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-13 15:31:42.703097639 +0800
+++ buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:26.006736063 +0800
@@ -25,6 +25,8 @@
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
+import com.google.javascript.rhino.jstype.FunctionType;
+import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.TernaryValue;
 
 import java.util.Arrays;
@@ -67,45 +69,52 @@
    * Note: unlike getBooleanValue this function does not return UNKNOWN
    * for expressions with side-effects.
    */
-  static TernaryValue getExpressionBooleanValue(Node n) {
+  static TernaryValue getImpureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.ASSIGN:
       case Token.COMMA:
         // For ASSIGN and COMMA the value is the value of the RHS.
-        return getExpressionBooleanValue(n.getLastChild());
+        return getImpureBooleanValue(n.getLastChild());
       case Token.NOT:
-        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue value = getImpureBooleanValue(n.getLastChild());
         return value.not();
       case Token.AND: {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
       case Token.OR:  {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
       case Token.HOOK:  {
-        TernaryValue trueValue = getExpressionBooleanValue(
+        TernaryValue trueValue = getImpureBooleanValue(
             n.getFirstChild().getNext());
-        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
         } else {
           return TernaryValue.UNKNOWN;
         }
       }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // ignoring side-effects
+        return TernaryValue.TRUE;
+
       default:
-        return getBooleanValue(n);
+        return getPureBooleanValue(n);
     }
   }
 
   /**
    * Gets the boolean value of a node that represents a literal. This method
-   * effectively emulates the <code>Boolean()</code> JavaScript cast function.
+   * effectively emulates the <code>Boolean()</code> JavaScript cast function
+   * except it return UNKNOWN for known values with side-effects, use
+   * getExpressionBooleanValue if you don't care about side-effects.
    */
-  static TernaryValue getBooleanValue(Node n) {
+  static TernaryValue getPureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
@@ -113,6 +122,9 @@
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
 
+      case Token.NOT:
+        return getPureBooleanValue(n.getLastChild()).not();
+
       case Token.NULL:
       case Token.FALSE:
       case Token.VOID:
@@ -131,10 +143,14 @@
         break;
 
       case Token.TRUE:
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
       case Token.REGEXP:
         return TernaryValue.TRUE;
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        if (!mayHaveSideEffects(n)) {
+          return TernaryValue.TRUE;
+        }
     }
 
     return TernaryValue.UNKNOWN;
@@ -147,7 +163,7 @@
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): Convert constant array, object, and regex literals as well.
+    // TODO(user): regex literals as well.
     switch (n.getType()) {
       case Token.STRING:
         return n.getString();
@@ -179,11 +195,57 @@
 
       case Token.VOID:
         return "undefined";
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? "false" : "true"; // reversed.
+        }
+        break;
+
+      case Token.ARRAYLIT:
+        return arrayToString(n);
+
+      case Token.OBJECTLIT:
+        return "[object Object]";
     }
     return null;
   }
 
   /**
+   * When converting arrays to string using Array.prototype.toString or
+   * Array.prototype.join, the rules for conversion to String are different
+   * than converting each element individually.  Specifically, "null" and
+   * "undefined" are converted to an empty string.
+   * @param n A node that is a member of an Array.
+   * @return The string representation.
+   */
+  static String getArrayElementStringValue(Node n) {
+    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)
+        ? "" : getStringValue(n);
+  }
+
+  static String arrayToString(Node literal) {
+    Node first = literal.getFirstChild();
+    StringBuilder result = new StringBuilder();
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
+    for (Node n = first; n != null; n = n.getNext()) {
+      String childValue = getArrayElementStringValue(n);
+      if (childValue == null) {
+        return null;
+      }
+      if (n != first) {
+        result.append(',');
+      }
+      result.append(childValue);
+
+      nextSlot++;
+    }
+    return result.toString();
+  }
+
+  /**
    * Gets the value of a node as a Number, or null if it cannot be converted.
    * When it returns a non-null Double, this method effectively emulates the
    * <code>Number()</code> JavaScript cast function.
@@ -228,48 +290,64 @@
         }
         return null;
 
-      case Token.STRING:
-        String s = trimJsWhiteSpace(n.getString());
-        // return ScriptRuntime.toNumber(s);
-        if (s.length() == 0) {
-          return 0.0;
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
         }
+        break;
 
-        if (s.length() > 2
-            && s.charAt(0) == '0'
-            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
-          // Attempt to convert hex numbers.
-          try {
-            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
-          } catch (NumberFormatException e) {
-            return Double.NaN;
-          }
-        }
+      case Token.STRING:
+        return getStringNumberValue(n.getString());
 
-        if (s.length() > 3
-            && (s.charAt(0) == '-' || s.charAt(0) == '+')
-            && s.charAt(1) == '0'
-            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
-          // hex numbers with explicit signs vary between browsers.
-          return null;
-        }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        String value = getStringValue(n);
+        return value != null ? getStringNumberValue(value) : null;
+    }
 
-        // FireFox and IE treat the "Infinity" differently. FireFox is case
-        // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
-        if (s.equals("infinity")
-            || s.equals("-infinity")
-            || s.equals("+infinity")) {
-          return null;
-        }
+    return null;
+  }
 
-        try {
-          return Double.parseDouble(s);
-        } catch (NumberFormatException e) {
-          return Double.NaN;
-        }
+  static Double getStringNumberValue(String rawJsString) {
+    String s = trimJsWhiteSpace(rawJsString);
+    // return ScriptRuntime.toNumber(s);
+    if (s.length() == 0) {
+      return 0.0;
+    }
+
+    if (s.length() > 2
+        && s.charAt(0) == '0'
+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+      // Attempt to convert hex numbers.
+      try {
+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+      } catch (NumberFormatException e) {
+        return Double.NaN;
+      }
     }
 
-    return null;
+    if (s.length() > 3
+        && (s.charAt(0) == '-' || s.charAt(0) == '+')
+        && s.charAt(1) == '0'
+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+      // hex numbers with explicit signs vary between browsers.
+      return null;
+    }
+
+    // FireFox and IE treat the "Infinity" differently. FireFox is case
+    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+    if (s.equals("infinity")
+        || s.equals("-infinity")
+        || s.equals("+infinity")) {
+      return null;
+    }
+
+    try {
+      return Double.parseDouble(s);
+    } catch (NumberFormatException e) {
+      return Double.NaN;
+    }
   }
 
   static String trimJsWhiteSpace(String s) {
@@ -388,6 +466,8 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
+      case Token.NOT:
+        return isImmutableValue(n.getFirstChild());
       case Token.VOID:
       case Token.NEG:
         return isImmutableValue(n.getFirstChild());
@@ -428,6 +508,15 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if (child.getType() != Token.EMPTY
+              && !isLiteralValue(child, includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.REGEXP:
         // Return true only if all children are const.
         for (Node child = n.getFirstChild(); child != null;
@@ -1060,7 +1149,6 @@
       case Token.NUMBER:
       case Token.OBJECTLIT:
       case Token.REGEXP:
-      case Token.RETURN:
       case Token.STRING:
       case Token.THIS:
       case Token.TRUE:
@@ -1073,12 +1161,47 @@
   }
 
   /**
+   * Apply the supplied predicate against the potential
+   * all possible result of the expression.
+   */
+  static boolean valueCheck(Node n, Predicate<Node> p) {
+    switch (n.getType()) {
+      case Token.ASSIGN:
+      case Token.COMMA:
+        return valueCheck(n.getLastChild(), p);
+      case Token.AND:
+      case Token.OR:
+        return valueCheck(n.getFirstChild(), p)
+            && valueCheck(n.getLastChild(), p);
+      case Token.HOOK:
+        return valueCheck(n.getFirstChild().getNext(), p)
+            && valueCheck(n.getLastChild(), p);
+      default:
+        return p.apply(n);
+    }
+  }
+
+  static class NumbericResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isNumericResultHelper(n);
+    }
+  }
+
+  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
+      new NumbericResultPredicate();
+
+  /**
    * Returns true if the result of node evaluation is always a number
    */
   static boolean isNumericResult(Node n) {
+    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);
+  }
+
+  static boolean isNumericResultHelper(Node n) {
     switch (n.getType()) {
-      // NOTE: ADD is deliberately excluded as it may produce
-      // a string.
+      case Token.ADD:
+        return !mayBeString(n.getFirstChild())
+            && !mayBeString(n.getLastChild());
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
@@ -1110,12 +1233,23 @@
     }
   }
 
+  static class BooleanResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return isBooleanResultHelper(n);
+    }
+  }
+
+  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
+      new BooleanResultPredicate();
+
   /**
    * @return Whether the result of node evaluation is always a boolean
    */
   static boolean isBooleanResult(Node n) {
-    // TODO(johnlenz): Add a recursive option to recurse into
-    // AND, OR, HOOK, COMMA and ASSIGN, like "getExpressionBooleanValue".
+    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);
+  }
+
+  static boolean isBooleanResultHelper(Node n) {
     switch (n.getType()) {
       // Primitives
       case Token.TRUE:
@@ -1134,6 +1268,8 @@
       case Token.INSTANCEOF:
       // Inversion
       case Token.NOT:
+      // delete operator returns a boolean.
+      case Token.DELPROP:
         return true;
       default:
         return false;
@@ -1154,10 +1290,35 @@
     return n.getType() == Token.NULL;
   }
 
+  static boolean isNullOrUndefined(Node n) {
+    return isNull(n) || isUndefined(n);
+  }
+
+  static class MayBeStringResultPredicate implements Predicate<Node> {
+    public boolean apply(Node n) {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
+      new MayBeStringResultPredicate();
+
   /**
    * @returns Whether the results is possibly a string.
    */
   static boolean mayBeString(Node n) {
+    return mayBeString(n, true);
+  }
+
+  static boolean mayBeString(Node n, boolean recurse) {
+    if (recurse) {
+      return valueCheck(n, MAY_BE_STRING_PREDICATE);
+    } else {
+      return mayBeStringHelper(n);
+    }
+  }
+
+  static boolean mayBeStringHelper(Node n) {
     return !isNumericResult(n) && !isBooleanResult(n)
         && !isUndefined(n) && !isNull(n);
   }
@@ -1514,7 +1675,10 @@
    * @return Whether the node is used as a statement.
    */
   static boolean isStatement(Node n) {
-    Node parent = n.getParent();
+    return isStatementParent(n.getParent());
+  }
+
+  static boolean isStatementParent(Node parent) {
     // It is not possible to determine definitely if a node is a statement
     // or not if it is not part of the AST.  A FUNCTION node can be
     // either part of an expression or a statement.
@@ -1687,6 +1851,14 @@
     return node.getType() == Token.THIS;
   }
 
+
+  /**
+   * Is this an ARRAYLIT node
+   */
+  static boolean isArrayLiteral(Node node) {
+    return node.getType() == Token.ARRAYLIT;
+  }
+
   /**
    * Is this node or any of its children a CALL?
    */
@@ -1863,6 +2035,55 @@
   }
 
   /**
+   * Get the name of an object literal key.
+   *
+   * @param key A node
+   */
+  static String getObjectLitKeyName(Node key) {
+    switch (key.getType()) {
+      case Token.NUMBER:
+        return NodeUtil.getStringValue(key);
+      case Token.STRING:
+      case Token.GET:
+      case Token.SET:
+        return key.getString();
+    }
+    throw new IllegalStateException("Unexpected node type: " + key);
+  }
+
+  /**
+   * @param key A OBJECTLIT key node.
+   * @return The type expected when using the key.
+   */
+  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {
+    if (valueType != null) {
+      switch (key.getType()) {
+        case Token.GET:
+          // GET must always return a function type.
+          if (valueType.isFunctionType()) {
+            FunctionType fntype = ((FunctionType) valueType);
+            valueType = fntype.getReturnType();
+          } else {
+            return null;
+          }
+          break;
+        case Token.SET:
+          if (valueType.isFunctionType()) {
+            // SET must always return a function type.
+            FunctionType fntype = ((FunctionType) valueType);
+            Node param = fntype.getParametersNode().getFirstChild();
+            // SET function must always have one parameter.
+            valueType = param.getJSType();
+          } else {
+            return null;
+          }
+          break;
+      }
+    }
+    return valueType;
+  }
+
+  /**
    * Determines whether a node represents an object literal get or set key
    * (e.g. key1 in {get key1() {}, set key2(a){}).
    *
@@ -2293,7 +2514,6 @@
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
-    // TODO(johnlenz): Why this instead of the more common "undefined"?
     Node node = new Node(Token.VOID, Node.newNumber(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
@@ -2692,6 +2912,7 @@
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
+      case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
diff -r -u original/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
--- original/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-13 15:31:42.703097639 +0800
+++ buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-12 11:40:26.006736063 +0800
@@ -27,8 +27,9 @@
 import java.util.Set;
 
 /**
- * Tests for PeepholeFoldConstants in isolation. Tests for the interaction of
- * multiple peephole passes are in PeepholeIntegrationTest.
+ * Tests for {@link PeepholeFoldConstants} in isolation. Tests for
+ * the interaction of multiple peephole passes are in
+ * {@link PeepholeIntegrationTest}.
  */
 public class PeepholeFoldConstantsTest extends CompilerTestCase {
 
@@ -218,6 +219,8 @@
 
   public void testFoldLogicalOp() {
     fold("x = true && x", "x = x");
+    foldSame("x = [foo()] && x");
+
     fold("x = false && x", "x = false");
     fold("x = true || x", "x = true");
     fold("x = false || x", "x = x");
@@ -421,7 +424,7 @@
     fold("x = foo() + 'a' + 2", "x = foo()+\"a2\"");
     fold("x = '' + null", "x = \"null\"");
     fold("x = true + '' + false", "x = \"truefalse\"");
-    fold("x = '' + []", "x = \"\"+[]");      // cannot fold (but nice if we can)
+    fold("x = '' + []", "x = ''");      // cannot fold (but nice if we can)
   }
 
   public void testFoldConstructor() {
@@ -466,6 +469,10 @@
     foldSame("x = 'abcdef'.indexOf([1,2])");
   }
 
+  public void testStringJoinAddSparse() {
+    fold("x = [,,'a'].join(',')", "x = ',,a'");
+  }
+
   public void testStringJoinAdd() {
     fold("x = ['a', 'b', 'c'].join('')", "x = \"abc\"");
     fold("x = [].join(',')", "x = \"\"");
@@ -504,6 +511,12 @@
 
     fold("x = [1,2,3].join('abcdef')",
          "x = '1abcdef2abcdef3'");
+
+    fold("x = [1,2].join()", "x = '1,2'");
+    fold("x = [null,undefined,''].join(',')", "x = ',,'");
+    fold("x = [null,undefined,0].join(',')", "x = ',,0'");
+    // This can be folded but we don't currently.
+    foldSame("x = [[1,2],[3,4]].join()"); // would like: "x = '1,2,3,4'"
   }
 
   public void testStringJoinAdd_b1992789() {
@@ -544,11 +557,11 @@
     fold("x = 2.25 * 3", "x = 6.75");
     fold("z = x * y", "z = x * y");
     fold("x = y * 5", "x = y * 5");
-    fold("x = 1 / 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
+    fold("x = 1 / 0", "x = 1 / 0");
     fold("x = 3 % 2", "x = 1");
     fold("x = 3 % -2", "x = 1");
     fold("x = -1 % 3", "x = -1");
-    fold("x = 1 % 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
+    fold("x = 1 % 0", "x = 1 % 0");
   }
 
   public void testFoldArithmetic2() {
@@ -684,6 +697,7 @@
   }
 
   public void testFoldGetElem() {
+    fold("x = [,10][0]", "x = void 0");
     fold("x = [10, 20][0]", "x = 10");
     fold("x = [10, 20][1]", "x = 20");
     fold("x = [10, 20][0.5]", "",
@@ -702,7 +716,7 @@
 
   public void testFoldLeft() {
     foldSame("(+x - 1) + 2"); // not yet
-    foldSame("(+x + 1) + 2"); // not yet
+    fold("(+x + 1) + 2", "+x + 3");
   }
 
   public void testFoldArrayLength() {
@@ -711,6 +725,9 @@
     fold("x = [1,2,3].length", "x = 3");
     fold("x = [a,b].length", "x = 2");
 
+    // Not handled yet
+    fold("x = [,,1].length", "x = 3");
+
     // Cannot fold
     fold("x = [foo(), 0].length", "x = [foo(),0].length");
     fold("x = y.length", "x = y.length");
@@ -751,6 +768,8 @@
     fold("'' instanceof String", "false");
     fold("true instanceof Object", "false");
     fold("true instanceof Boolean", "false");
+    fold("!0 instanceof Object", "false");
+    fold("!0 instanceof Boolean", "false");
     fold("false instanceof Object", "false");
     fold("null instanceof Object", "false");
     fold("undefined instanceof Object", "false");
@@ -849,6 +868,8 @@
   public void testFoldLeftChildConcat() {
     foldSame("x +5 + \"1\"");
     fold("x+\"5\" + \"1\"", "x + \"51\"");
+    // fold("\"a\"+(c+\"b\")","\"a\"+c+\"b\"");
+    fold("\"a\"+(\"b\"+c)","\"ab\"+c");
   }
 
   public void testFoldLeftChildOp() {
@@ -900,6 +921,73 @@
     fold("x/false", "x/0");  // should we add an error check? :)
   }
 
+  public void testNotFoldBackToTrueFalse() {
+    foldSame("!0");
+    foldSame("!1");
+    fold("!3", "false");
+  }
+
+  public void testFoldBangConstants() {
+    fold("1 + !0", "2");
+    fold("1 + !1", "1");
+    fold("'a ' + !1", "'a false'");
+    fold("'a ' + !0", "'a true'");
+  }
+
+  public void testFoldMixed() {
+    fold("''+[1]", "'1'");
+    foldSame("false+[]"); // would like: "\"false\""
+  }
+
+  public void testFoldVoid() {
+    foldSame("void 0");
+    fold("void 1", "void 0");
+    fold("void x", "void 0");
+    fold("void x()", "void x()");
+  }
+
+  public void testJoinBug() {
+    fold("var x = [].join();", "var x = '';");
+    fold("var x = [x].join();", "var x = '' + x;");
+    foldSame("var x = [x,y].join();");
+    foldSame("var x = [x,y,z].join();");
+
+    foldSame("shape['matrix'] = [\n" +
+            "    Number(headingCos2).toFixed(4),\n" +
+            "    Number(-headingSin2).toFixed(4),\n" +
+            "    Number(headingSin2 * yScale).toFixed(4),\n" +
+            "    Number(headingCos2 * yScale).toFixed(4),\n" +
+            "    0,\n" +
+            "    0\n" +
+            "  ].join()");
+  }
+
+  public void testToUpper() {
+    fold("'a'.toUpperCase()", "'A'");
+    fold("'A'.toUpperCase()", "'A'");
+    fold("'aBcDe'.toUpperCase()", "'ABCDE'");
+  }
+
+  public void testToLower() {
+    fold("'A'.toLowerCase()", "'a'");
+    fold("'a'.toLowerCase()", "'a'");
+    fold("'aBcDe'.toLowerCase()", "'abcde'");
+  }
+
+  public void testObjectLiteral() {
+    test("(!{})", "false");
+    test("(!{a:1})", "false");
+    testSame("(!{a:foo()})");
+    testSame("(!{'a':foo()})");
+  }
+
+  public void testArrayLiteral() {
+    test("(![])", "false");
+    test("(![1])", "false");
+    test("(![a])", "false");
+    testSame("(![foo()])");
+  }
+
   private static final List<String> LITERAL_OPERANDS =
       ImmutableList.of(
           "null",
@@ -1004,7 +1092,7 @@
 
   private void assertSameResultsOrUncollapsed(String exprA, String exprB) {
     String resultA = process(exprA);
-    String resultB = process(exprB);
+    String resultB = process(exprB);  // TODO: why is nothing done with this?
     if (resultA.equals(print(exprA))) {
       foldSame(exprA);
       foldSame(exprB);
