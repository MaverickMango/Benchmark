diff --git a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
index 49829a3..35b48e5 100644
--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
@@ -82,7 +82,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AgeCalculator is a small Swing application that computes age from a specific
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
index 0530598..9431d60 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
@@ -63,7 +63,7 @@
 
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 
 /**
  * DateTimePerformance provides various comparisons between the Java supplied
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index e767880..bc32ed4 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -56,7 +56,7 @@
 import java.io.Serializable;
 import java.util.Locale;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.DateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 57d8982..bb4b540 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -57,7 +57,7 @@
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Locale;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AbstractInstant provides the common behaviour for instant classes.
diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index a06bc39..05a155a 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -53,7 +53,7 @@
  */
 package org.joda.time;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.IntervalConverter;
 import org.joda.time.format.DateTimePrinter;
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 2bb943b..9e67082 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -56,7 +56,7 @@
 import java.io.Serializable;
 import java.util.Locale;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.DateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index 1c5e772..c97580e 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -53,50 +53,38 @@
  */
 package org.joda.time;
 
-import java.io.Serializable;
-import org.joda.time.chrono.UnsupportedDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-
 /**
- * Chronology provides access to the individual date time fields for
- * a chronological calendar system.
- * Various chronologies are supported by subclasses including ISO and 
- * GregorianJulian. 
+ * Chronology provides access to the individual date time fields for a
+ * chronological calendar system. Various chronologies are supported by
+ * subclasses including ISO and GregorianJulian.
  * <p>
  * This class defines a number of fields with names from the ISO8601 standard.
  * Chronology does not 'strongly' define these fields however, thus subclasses
  * are free to interpret the field names as they wish. For example, a week
  * could be defined as 10 days and a month as 40 days in a special
- * WeirdChronology subclass. Clearly the GJ and ISO implementations provided
- * use the field names as you would expect.
- * <p>
- * Chronology is thread-safe and immutable, and all subclasses must be as well.
+ * WeirdChronology implementation. Clearly the GJ and ISO implementations
+ * provided use the field names as you would expect.
  * 
- * @see org.joda.time.chrono.iso.ISOChronology
- * @see org.joda.time.chrono.gj.GJChronology
+ * @see org.joda.time.chrono.ISOChronology
+ * @see org.joda.time.chrono.GJChronology
+ * @see org.joda.time.chrono.GregorianChronology
+ * @see org.joda.time.chrono.JulianChronology
+ * @see org.joda.time.chrono.CopticChronology
+ * @see org.joda.time.chrono.BuddhistChronology
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public abstract class Chronology implements Serializable {
+public interface Chronology {
     
-    static final long serialVersionUID = -7310865996721419676L;
-
-    /**
-     * Restricted constructor
-     */
-    protected Chronology() {
-        super();
-    }
-
     /**
      * Returns the DateTimeZone that this Chronology operates in, or null if
      * unspecified.
      *
      * @return DateTimeZone null if unspecified
      */
-    public abstract DateTimeZone getDateTimeZone();
+    DateTimeZone getDateTimeZone();
 
     /**
      * Returns an instance of this Chronology that operates in the UTC time
@@ -105,7 +93,7 @@
      *
      * @return a version of this chronology that ignores time zones
      */
-    public abstract Chronology withUTC();
+    Chronology withUTC();
     
     /**
      * Returns an instance of this Chronology that operates in any time zone.
@@ -114,7 +102,7 @@
      * @param zone to use, or default if null
      * @see org.joda.time.chrono.ZonedChronology
      */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+    Chronology withDateTimeZone(DateTimeZone zone);
 
     /**
      * Returns a date-only millisecond instant, by clearing the time fields
@@ -127,9 +115,7 @@
      * @return millisecond instant from 1970-01-01T00:00:00Z with the time part
      * cleared
      */
-    public long getDateOnlyMillis(long instant) {
-        return dayOfYear().roundFloor(instant);
-    }
+    long getDateOnlyMillis(long instant);
 
     /**
      * Returns a date-only millisecond instant, formed from the given year,
@@ -145,11 +131,8 @@
      * @return millisecond instant from 1970-01-01T00:00:00Z without any time
      * part
      */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
+    long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException;
 
     /**
      * Returns a time-only millisecond instant, by clearing the date fields
@@ -162,9 +145,7 @@
      * @return millisecond instant from 1970-01-01T00:00:00Z with the date part
      * cleared
      */
-    public long getTimeOnlyMillis(long instant) {
-        return dayOfYear().remainder(instant);
-    }
+    long getTimeOnlyMillis(long instant);
 
     /**
      * Returns a time-only millisecond instant, formed from the given hour,
@@ -182,15 +163,9 @@
      * @return millisecond instant from 1970-01-01T00:00:00Z without any date
      * part
      */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, formed from the given year,
@@ -207,15 +182,8 @@
      * @param millisOfDay millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
-    }
+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, from from the given instant,
@@ -234,16 +202,10 @@
      * @param millisOfSecond millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getDateTimeMillis(long instant,
+                           int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, formed from the given year,
@@ -264,19 +226,10 @@
      * @param millisOfSecond millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                           int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     // Millis
     //-----------------------------------------------------------------------
@@ -285,27 +238,21 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField millis() {
-        return UnsupportedDurationField.getInstance("millis");
-    }
+    DurationField millis();
 
     /**
      * Get the millis of second field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField millisOfSecond() {
-        return UnsupportedDateTimeField.getInstance("millisOfSecond", millis());
-    }
+    DateTimeField millisOfSecond();
 
     /**
      * Get the millis of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField millisOfDay() {
-        return UnsupportedDateTimeField.getInstance("millisOfDay", millis());
-    }
+    DateTimeField millisOfDay();
 
     // Second
     //-----------------------------------------------------------------------
@@ -314,27 +261,21 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField seconds() {
-        return UnsupportedDurationField.getInstance("seconds");
-    }
+    DurationField seconds();
 
     /**
      * Get the second of minute field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField secondOfMinute() {
-        return UnsupportedDateTimeField.getInstance("secondOfMinute", seconds());
-    }
+    DateTimeField secondOfMinute();
 
     /**
      * Get the second of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField secondOfDay() {
-        return UnsupportedDateTimeField.getInstance("secondOfDay", seconds());
-    }
+    DateTimeField secondOfDay();
 
     // Minute
     //-----------------------------------------------------------------------
@@ -343,27 +284,21 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField minutes() {
-        return UnsupportedDurationField.getInstance("minutes");
-    }
+    DurationField minutes();
 
     /**
      * Get the minute of hour field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField minuteOfHour() {
-        return UnsupportedDateTimeField.getInstance("minuteOfHour", minutes());
-    }
+    DateTimeField minuteOfHour();
 
     /**
      * Get the minute of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField minuteOfDay() {
-        return UnsupportedDateTimeField.getInstance("minuteOfDay", minutes());
-    }
+    DateTimeField minuteOfDay();
 
     // Hour
     //-----------------------------------------------------------------------
@@ -372,55 +307,42 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField hours() {
-        return UnsupportedDurationField.getInstance("hours");
-    }
+    DurationField hours();
 
     /**
      * Get the hour of day (0-23) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField hourOfDay() {
-        return UnsupportedDateTimeField.getInstance("hourOfDay", hours());
-    }
+    DateTimeField hourOfDay();
 
     /**
      * Get the hour of day (offset to 1-24) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField clockhourOfDay() {
-        return UnsupportedDateTimeField.getInstance("clockhourOfDay", hours());
-    }
+    DateTimeField clockhourOfDay();
 
     /**
      * Get the hour of am/pm (0-11) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField hourOfHalfday() {
-        return UnsupportedDateTimeField.getInstance("hourOfHalfday", hours());
-    }
+    DateTimeField hourOfHalfday();
 
     /**
      * Get the hour of am/pm (offset to 1-12) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField clockhourOfHalfday() {
-        return UnsupportedDateTimeField.getInstance("clockhourOfHalfday", hours());
-    }
+    DateTimeField clockhourOfHalfday();
 
     /**
      * Get the AM(0) PM(1) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField halfdayOfDay() {
-        return UnsupportedDateTimeField.getInstance
-            ("halfdayOfDay", UnsupportedDurationField.getInstance("halfdays"));
-    }
+    DateTimeField halfdayOfDay();
 
     // Day
     //-----------------------------------------------------------------------
@@ -429,9 +351,7 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField days() {
-        return UnsupportedDurationField.getInstance("days");
-    }
+    DurationField days();
 
     /**
      * Get the day of week field for this chronology.
@@ -441,27 +361,21 @@
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfWeek() {
-        return UnsupportedDateTimeField.getInstance("dayOfWeek", days());
-    }
+    DateTimeField dayOfWeek();
 
     /**
      * Get the day of month field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfMonth() {
-        return UnsupportedDateTimeField.getInstance("dayOfMonth", days());
-    }
+    DateTimeField dayOfMonth();
 
     /**
      * Get the day of year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfYear() {
-        return UnsupportedDateTimeField.getInstance("dayOfYear", days());
-    }
+    DateTimeField dayOfYear();
 
     // Week
     //-----------------------------------------------------------------------
@@ -470,36 +384,28 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField weeks() {
-        return UnsupportedDurationField.getInstance("weeks");
-    }
+    DurationField weeks();
 
     /**
      * Get the week of a week based year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField weekOfWeekyear() {
-        return UnsupportedDateTimeField.getInstance("weekOfWeekyear", weeks());
-    }
+    DateTimeField weekOfWeekyear();
 
     /**
      * Get the weekyears duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField weekyears() {
-        return UnsupportedDurationField.getInstance("weekyears");
-    }
+    DurationField weekyears();
 
     /**
      * Get the year of a week based year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField weekyear() {
-        return UnsupportedDateTimeField.getInstance("weekyear", weekyears());
-    }
+    DateTimeField weekyear();
 
     // Month
     //-----------------------------------------------------------------------
@@ -508,18 +414,14 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField months() {
-        return UnsupportedDurationField.getInstance("months");
-    }
+    DurationField months();
 
     /**
      * Get the month of year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField monthOfYear() {
-        return UnsupportedDateTimeField.getInstance("monthOfYear", months());
-    }
+    DateTimeField monthOfYear();
 
     // Year
     //-----------------------------------------------------------------------
@@ -528,78 +430,62 @@
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField years() {
-        return UnsupportedDurationField.getInstance("years");
-    }
+    DurationField years();
 
     /**
      * Get the year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField year() {
-        return UnsupportedDateTimeField.getInstance("year", years());
-    }
+    DateTimeField year();
 
     /**
      * Get the year of era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField yearOfEra() {
-        return UnsupportedDateTimeField.getInstance("yearOfEra", years());
-    }
+    DateTimeField yearOfEra();
 
     /**
      * Get the year of century field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField yearOfCentury() {
-        return UnsupportedDateTimeField.getInstance("yearOfCentury", years());
-    }
+    DateTimeField yearOfCentury();
 
     /**
      * Get the centuries duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField centuries() {
-        return UnsupportedDurationField.getInstance("centuries");
-    }
+    DurationField centuries();
 
     /**
      * Get the century of era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField centuryOfEra() {
-        return UnsupportedDateTimeField.getInstance("centuryOfEra", centuries());
-    }
+    DateTimeField centuryOfEra();
 
     /**
      * Get the eras duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField eras() {
-        return UnsupportedDurationField.getInstance("eras");
-    }
+    DurationField eras();
 
     /**
      * Get the era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField era() {
-        return UnsupportedDateTimeField.getInstance("era", eras());
-    }
+    DateTimeField era();
 
     /**
      * Gets a debugging toString.
      * 
      * @return a debugging string
      */
-    public abstract String toString();
+    String toString();
 
 }
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 3f1feaa..07a6647 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 837044d..81621fd 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -54,11 +54,11 @@
 package org.joda.time;
 
 import java.io.Serializable;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.PreciseDurationField;
-import org.joda.time.chrono.ScaledDurationField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.PreciseDurationField;
+import org.joda.time.field.ScaledDurationField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * Controls a duration implementation by specifying which duration fields are to be used.
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index c368fab..d09fae2 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 780f01b..40b4868 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.convert.InstantConverter;
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index ae56ab3..79ede70 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index 3253d00..00cf0bf 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
new file mode 100644
index 0000000..46c3787
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
@@ -0,0 +1,600 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+
+import org.joda.time.Chronology;
+// Import for @link support
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.UnsupportedDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+
+/**
+ * AbstractChronology provides a skeleton implementation for chronology
+ * classes. Many utility methods are defined, but all fields are unsupported.
+ * <p>
+ * AbstractChronology is thread-safe and immutable, and all subclasses must be
+ * as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractChronology implements Chronology, Serializable {
+    
+    static final long serialVersionUID = -7310865996721419676L;
+
+    /**
+     * Restricted constructor
+     */
+    protected AbstractChronology() {
+        super();
+    }
+
+    /**
+     * Returns the DateTimeZone that this Chronology operates in, or null if
+     * unspecified.
+     *
+     * @return DateTimeZone null if unspecified
+     */
+    public abstract DateTimeZone getDateTimeZone();
+
+    /**
+     * Returns an instance of this Chronology that operates in the UTC time
+     * zone. Chronologies that do not operate in a time zone or are already
+     * UTC must return themself.
+     *
+     * @return a version of this chronology that ignores time zones
+     */
+    public abstract Chronology withUTC();
+    
+    /**
+     * Returns an instance of this Chronology that operates in any time zone.
+     *
+     * @return a version of this chronology with a specific time zone
+     * @param zone to use, or default if null
+     * @see org.joda.time.chrono.ZonedChronology
+     */
+    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+
+    /**
+     * Returns a date-only millisecond instant, by clearing the time fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().roundFloor(instant)</code>.
+     * 
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part
+     * cleared
+     */
+    public long getDateOnlyMillis(long instant) {
+        return dayOfYear().roundFloor(instant);
+    }
+
+    /**
+     * Returns a date-only millisecond instant, formed from the given year,
+     * month, and day values. The set of given values must refer to a valid
+     * date, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation simply returns
+     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any time
+     * part
+     */
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, by clearing the date fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().remainder(instant)</code>.
+     * 
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part
+     * cleared
+     */
+    public long getTimeOnlyMillis(long instant) {
+        return dayOfYear().remainder(instant);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, formed from the given hour,
+     * minute, second, and millisecond values. The set of given values must
+     * refer to a valid time, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any date
+     * part
+     */
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = hourOfDay().set(0, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, and millisecond values. The set of given values must refer
+     * to a valid datetime, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param millisOfDay millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        return millisOfDay().set(instant, millisOfDay);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, from from the given instant,
+     * hour, minute, second, and millisecond values. The set of given values
+     * must refer to a valid datetime, or else an IllegalArgumentException is
+     * thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param instant instant to start from
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, hour, minute, second, and millisecond values. The set of
+     * given values must refer to a valid datetime, or else an
+     * IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    // Millis
+    //-----------------------------------------------------------------------
+    /**
+     * Get the millis duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField millis() {
+        return UnsupportedDurationField.getInstance("millis");
+    }
+
+    /**
+     * Get the millis of second field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField millisOfSecond() {
+        return UnsupportedDateTimeField.getInstance("millisOfSecond", millis());
+    }
+
+    /**
+     * Get the millis of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField millisOfDay() {
+        return UnsupportedDateTimeField.getInstance("millisOfDay", millis());
+    }
+
+    // Second
+    //-----------------------------------------------------------------------
+    /**
+     * Get the seconds duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField seconds() {
+        return UnsupportedDurationField.getInstance("seconds");
+    }
+
+    /**
+     * Get the second of minute field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField secondOfMinute() {
+        return UnsupportedDateTimeField.getInstance("secondOfMinute", seconds());
+    }
+
+    /**
+     * Get the second of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField secondOfDay() {
+        return UnsupportedDateTimeField.getInstance("secondOfDay", seconds());
+    }
+
+    // Minute
+    //-----------------------------------------------------------------------
+    /**
+     * Get the minutes duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField minutes() {
+        return UnsupportedDurationField.getInstance("minutes");
+    }
+
+    /**
+     * Get the minute of hour field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField minuteOfHour() {
+        return UnsupportedDateTimeField.getInstance("minuteOfHour", minutes());
+    }
+
+    /**
+     * Get the minute of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField minuteOfDay() {
+        return UnsupportedDateTimeField.getInstance("minuteOfDay", minutes());
+    }
+
+    // Hour
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hours duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField hours() {
+        return UnsupportedDurationField.getInstance("hours");
+    }
+
+    /**
+     * Get the hour of day (0-23) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField hourOfDay() {
+        return UnsupportedDateTimeField.getInstance("hourOfDay", hours());
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField clockhourOfDay() {
+        return UnsupportedDateTimeField.getInstance("clockhourOfDay", hours());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField hourOfHalfday() {
+        return UnsupportedDateTimeField.getInstance("hourOfHalfday", hours());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField clockhourOfHalfday() {
+        return UnsupportedDateTimeField.getInstance("clockhourOfHalfday", hours());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField halfdayOfDay() {
+        return UnsupportedDateTimeField.getInstance
+            ("halfdayOfDay", UnsupportedDurationField.getInstance("halfdays"));
+    }
+
+    // Day
+    //-----------------------------------------------------------------------
+    /**
+     * Get the days duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField days() {
+        return UnsupportedDurationField.getInstance("days");
+    }
+
+    /**
+     * Get the day of week field for this chronology.
+     *
+     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.
+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfWeek() {
+        return UnsupportedDateTimeField.getInstance("dayOfWeek", days());
+    }
+
+    /**
+     * Get the day of month field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfMonth() {
+        return UnsupportedDateTimeField.getInstance("dayOfMonth", days());
+    }
+
+    /**
+     * Get the day of year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfYear() {
+        return UnsupportedDateTimeField.getInstance("dayOfYear", days());
+    }
+
+    // Week
+    //-----------------------------------------------------------------------
+    /**
+     * Get the weeks duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weeks() {
+        return UnsupportedDurationField.getInstance("weeks");
+    }
+
+    /**
+     * Get the week of a week based year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField weekOfWeekyear() {
+        return UnsupportedDateTimeField.getInstance("weekOfWeekyear", weeks());
+    }
+
+    /**
+     * Get the weekyears duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weekyears() {
+        return UnsupportedDurationField.getInstance("weekyears");
+    }
+
+    /**
+     * Get the year of a week based year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField weekyear() {
+        return UnsupportedDateTimeField.getInstance("weekyear", weekyears());
+    }
+
+    // Month
+    //-----------------------------------------------------------------------
+    /**
+     * Get the months duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField months() {
+        return UnsupportedDurationField.getInstance("months");
+    }
+
+    /**
+     * Get the month of year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField monthOfYear() {
+        return UnsupportedDateTimeField.getInstance("monthOfYear", months());
+    }
+
+    // Year
+    //-----------------------------------------------------------------------
+    /**
+     * Get the years duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField years() {
+        return UnsupportedDurationField.getInstance("years");
+    }
+
+    /**
+     * Get the year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField year() {
+        return UnsupportedDateTimeField.getInstance("year", years());
+    }
+
+    /**
+     * Get the year of era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField yearOfEra() {
+        return UnsupportedDateTimeField.getInstance("yearOfEra", years());
+    }
+
+    /**
+     * Get the year of century field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField yearOfCentury() {
+        return UnsupportedDateTimeField.getInstance("yearOfCentury", years());
+    }
+
+    /**
+     * Get the centuries duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField centuries() {
+        return UnsupportedDurationField.getInstance("centuries");
+    }
+
+    /**
+     * Get the century of era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField centuryOfEra() {
+        return UnsupportedDateTimeField.getInstance("centuryOfEra", centuries());
+    }
+
+    /**
+     * Get the eras duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField eras() {
+        return UnsupportedDurationField.getInstance("eras");
+    }
+
+    /**
+     * Get the era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField era() {
+        return UnsupportedDateTimeField.getInstance("era", eras());
+    }
+
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public abstract String toString();
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
deleted file mode 100644
index d1514cc..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
+++ /dev/null
@@ -1,621 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import java.util.Locale;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * AbstractDateTimeField provides the common behaviour for DateTimeField
- * implementations. 
- * <p>
- * This class should generally not be used directly by API users. The
- * DateTimeField interface should be used when different kinds of DateTimeField
- * objects are to be referenced.
- * <p>
- * AbstractDateTimeField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DecoratedDateTimeField
- */
-public abstract class AbstractDateTimeField implements DateTimeField, Serializable {
-
-    static final long serialVersionUID = -4388055220581798589L;
-
-    /** A desriptive name for the field */
-    private final String iName;
-
-    /**
-     * Constructor.
-     */
-    protected AbstractDateTimeField(String name) {
-        super();
-        if (name == null) {
-            throw new IllegalArgumentException("The name must not be null");
-        }
-        iName = name;
-    }
-    
-    public final String getName() {
-        return iName;
-    }
-
-    /**
-     * @return true always
-     */
-    public final boolean isSupported() {
-        return true;
-    }
-
-    // Main access API
-    //------------------------------------------------------------------------
-    /**
-     * Get the value of this field from the milliseconds.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the value of the field, in the units of the field
-     */
-    public abstract int get(long instant);
-
-    /**
-     * Get the human-readable, text value of this field from the milliseconds.
-     * If the specified locale is null, the default locale is used.
-     * <p>
-     * The default implementation returns Integer.toString(get(instant)).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getMaximumTextLength.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
-     * @return the text value of the field
-     */
-    public String getAsText(long instant, Locale locale) {
-        return Integer.toString(get(instant));
-    }
-
-    /**
-     * Get the human-readable, text value of this field from the milliseconds.
-     * This implementation returns getAsText(instant, null).
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the text value of the field
-     */
-    public final String getAsText(long instant) {
-        return getAsText(instant, null);
-    }
-
-    /**
-     * Get the human-readable, short text value of this field from the
-     * milliseconds.  If the specified locale is null, the default locale is
-     * used.
-     * <p>
-     * The default implementation returns getAsText(instant, locale).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getMaximumShortTextLength.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
-     * @return the short text value of the field
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        return getAsText(instant, locale);
-    }
-
-    /**
-     * Get the human-readable, short text value of this field from the
-     * milliseconds.  This implementation returns getAsShortText(instant, null).
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the short text value of the field
-     */
-    public final String getAsShortText(long instant) {
-        return getAsShortText(instant, null);
-    }
-
-    /**
-     * Adds a value (which may be negative) to the instant value,
-     * overflowing into larger fields if necessary.
-     * <p>
-     * The value will be added to this field. If the value is too large to be
-     * added solely to this field, larger fields will increase as required.
-     * Smaller fields should be unaffected, except where the result would be
-     * an invalid value for a smaller field. In this case the smaller field is
-     * adjusted to be in range.
-     * <p>
-     * For example, in the ISO chronology:<br>
-     * 2000-08-20 add six months is 2001-02-20<br>
-     * 2000-08-20 add twenty months is 2002-04-20<br>
-     * 2000-08-20 add minus nine months is 1999-11-20<br>
-     * 2001-01-31 add one month  is 2001-02-28<br>
-     * 2001-01-31 add two months is 2001-03-31<br>
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param value  the value to add, in the units of the field
-     * @return the updated milliseconds
-     */
-    public long add(long instant, int value) {
-        return getDurationField().add(instant, value);
-    }
-
-    /**
-     * Adds a value (which may be negative) to the instant value,
-     * overflowing into larger fields if necessary.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param value  the long value to add, in the units of the field
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if value is too large
-     * @see #add(long,int)
-     */
-    public long add(long instant, long value) {
-        return getDurationField().add(instant, value);
-    }
-
-    /**
-     * Adds a value (which may be negative) to the instant value,
-     * wrapping within this field.
-     * <p>
-     * The value will be added to this field. If the value is too large to be
-     * added solely to this field then it wraps. Larger fields are always
-     * unaffected. Smaller fields should be unaffected, except where the
-     * result would be an invalid value for a smaller field. In this case the
-     * smaller field is adjusted to be in range.
-     * <p>
-     * For example, in the ISO chronology:<br>
-     * 2000-08-20 addWrapped six months is 2000-02-20<br>
-     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>
-     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>
-     * 2001-01-31 addWrapped one month  is 2001-02-28<br>
-     * 2001-01-31 addWrapped two months is 2001-03-31<br>
-     * <p>
-     * The default implementation internally calls set. Subclasses are
-     * encouraged to provide a more efficient implementation.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param value  the value to add, in the units of the field
-     * @return the updated milliseconds
-     */
-    public long addWrapped(long instant, int value) {
-        int current = get(instant);
-        int wrapped = Utils.getWrappedValue
-            (current, value, getMinimumValue(instant), getMaximumValue(instant));
-        return set(instant, wrapped);
-    }
-
-    /**
-     * Computes the difference between two instants, as measured in the units
-     * of this field. Any fractional units are dropped from the result. Calling
-     * getDifference reverses the effect of calling add. In the following code:
-     *
-     * <pre>
-     * long instant = ...
-     * int v = ...
-     * int age = getDifference(add(instant, v), instant);
-     * </pre>
-     *
-     * The value 'age' is the same as the value 'v'.
-     *
-     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract from
-     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract off the minuend
-     * @return the difference in the units of this field
-     */
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Computes the difference between two instants, as measured in the units
-     * of this field. Any fractional units are dropped from the result. Calling
-     * getDifference reverses the effect of calling add. In the following code:
-     *
-     * <pre>
-     * long instant = ...
-     * long v = ...
-     * long age = getDifferenceAsLong(add(instant, v), instant);
-     * </pre>
-     *
-     * The value 'age' is the same as the value 'v'.
-     *
-     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract from
-     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract off the minuend
-     * @return the difference in the units of this field
-     */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Sets a value in the milliseconds supplied.
-     * <p>
-     * The value of this field will be set. If the value is invalid, an
-     * exception if thrown. Other fields are always unaffected.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param value  the value to set, in the units of the field
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public abstract long set(long instant, int value);
-
-    /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. If the specified locale is null, the default locale is used.
-     * <p>
-     * The default implementation returns set(instant,
-     * Integer.parseInt(instant)).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getAsText.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param text  the text value to set
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if the text value is invalid
-     */
-    public long set(long instant, String text, Locale locale) {
-        try {
-            return set(instant, Integer.parseInt(text));
-        } catch (NumberFormatException ex) {
-            throw new IllegalArgumentException("Invalid " + getName() + " text: " + text);
-        }
-    }
-
-    /**
-     * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. This implementation returns set(instant, text, null).
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param text  the text value to set
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if the text value is invalid
-     */
-    public final long set(long instant, String text) {
-        return set(instant, text, null);
-    }
-
-    // Extra information API
-    //------------------------------------------------------------------------
-    /**
-     * Returns the duration per unit value of this field. For example, if this
-     * field represents "hour of day", then the unit duration is an hour.
-     *
-     * @return the duration of this field, or UnsupportedDurationField if field
-     * has no duration
-     */
-    public abstract DurationField getDurationField();
-
-    /**
-     * Returns the range duration of this field. For example, if this field
-     * represents "hour of day", then the range duration is a day.
-     *
-     * @return the range duration of this field, or null if field has no range
-     */
-    public abstract DurationField getRangeDurationField();
-
-    /**
-     * Returns whether this field is 'leap' for the specified instant.
-     * <p>
-     * For example, a leap year would return true, a non leap year would return
-     * false.
-     * <p>
-     * This implementation returns false.
-     * 
-     * @return true if the field is 'leap'
-     */
-    public boolean isLeap(long instant) {
-        return false;
-    }
-
-    /**
-     * Gets the amount by which this field is 'leap' for the specified instant.
-     * <p>
-     * For example, a leap year would return one, a non leap year would return
-     * zero.
-     * <p>
-     * This implementation returns zero.
-     */
-    public int getLeapAmount(long instant) {
-        return 0;
-    }
-
-    /**
-     * If this field were to leap, then it would be in units described by the
-     * returned duration. If this field doesn't ever leap, null is returned.
-     * <p>
-     * This implementation returns null.
-     */
-    public DurationField getLeapDurationField() {
-        return null;
-    }
-
-    /**
-     * Get the minimum allowable value for this field.
-     * 
-     * @return the minimum valid value for this field, in the units of the
-     * field
-     */
-    public abstract int getMinimumValue();
-
-    /**
-     * Get the minimum value for this field evaluated at the specified time.
-     * <p>
-     * This implementation returns the same as {@link #getMinimumValue()}.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the minimum value for this field, in the units of the field
-     */
-    public int getMinimumValue(long instant) {
-        return getMinimumValue();
-    }
-
-    /**
-     * Get the maximum allowable value for this field.
-     * 
-     * @return the maximum valid value for this field, in the units of the
-     * field
-     */
-    public abstract int getMaximumValue();
-
-    /**
-     * Get the maximum value for this field evaluated at the specified time.
-     * <p>
-     * This implementation returns the same as {@link #getMaximumValue()}.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the maximum value for this field, in the units of the field
-     */
-    public int getMaximumValue(long instant) {
-        return getMaximumValue();
-    }
-
-    /**
-     * Get the maximum text value for this field. The default implementation
-     * returns the equivalent of Integer.toString(getMaximumValue()).length().
-     * 
-     * @param locale  the locale to use for selecting a text symbol
-     * @return the maximum text length
-     */
-    public int getMaximumTextLength(Locale locale) {
-        int max = getMaximumValue();
-        if (max >= 0) {
-            if (max < 10) {
-                return 1;
-            } else if (max < 100) {
-                return 2;
-            } else if (max < 1000) {
-                return 3;
-            }
-        }
-        return Integer.toString(max).length();
-    }
-
-    /**
-     * Get the maximum short text value for this field. The default
-     * implementation returns getMaximumTextLength().
-     * 
-     * @param locale  the locale to use for selecting a text symbol
-     * @return the maximum short text length
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return getMaximumTextLength(locale);
-    }
-
-    // Calculation API
-    //------------------------------------------------------------------------
-    /**
-     * Round to the lowest whole unit of this field. After rounding, the value
-     * of this field and all fields of a higher magnitude are retained. The
-     * fractional millis that cannot be expressed in whole increments of this
-     * field are set to minimum.
-     * <p>
-     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
-     * lowest whole hour is 2002-11-02T23:00:00.000.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
-     * @return rounded milliseconds
-     */
-    public abstract long roundFloor(long instant);
-
-    /**
-     * Round to the highest whole unit of this field. The value of this field
-     * and all fields of a higher magnitude may be incremented in order to
-     * achieve this result. The fractional millis that cannot be expressed in
-     * whole increments of this field are set to minimum.
-     * <p>
-     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
-     * highest whole hour is 2002-11-03T00:00:00.000.
-     * <p>
-     * The default implementation calls roundFloor, and if the instant is
-     * modified as a result, adds one field unit. Subclasses are encouraged to
-     * provide a more efficient implementation.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
-     * @return rounded milliseconds
-     */
-    public long roundCeiling(long instant) {
-        long newInstant = roundFloor(instant);
-        if (newInstant != instant) {
-            instant = add(newInstant, 1);
-        }
-        return instant;
-    }
-
-    /**
-     * Round to the nearest whole unit of this field. If the given millisecond
-     * value is closer to the floor or is exactly halfway, this function
-     * behaves like roundFloor. If the millisecond value is closer to the
-     * ceiling, this function behaves like roundCeiling.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
-     * @return rounded milliseconds
-     */
-    public long roundHalfFloor(long instant) {
-        long floor = roundFloor(instant);
-        long ceiling = roundCeiling(instant);
-
-        long diffFromFloor = instant - floor;
-        long diffToCeiling = ceiling - instant;
-
-        if (diffFromFloor <= diffToCeiling) {
-            // Closer to the floor, or halfway - round floor
-            return floor;
-        } else {
-            return ceiling;
-        }
-    }
-
-    /**
-     * Round to the nearest whole unit of this field. If the given millisecond
-     * value is closer to the floor, this function behaves like roundFloor. If
-     * the millisecond value is closer to the ceiling or is exactly halfway,
-     * this function behaves like roundCeiling.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
-     * @return rounded milliseconds
-     */
-    public long roundHalfCeiling(long instant) {
-        long floor = roundFloor(instant);
-        long ceiling = roundCeiling(instant);
-
-        long diffFromFloor = instant - floor;
-        long diffToCeiling = ceiling - instant;
-
-        if (diffToCeiling <= diffFromFloor) {
-            // Closer to the ceiling, or halfway - round ceiling
-            return ceiling;
-        } else {
-            return floor;
-        }
-    }
-
-    /**
-     * Round to the nearest whole unit of this field. If the given millisecond
-     * value is closer to the floor, this function behaves like roundFloor. If
-     * the millisecond value is closer to the ceiling, this function behaves
-     * like roundCeiling.
-     * <p>
-     * If the millisecond value is exactly halfway between the floor and
-     * ceiling, the ceiling is chosen over the floor only if it makes this
-     * field's value even.
-     *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
-     * @return rounded milliseconds
-     */
-    public long roundHalfEven(long instant) {
-        long floor = roundFloor(instant);
-        long ceiling = roundCeiling(instant);
-
-        long diffFromFloor = instant - floor;
-        long diffToCeiling = ceiling - instant;
-
-        if (diffFromFloor < diffToCeiling) {
-            // Closer to the floor - round floor
-            return floor;
-        } else if (diffToCeiling < diffFromFloor) {
-            // Closer to the ceiling - round ceiling
-            return ceiling;
-        } else {
-            // Round to the instant that makes this field even. If both values
-            // make this field even (unlikely), favor the ceiling.
-            if ((get(ceiling) & 1) == 0) {
-                return ceiling;
-            }
-            return floor;
-        }
-    }
-
-    /**
-     * Returns the fractional duration milliseconds of this field. In other
-     * words, calling remainder returns the duration that roundFloor would
-     * subtract.
-     * <p>
-     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
-     * hour is 34 minutes and 56.789 seconds.
-     * <p>
-     * The default implementation computes
-     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to
-     * provide a more efficient implementation.
-     *
-     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the
-     * remainder
-     * @return remainder duration, in milliseconds
-     */
-    public long remainder(long instant) {
-        return instant - roundFloor(instant);
-    }
-
-    /**
-     * Get a suitable debug string.
-     * 
-     * @return debug string
-     */
-    public String toString() {
-        return "DateTimeField[" + getName() + ']';
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
deleted file mode 100644
index 27c8c49..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import org.joda.time.DurationField;
-
-/**
- * AbstractDurationField provides the common behaviour for DurationField
- * implementations.
- * <p>
- * This class should generally not be used directly by API users. The
- * DurationField interface should be used when different kinds of DurationField
- * objects are to be referenced.
- * <p>
- * AbstractDurationField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @see DecoratedDurationField
- */
-public abstract class AbstractDurationField implements DurationField, Serializable {
-
-    static final long serialVersionUID = -2554245107589433218L;
-
-    /** A desriptive name for the field */
-    private final String iName;
-
-    protected AbstractDurationField(String name) {
-        super();
-        if (name == null) {
-            throw new IllegalArgumentException("The name must not be null");
-        }
-        iName = name;
-    }
-
-    public final String getName() {
-        return iName;
-    }
-
-    /**
-     * @return true always
-     */
-    public final boolean isSupported() {
-        return true;
-    }
-
-    //------------------------------------------------------------------------
-    /**
-     * Get the value of this field from the milliseconds, which is approximate
-     * if this field is imprecise.
-     *
-     * @param duration  the milliseconds to query, which may be negative
-     * @return the value of the field, in the units of the field, which may be
-     * negative
-     */
-    public int getValue(long duration) {
-        return Utils.safeToInt(getValueAsLong(duration));
-    }
-
-    /**
-     * Get the value of this field from the milliseconds, which is approximate
-     * if this field is imprecise.
-     *
-     * @param duration  the milliseconds to query, which may be negative
-     * @return the value of the field, in the units of the field, which may be
-     * negative
-     */
-    public long getValueAsLong(long duration) {
-        return duration / getUnitMillis();
-    }
-
-    /**
-     * Get the value of this field from the milliseconds relative to an
-     * instant.
-     *
-     * <p>If the milliseconds is positive, then the instant is treated as a
-     * "start instant". If negative, the instant is treated as an "end
-     * instant".
-     *
-     * <p>The default implementation returns
-     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.
-     * 
-     * @param duration  the milliseconds to query, which may be negative
-     * @param instant  the start instant to calculate relative to
-     * @return the value of the field, in the units of the field, which may be
-     * negative
-     */
-    public int getValue(long duration, long instant) {
-        return Utils.safeToInt(getValueAsLong(duration, instant));
-    }
-
-    /**
-     * Get the millisecond duration of this field from its value, which is
-     * approximate if this field is imprecise.
-     * 
-     * @param value  the value of the field, which may be negative
-     * @return the milliseconds that the field represents, which may be
-     * negative
-     */
-    public long getMillis(int value) {
-        return value * getUnitMillis();
-    }
-
-    /**
-     * Get the millisecond duration of this field from its value, which is
-     * approximate if this field is imprecise.
-     * 
-     * @param value  the value of the field, which may be negative
-     * @return the milliseconds that the field represents, which may be
-     * negative
-     */
-    public long getMillis(long value) {
-        return value * getUnitMillis();
-    }
-
-    // Calculation API
-    //------------------------------------------------------------------------
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
-    }
-
-    //------------------------------------------------------------------------
-    public int compareTo(Object durationField) {
-        DurationField otherField = (DurationField) durationField;
-        long otherMillis = otherField.getUnitMillis();
-        long thisMillis = getUnitMillis();
-        // cannot do (thisMillis - otherMillis) as can overflow
-        if (thisMillis == otherMillis) {
-            return 0;
-        }
-        if (thisMillis < otherMillis) {
-            return -1;
-        } else {
-            return 1;
-        }
-    }
-
-    /**
-     * Get a suitable debug string.
-     * 
-     * @return debug string
-     */
-    public String toString() {
-        return "DurationField[" + getName() + ']';
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
new file mode 100644
index 0000000..1936c11
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -0,0 +1,858 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.FieldUtils;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.NonZeroDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.PreciseDateTimeField;
+import org.joda.time.field.PreciseDurationField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ *
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @author Guy Allard
+ * @since 1.0
+ */
+public abstract class AbstractGJChronology extends AssembledChronology {
+
+    static final long serialVersionUID = 8283225332206808863L;
+
+    static final long MILLIS_1970_TO_2000 = 946684800000L;
+
+    // These arrays are NOT public. We trust ourselves not to alter the array.
+    // They use zero-based array indexes so the that valid range of months is
+    // automatically checked.
+
+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {
+        31,28,31,30,31,30,31,31,30,31,30,31
+    };
+
+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {
+        31,29,31,30,31,30,31,31,30,31,30,31
+    };
+
+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;
+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;
+
+    private static final DurationField cMillisField;
+    private static final DurationField cSecondsField;
+    private static final DurationField cMinutesField;
+    private static final DurationField cHoursField;
+    private static final DurationField cHalfdaysField;
+    private static final DurationField cDaysField;
+    private static final DurationField cWeeksField;
+
+    private static final DateTimeField cMillisOfSecondField;
+    private static final DateTimeField cMillisOfDayField;
+    private static final DateTimeField cSecondOfMinuteField;
+    private static final DateTimeField cSecondOfDayField;
+    private static final DateTimeField cMinuteOfHourField;
+    private static final DateTimeField cMinuteOfDayField;
+    private static final DateTimeField cHourOfDayField;
+    private static final DateTimeField cHourOfHalfdayField;
+    private static final DateTimeField cClockhourOfDayField;
+    private static final DateTimeField cClockhourOfHalfdayField;
+    private static final DateTimeField cHalfdayOfDayField;
+
+    static {
+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];
+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];
+
+        long minSum = 0;
+        long maxSum = 0;
+        for (int i=0; i<12; i++) {
+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]
+                * (long)DateTimeConstants.MILLIS_PER_DAY;
+            minSum += millis;
+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;
+
+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]
+                * (long)DateTimeConstants.MILLIS_PER_DAY;
+            maxSum += millis;
+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;
+        }
+
+        cMillisField = MillisDurationField.INSTANCE;
+        cSecondsField = new PreciseDurationField
+            ("seconds", DateTimeConstants.MILLIS_PER_SECOND);
+        cMinutesField = new PreciseDurationField
+            ("minutes", DateTimeConstants.MILLIS_PER_MINUTE);
+        cHoursField = new PreciseDurationField
+            ("hours", DateTimeConstants.MILLIS_PER_HOUR);
+        cHalfdaysField = new PreciseDurationField
+            ("halfdays", DateTimeConstants.MILLIS_PER_DAY / 2);
+        cDaysField = new PreciseDurationField
+            ("days", DateTimeConstants.MILLIS_PER_DAY);
+        cWeeksField = new PreciseDurationField
+            ("weeks", DateTimeConstants.MILLIS_PER_WEEK);
+
+        cMillisOfSecondField = new PreciseDateTimeField
+            ("millisOfSecond", cMillisField, cSecondsField);
+
+        cMillisOfDayField = new PreciseDateTimeField
+            ("millisOfDay", cMillisField, cDaysField);
+             
+        cSecondOfMinuteField = new PreciseDateTimeField
+            ("secondOfMinute", cSecondsField, cMinutesField);
+
+        cSecondOfDayField = new PreciseDateTimeField
+            ("secondOfDay", cSecondsField, cDaysField);
+
+        cMinuteOfHourField = new PreciseDateTimeField
+            ("minuteOfHour", cMinutesField, cHoursField);
+
+        cMinuteOfDayField = new PreciseDateTimeField
+            ("minuteOfDay", cMinutesField, cDaysField);
+
+        cHourOfDayField = new PreciseDateTimeField
+            ("hourOfDay", cHoursField, cDaysField);
+
+        cHourOfHalfdayField = new PreciseDateTimeField
+            ("hourOfHalfday", cHoursField, cHalfdaysField);
+
+        cClockhourOfDayField = new NonZeroDateTimeField
+            (cHourOfDayField, "clockhourOfDay");
+
+        cClockhourOfHalfdayField = new NonZeroDateTimeField
+            (cHourOfHalfdayField, "clockhourOfHalfday");
+
+        cHalfdayOfDayField = new HalfdayField();
+    }
+
+    private transient YearInfo[] iYearInfoCache;
+    private transient int iYearInfoCacheMask;
+
+    private final int iMinDaysInFirstWeek;
+
+    AbstractGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param);
+
+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+
+        iMinDaysInFirstWeek = minDaysInFirstWeek;
+
+        Integer i;
+        try {
+            i = Integer.getInteger(getClass().getName().concat(".yearInfoCacheSize"));
+        } catch (SecurityException e) {
+            i = null;
+        }
+
+        int cacheSize;
+        if (i == null) {
+            cacheSize = 1024; // (1 << 10)
+        } else {
+            cacheSize = i.intValue();
+            // Ensure cache size is even power of 2.
+            cacheSize--;
+            int shift = 0;
+            while (cacheSize > 0) {
+                shift++;
+                cacheSize >>= 1;
+            }
+            cacheSize = 1 << shift;
+        }
+
+        iYearInfoCache = new YearInfo[cacheSize];
+        iYearInfoCacheMask = cacheSize - 1;
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeZone();
+        }
+        return DateTimeZone.UTC;
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+
+        boolean isLeap = isLeapYear(year);
+
+        FieldUtils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
+        FieldUtils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
+                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)
+                                [monthOfYear - 1]);
+
+        long instant = getYearMillis(year);
+
+        if (monthOfYear > 1) {
+            instant += 
+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)
+                [monthOfYear - 2];
+        }
+
+        if (dayOfMonth != 1) {
+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
+        }
+
+        return instant;
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
+        FieldUtils.verifyValueBounds("hourOfDay", hourOfDay, 0, 23);
+        FieldUtils.verifyValueBounds("minuteOfHour", minuteOfHour, 0, 59);
+        FieldUtils.verifyValueBounds("secondOfMinute", secondOfMinute, 0, 59);
+        FieldUtils.verifyValueBounds("millisOfSecond", millisOfSecond, 0, 999);
+
+        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
+            + millisOfSecond;
+    }
+
+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                        int millisOfDay)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+        FieldUtils.verifyValueBounds("millisOfDay", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
+    }
+
+    public final long getDateTimeMillis(long instant,
+                                        int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return getDateOnlyMillis(instant)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                        int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public final int getMinimumDaysInFirstWeek() {
+        return iMinDaysInFirstWeek;
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer(60);
+        String name = getClass().getName();
+        int index = name.lastIndexOf('.');
+        if (index >= 0) {
+            name = name.substring(index + 1);
+        }
+        sb.append(name);
+        sb.append('[');
+        DateTimeZone zone = getDateTimeZone();
+        if (zone != null) {
+            sb.append(zone.getID());
+            sb.append(", ");
+        }
+        sb.append("mdfw=");
+        sb.append(getMinimumDaysInFirstWeek());
+        sb.append(']');
+        return sb.toString();
+    }
+
+    protected void assemble(Fields fields) {
+        // First copy fields that are the same for all Gregorian and Julian
+        // chronologies.
+
+        fields.millis = cMillisField;
+        fields.seconds = cSecondsField;
+        fields.minutes = cMinutesField;
+        fields.hours = cHoursField;
+        //fields.halfdays = cHalfdaysField;  Doesn't exist in public interface
+        fields.days = cDaysField;
+        fields.weeks = cWeeksField;
+
+        fields.millisOfSecond = cMillisOfSecondField;
+        fields.millisOfDay = cMillisOfDayField;
+        fields.secondOfMinute = cSecondOfMinuteField;
+        fields.secondOfDay = cSecondOfDayField;
+        fields.minuteOfHour = cMinuteOfHourField;
+        fields.minuteOfDay = cMinuteOfDayField;
+        fields.hourOfDay = cHourOfDayField;
+        fields.hourOfHalfday = cHourOfHalfdayField;
+        fields.clockhourOfDay = cClockhourOfDayField;
+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;
+        fields.halfdayOfDay = cHalfdayOfDayField;
+
+        // Now create fields that have unique behavior for Gregorian and Julian
+        // chronologies.
+
+        fields.year = new GJYearDateTimeField(this);
+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);
+
+        // Define one-based centuryOfEra and yearOfCentury.
+        DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, "", 99);
+        fields.centuryOfEra = new DividedDateTimeField
+            (field, "centuryOfEra", "centuries", 100);
+        
+        field = new RemainderDateTimeField
+            ((DividedDateTimeField)fields.centuryOfEra, "");
+        fields.yearOfCentury = new OffsetDateTimeField(field, "yearOfCentury", 1);
+
+        fields.era = new GJEraDateTimeField(this);
+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);
+        fields.dayOfMonth = new GJDayOfMonthDateTimeField(this, fields.days);
+        fields.dayOfYear = new GJDayOfYearDateTimeField(this, fields.days);
+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);
+        fields.weekyear = new GJWeekyearDateTimeField(this);
+        fields.weekOfWeekyear = new GJWeekOfWeekyearDateTimeField(this, fields.weeks);
+
+        // The remaining (imprecise) durations are available from the newly
+        // created datetime fields.
+
+        fields.years = fields.year.getDurationField();
+        fields.centuries = fields.centuryOfEra.getDurationField();
+        fields.months = fields.monthOfYear.getDurationField();
+        fields.weekyears = fields.weekyear.getDurationField();
+    }
+
+    /**
+     * Get the number of days in the year.
+     * @param year The year to use.
+     * @return 366 if a leap year, otherwise 365.
+     */
+    final int getDaysInYear(int year) {
+        return isLeapYear(year) ? 366 : 365;
+    }
+
+    final int getDaysInYearMonth(int year, int month) {
+        if (isLeapYear(year)) {
+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];
+        } else {
+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];
+        }
+    }
+
+    /**
+     * Returns the total number of milliseconds elapsed in the year, by the end
+     * of the month.
+     */
+    final long getTotalMillisByYearMonth(int year, int month) {
+        if (isLeapYear(year)) {
+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];
+        } else {
+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];
+        }
+    }
+
+    /**
+     * Get the number of weeks in the year.
+     * @param year  the year to use.
+     * @return number of weeks in the year.
+     */
+    final int getWeeksInYear(int year) {
+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);
+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);
+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);
+    }
+
+    /**
+     * Get the millis for the first week of a year.
+     * @param year  the year to use.
+     * @return millis
+     */
+    final long getFirstWeekOfYearMillis(int year) {
+        long jan1millis = getYearMillis(year);
+        int jan1dayOfWeek = getDayOfWeek(jan1millis);
+        
+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {
+            // First week is end of previous year because it doesn't have enough days.
+            return jan1millis + (8 - jan1dayOfWeek)
+                * (long)DateTimeConstants.MILLIS_PER_DAY;
+        } else {
+            // First week is start of this year because it has enough days.
+            return jan1millis - (jan1dayOfWeek - 1)
+                * (long)DateTimeConstants.MILLIS_PER_DAY;
+        }
+    }
+
+    /**
+     * Get the milliseconds for the start of a year.
+     *
+     * @param year The year to use.
+     * @return millis from 1970-01-01T00:00:00Z
+     */
+    final long getYearMillis(int year) {
+        return getYearInfo(year).iFirstDayMillis;
+        //return calculateFirstDayOfYearMillis(year);
+    }
+
+    /**
+     * Get the milliseconds for the start of a month.
+     *
+     * @param year The year to use.
+     * @param month The month to use
+     * @return millis from 1970-01-01T00:00:00Z
+     */
+    final long getYearMonthMillis(int year, int month) {
+        long millis = getYearMillis(year);
+        // month
+        if (month > 1) {
+            millis += getTotalMillisByYearMonth(year, month - 1);
+        }
+        return millis;
+    }
+
+    /**
+     * Get the milliseconds for a particular date.
+     *
+     * @param year The year to use.
+     * @param month The month to use
+     * @param dayOfMonth The day of the month to use
+     * @return millis from 1970-01-01T00:00:00Z
+     */
+    final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {
+        long millis = getYearMillis(year);
+        // month
+        if (month > 1) {
+            millis += getTotalMillisByYearMonth(year, month - 1);
+        }
+        // day
+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
+    }
+    
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getYear(long instant) {
+        // Get an initial estimate of the year, and the millis value that
+        // represents the start of that year. Then verify estimate and fix if
+        // necessary.
+
+        long unitMillis = getAverageMillisPerYear();
+        long i2 = instant + getApproxMillisAtEpoch();
+        if (i2 < 0) {
+            i2 = i2 - unitMillis + 1;
+        }
+        int year = (int) (i2 / unitMillis);
+
+        long yearStart = getYearMillis(year);
+        long diff = instant - yearStart;
+
+        if (diff < 0) {
+            if (diff < -DateTimeConstants.MILLIS_PER_DAY * 2L) {
+                // Too much error, assume operation overflowed.
+                return getYearOverflow(instant);
+            }
+            year--;
+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {
+            if (diff >= DateTimeConstants.MILLIS_PER_DAY * 367L) {
+                // Too much error, assume operation overflowed.
+                return getYearOverflow(instant);
+            }
+            // One year may need to be added to fix estimate.
+            long oneYear;
+            if (isLeapYear(year)) {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;
+            } else {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;
+            }
+
+            yearStart += oneYear;
+
+            if ((yearStart ^ instant) < 0) {
+                // Sign mismatch, operation may have overflowed.
+                if ((yearStart <  0 && (yearStart - oneYear) >= 0) ||
+                    (yearStart >= 0 && (yearStart - oneYear) <  0)   ) {
+                    // It overflowed.
+                    return getYearOverflow(instant);
+                }
+            }
+
+            if (yearStart <= instant) {
+                // Didn't go too far, so actually add one year.
+                year++;
+            }
+        }
+
+        return year;
+    }
+
+    private final int getYearOverflow(long instant) {
+        if (instant > 0) {
+            int year = getMaxYear();
+            long yearStartMillis = getYearMillis(year);
+            if (isLeapYear(year)) {
+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
+            } else {
+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
+            }
+            long yearEndMillis = yearStartMillis - 1;
+
+            if (instant <= yearEndMillis) {
+                return year;
+            }
+
+            throw new IllegalArgumentException
+                ("Instant too large: " + instant + " > " + yearEndMillis);
+        } else {
+            int year = getMinYear();
+            long yearStartMillis = getYearMillis(year);
+            if (instant >= yearStartMillis) {
+                return year;
+            }
+
+            throw new IllegalArgumentException
+                ("Instant too small: " + instant + " < " + yearStartMillis);
+        }
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final long setYear(long instant, int year) {
+        int thisYear = getYear(instant);
+        int dayOfYear = getDayOfYear(instant, thisYear);
+        int millisOfDay = getMillisOfDay(instant);
+
+        if (dayOfYear > (31 + 28)) { // after Feb 28
+            if (isLeapYear(thisYear)) {
+                // Current date is Feb 29 or later.
+                if (!isLeapYear(year)) {
+                    // Moving to a non-leap year, Feb 29 does not exist.
+                    dayOfYear--;
+                }
+            } else {
+                // Current date is Mar 01 or later.
+                if (isLeapYear(year)) {
+                    // Moving to a leap year, account for Feb 29.
+                    dayOfYear++;
+                }
+            }
+        }
+
+        instant = getYearMonthDayMillis(year, 1, dayOfYear);
+        instant += millisOfDay;
+
+        return instant;
+    }
+
+    /**
+     * @param millis from 1970-01-01T00:00:00Z
+     */
+    final int getMonthOfYear(long millis) {
+        return getMonthOfYear(millis, getYear(millis));
+    }
+
+    /**
+     * @param millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getMonthOfYear(long millis, int year) {
+        // Perform a binary search to get the month. To make it go even faster,
+        // compare using ints instead of longs. The number of milliseconds per
+        // year exceeds the limit of a 32-bit int's capacity, so divide by
+        // 1024. No precision is lost (except time of day) since the number of
+        // milliseconds per day contains 1024 as a factor. After the division,
+        // the instant isn't measured in milliseconds, but in units of
+        // (128/125)seconds.
+
+        int i = (int)((millis - getYearMillis(year)) >> 10);
+
+        // There are 86400000 milliseconds per day, but divided by 1024 is
+        // 84375. There are 84375 (128/125)seconds per day.
+
+        return
+            (isLeapYear(year))
+            ? ((i < 182 * 84375)
+               ? ((i < 91 * 84375)
+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)
+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))
+               : ((i < 274 * 84375)
+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)
+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))
+            : ((i < 181 * 84375)
+               ? ((i < 90 * 84375)
+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)
+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))
+               : ((i < 273 * 84375)
+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)
+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));
+    }
+
+    /**
+     * @param millis from 1970-01-01T00:00:00Z
+     */
+    final int getDayOfMonth(long millis) {
+        int year = getYear(millis);
+        int month = getMonthOfYear(millis, year);
+        return getDayOfMonth(millis, year, month);
+    }
+
+    /**
+     * @param millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getDayOfMonth(long millis, int year) {
+        int month = getMonthOfYear(millis, year);
+        return getDayOfMonth(millis, year, month);
+    }
+
+    /**
+     * @param millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     * @param month precalculated month of millis
+     */
+    final int getDayOfMonth(long millis, int year, int month) {
+        long dateMillis = getYearMillis(year);
+        if (month > 1) {
+            dateMillis += getTotalMillisByYearMonth(year, month - 1);
+        }
+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getDayOfYear(long instant) {
+        return getDayOfYear(instant, getYear(instant));
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getDayOfYear(long instant, int year) {
+        long yearStart = getYearMillis(year);
+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getWeekyear(long instant) {
+        int year = getYear(instant);
+        int week = getWeekOfWeekyear(instant, year);
+        if (week == 1) {
+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);
+        } else if (week > 51) {
+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));
+        } else {
+            return year;
+        }
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getWeekOfWeekyear(long instant) {
+        return getWeekOfWeekyear(instant, getYear(instant));
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getWeekOfWeekyear(long instant, int year) {
+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);
+        if (instant < firstWeekMillis1) {
+            return getWeeksInYear(year - 1);
+        }
+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);
+        if (instant >= firstWeekMillis2) {
+            return 1;
+        }
+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getDayOfWeek(long instant) {
+        // 1970-01-01 is day of week 4, Thursday.
+
+        long daysSince19700101;
+        if (instant >= 0) {
+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;
+        } else {
+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))
+                / DateTimeConstants.MILLIS_PER_DAY;
+            if (daysSince19700101 < -3) {
+                return 7 + (int) ((daysSince19700101 + 4) % 7);
+            }
+        }
+
+        return 1 + (int) ((daysSince19700101 + 3) % 7);
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getMillisOfDay(long instant) {
+        if (instant >= 0) {
+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);
+        } else {
+            return (DateTimeConstants.MILLIS_PER_DAY - 1)
+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);
+        }
+    }
+
+    abstract boolean isLeapYear(int year);
+
+    abstract long calculateFirstDayOfYearMillis(int year);
+
+    abstract int getMinYear();
+
+    abstract int getMaxYear();
+
+    abstract long getAverageMillisPerYear();
+
+    abstract long getAverageMillisPerMonth();
+
+    /**
+     * Returns a constant representing the approximate number of milliseconds
+     * elapsed from year 0 of this chronology. This constant <em>must</em> be
+     * defined as:
+     * <pre>
+     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch
+     * <pre>
+     * where epoch is 1970-01-01 (Gregorian).
+     */
+    abstract long getApproxMillisAtEpoch();
+
+    // Although accessed by multiple threads, this method doesn't need to be synchronized.
+    private YearInfo getYearInfo(int year) {
+        YearInfo[] cache = iYearInfoCache;
+        int index = year & iYearInfoCacheMask;
+        YearInfo info = cache[index];
+        if (info == null || info.iYear != year) {
+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));
+            cache[index] = info;
+        }
+        return info;
+    }
+
+    private static class HalfdayField extends PreciseDateTimeField {
+        static final long serialVersionUID = 581601443656929254L;
+
+        HalfdayField() {
+            super("halfdayOfDay", cHalfdaysField, cDaysField);
+        }
+
+        public String getAsText(long millis, Locale locale) {
+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));
+        }
+
+        public long set(long millis, String text, Locale locale) {
+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));
+        }
+
+        public int getMaximumTextLength(Locale locale) {
+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();
+        }
+    }
+
+    private static class YearInfo {
+        public final int iYear;
+        public final long iFirstDayMillis;
+
+        YearInfo(int year, long firstDayMillis) {
+            iYear = year;
+            iFirstDayMillis = firstDayMillis;
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
new file mode 100644
index 0000000..27b8bb5
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -0,0 +1,617 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+
+/**
+ * Allows chronologies to be assembled from a container of fields.
+ * <p>
+ * AssembledChronology is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class AssembledChronology extends AbstractChronology {
+
+    static final long serialVersionUID = -6728465968995518215L;
+
+    private final Chronology iBase;
+    private final Object iParam;
+
+    private transient DurationField iMillis;
+    private transient DurationField iSeconds;
+    private transient DurationField iMinutes;
+    private transient DurationField iHours;
+
+    private transient DurationField iDays;
+    private transient DurationField iWeeks;
+    private transient DurationField iWeekyears;
+    private transient DurationField iMonths;
+    private transient DurationField iYears;
+    private transient DurationField iCenturies;
+    private transient DurationField iEras;
+
+    private transient DateTimeField iMillisOfSecond;
+    private transient DateTimeField iMillisOfDay;
+    private transient DateTimeField iSecondOfMinute;
+    private transient DateTimeField iSecondOfDay;
+    private transient DateTimeField iMinuteOfHour;
+    private transient DateTimeField iMinuteOfDay;
+    private transient DateTimeField iHourOfDay;
+    private transient DateTimeField iClockhourOfDay;
+    private transient DateTimeField iHourOfHalfday;
+    private transient DateTimeField iClockhourOfHalfday;
+    private transient DateTimeField iHalfdayOfDay;
+
+    private transient DateTimeField iDayOfWeek;
+    private transient DateTimeField iDayOfMonth;
+    private transient DateTimeField iDayOfYear;
+    private transient DateTimeField iWeekOfWeekyear;
+    private transient DateTimeField iWeekyear;
+    private transient DateTimeField iMonthOfYear;
+    private transient DateTimeField iYear;
+    private transient DateTimeField iYearOfEra;
+    private transient DateTimeField iYearOfCentury;
+    private transient DateTimeField iCenturyOfEra;
+    private transient DateTimeField iEra;
+
+    // Bit set determines which base fields are used
+    // bit 1 set: hourOfDay, minuteOfHour, secondOfMinute, and millisOfSecond fields
+    // bit 2 set: millisOfDayField
+    // bit 3 set: year, monthOfYear, and dayOfMonth fields
+    private transient int iBaseFlags;
+
+    /**
+     * Constructor calls the assemble method, enabling subclasses to define its
+     * supported fields. If a base chronology is supplied, the field set
+     * initially contains references to each base chronlogy field.
+     * <p>
+     * Other methods in this class will delegate to the base chronology, if it
+     * can be determined that the base chronology will produce the same results
+     * as AbstractChronology.
+     *
+     * @param base optional base chronology to copy initial fields from
+     * @param param optional param object avalable for assemble method
+     */
+    protected AssembledChronology(Chronology base, Object param) {
+        iBase = base;
+        iParam = param;
+        setFields();
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getDateTimeZone();
+        }
+        return null;
+    }
+
+    public long getDateOnlyMillis(long instant) {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getDateOnlyMillis(instant);
+        }
+        return super.getDateOnlyMillis(instant);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 4) == 4) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+        return super.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(long instant) {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getTimeOnlyMillis(instant);
+        }
+        return super.getTimeOnlyMillis(instant);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 6) == 6) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getDateTimeMillis
+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public final DurationField millis() {
+        return iMillis;
+    }
+
+    public final DateTimeField millisOfSecond() {
+        return iMillisOfSecond;
+    }
+
+    public final DateTimeField millisOfDay() {
+        return iMillisOfDay;
+    }
+
+    public final DurationField seconds() {
+        return iSeconds;
+    }
+
+    public final DateTimeField secondOfMinute() {
+        return iSecondOfMinute;
+    }
+
+    public final DateTimeField secondOfDay() {
+        return iSecondOfDay;
+    }
+
+    public final DurationField minutes() {
+        return iMinutes;
+    }
+
+    public final DateTimeField minuteOfHour() {
+        return iMinuteOfHour;
+    }
+
+    public final DateTimeField minuteOfDay() {
+        return iMinuteOfDay;
+    }
+
+    public final DurationField hours() {
+        return iHours;
+    }
+
+    public final DateTimeField hourOfDay() {
+        return iHourOfDay;
+    }
+
+    public final DateTimeField clockhourOfDay() {
+        return iClockhourOfDay;
+    }
+
+    public final DateTimeField hourOfHalfday() {
+        return iHourOfHalfday;
+    }
+
+    public final DateTimeField clockhourOfHalfday() {
+        return iClockhourOfHalfday;
+    }
+
+    public final DateTimeField halfdayOfDay() {
+        return iHalfdayOfDay;
+    }
+
+    public final DurationField days() {
+        return iDays;
+    }
+
+    public final DateTimeField dayOfWeek() {
+        return iDayOfWeek;
+    }
+
+    public final DateTimeField dayOfMonth() {
+        return iDayOfMonth;
+    }
+
+    public final DateTimeField dayOfYear() {
+        return iDayOfYear;
+    }
+
+    public final DurationField weeks() {
+        return iWeeks;
+    }
+
+    public final DateTimeField weekOfWeekyear() {
+        return iWeekOfWeekyear;
+    }
+
+    public final DurationField weekyears() {
+        return iWeekyears;
+    }
+
+    public final DateTimeField weekyear() {
+        return iWeekyear;
+    }
+
+    public final DurationField months() {
+        return iMonths;
+    }
+
+    public final DateTimeField monthOfYear() {
+        return iMonthOfYear;
+    }
+
+    public final DurationField years() {
+        return iYears;
+    }
+
+    public final DateTimeField year() {
+        return iYear;
+    }
+
+    public final DateTimeField yearOfEra() {
+        return iYearOfEra;
+    }
+
+    public final DateTimeField yearOfCentury() {
+        return iYearOfCentury;
+    }
+
+    public final DurationField centuries() {
+        return iCenturies;
+    }
+
+    public final DateTimeField centuryOfEra() {
+        return iCenturyOfEra;
+    }
+
+    public final DurationField eras() {
+        return iEras;
+    }
+
+    public final DateTimeField era() {
+        return iEra;
+    }
+
+    /**
+     * Invoked by the constructor and after deserialization to allow subclasses
+     * to define all of its supported fields. All unset fields default to
+     * unsupported instances.
+     *
+     * @param fields container of fields
+     */
+    protected abstract void assemble(Fields fields);
+
+    /**
+     * Returns the same base chronology as passed into the constructor.
+     */
+    protected final Chronology getBase() {
+        return iBase;
+    }
+
+    /**
+     * Returns the same param object as passed into the constructor.
+     */
+    protected final Object getParam() {
+        return iParam;
+    }
+
+    private void setFields() {
+        Fields fields = new Fields();
+        if (iBase != null) {
+            fields.copyFieldsFrom(iBase);
+        }
+        assemble(fields);
+
+        {
+            DurationField f;
+            iMillis    = (f = fields.millis)    != null ? f : super.millis();
+            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();
+            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();
+            iHours     = (f = fields.hours)     != null ? f : super.hours();
+            iDays      = (f = fields.days)      != null ? f : super.days();
+            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();
+            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();
+            iMonths    = (f = fields.months)    != null ? f : super.months();
+            iYears     = (f = fields.years)     != null ? f : super.years();
+            iCenturies = (f = fields.centuries) != null ? f : super.centuries();
+            iEras      = (f = fields.eras)      != null ? f : super.eras();
+        }
+
+        {
+            DateTimeField f;
+            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();
+            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();
+            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();
+            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();
+            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();
+            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();
+            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();
+            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();
+            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();
+            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();
+            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();
+            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();
+            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();
+            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();
+            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();
+            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();
+            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();
+            iYear               = (f = fields.year)               != null ? f : super.year();
+            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();
+            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();
+            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();
+            iEra                = (f = fields.era)                != null ? f : super.era();
+        }
+
+        int flags;
+        if (iBase == null) {
+            flags = 0;
+        } else {
+            flags = 
+                ((iHourOfDay      == iBase.hourOfDay()      &&
+                  iMinuteOfHour   == iBase.minuteOfHour()   &&
+                  iSecondOfMinute == iBase.secondOfMinute() &&
+                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |
+
+                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |
+
+                ((iYear        == iBase.year()        &&
+                  iMonthOfYear == iBase.monthOfYear() &&
+                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);
+        }
+
+        iBaseFlags = flags;
+    }
+
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        setFields();
+    }
+
+    public static final class Fields {
+        public DurationField millis;
+        public DurationField seconds;
+        public DurationField minutes;
+        public DurationField hours;
+    
+        public DurationField days;
+        public DurationField weeks;
+        public DurationField weekyears;
+        public DurationField months;
+        public DurationField years;
+        public DurationField centuries;
+        public DurationField eras;
+    
+        public DateTimeField millisOfSecond;
+        public DateTimeField millisOfDay;
+        public DateTimeField secondOfMinute;
+        public DateTimeField secondOfDay;
+        public DateTimeField minuteOfHour;
+        public DateTimeField minuteOfDay;
+        public DateTimeField hourOfDay;
+        public DateTimeField clockhourOfDay;
+        public DateTimeField hourOfHalfday;
+        public DateTimeField clockhourOfHalfday;
+        public DateTimeField halfdayOfDay;
+    
+        public DateTimeField dayOfWeek;
+        public DateTimeField dayOfMonth;
+        public DateTimeField dayOfYear;
+        public DateTimeField weekOfWeekyear;
+        public DateTimeField weekyear;
+        public DateTimeField monthOfYear;
+        public DateTimeField year;
+        public DateTimeField yearOfEra;
+        public DateTimeField yearOfCentury;
+        public DateTimeField centuryOfEra;
+        public DateTimeField era;
+
+        Fields() {
+        }
+
+        /**
+         * Copy the supported fields from a chronology into this container.
+         */
+        public void copyFieldsFrom(Chronology chrono) {
+            {
+                DurationField f;
+                if (isSupported(f = chrono.millis())) {
+                    millis = f;
+                }
+                if (isSupported(f = chrono.seconds())) {
+                    seconds = f;
+                }
+                if (isSupported(f = chrono.minutes())) {
+                    minutes = f;
+                }
+                if (isSupported(f = chrono.hours())) {
+                    hours = f;
+                }
+                if (isSupported(f = chrono.days())) {
+                    days = f;
+                }
+                if (isSupported(f = chrono.weeks())) {
+                    weeks = f;
+                }
+                if (isSupported(f = chrono.weekyears())) {
+                    weekyears = f;
+                }
+                if (isSupported(f = chrono.months())) {
+                    months = f;
+                }
+                if (isSupported(f = chrono.years())) {
+                    years = f;
+                }
+                if (isSupported(f = chrono.centuries())) {
+                    centuries = f;
+                }
+                if (isSupported(f = chrono.eras())) {
+                    eras = f;
+                }
+            }
+
+            {
+                DateTimeField f;
+                if (isSupported(f = chrono.millisOfSecond())) {
+                    millisOfSecond = f;
+                }
+                if (isSupported(f = chrono.millisOfDay())) {
+                    millisOfDay = f;
+                }
+                if (isSupported(f = chrono.secondOfMinute())) {
+                    secondOfMinute = f;
+                }
+                if (isSupported(f = chrono.secondOfDay())) {
+                    secondOfDay = f;
+                }
+                if (isSupported(f = chrono.minuteOfHour())) {
+                    minuteOfHour = f;
+                }
+                if (isSupported(f = chrono.minuteOfDay())) {
+                    minuteOfDay = f;
+                }
+                if (isSupported(f = chrono.hourOfDay())) {
+                    hourOfDay = f;
+                }
+                if (isSupported(f = chrono.clockhourOfDay())) {
+                    clockhourOfDay = f;
+                }
+                if (isSupported(f = chrono.hourOfHalfday())) {
+                    hourOfHalfday = f;
+                }
+                if (isSupported(f = chrono.clockhourOfHalfday())) {
+                    clockhourOfHalfday = f;
+                }
+                if (isSupported(f = chrono.halfdayOfDay())) {
+                    halfdayOfDay = f;
+                }
+                if (isSupported(f = chrono.dayOfWeek())) {
+                    dayOfWeek = f;
+                }
+                if (isSupported(f = chrono.dayOfMonth())) {
+                    dayOfMonth = f;
+                }
+                if (isSupported(f = chrono.dayOfYear())) {
+                    dayOfYear = f;
+                }
+                if (isSupported(f = chrono.weekOfWeekyear())) {
+                    weekOfWeekyear = f;
+                }
+                if (isSupported(f = chrono.weekyear())) {
+                    weekyear = f;
+                }
+                if (isSupported(f = chrono.monthOfYear())) {
+                    monthOfYear = f;
+                }
+                if (isSupported(f = chrono.year())) {
+                    year = f;
+                }
+                if (isSupported(f = chrono.yearOfEra())) {
+                    yearOfEra = f;
+                }
+                if (isSupported(f = chrono.yearOfCentury())) {
+                    yearOfCentury = f;
+                }
+                if (isSupported(f = chrono.centuryOfEra())) {
+                    centuryOfEra = f;
+                }
+                if (isSupported(f = chrono.era())) {
+                    era = f;
+                }
+            }
+        }
+
+        private static boolean isSupported(DurationField field) {
+            return field == null ? false : field.isSupported();
+        }
+
+        private static boolean isSupported(DateTimeField field) {
+            return field == null ? false : field.isSupported();
+        }
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
new file mode 100644
index 0000000..eff0211
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
@@ -0,0 +1,227 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ * <code>BuddhistChronology</code> provides access to the individual date
+ * time fields for the Buddhist chronological calendar system.
+ * <p>
+ * The Buddhist calendar differs from the GregorianJulian calendar only 
+ * in the year. This class is compatable with the BuddhistCalendar class 
+ * supplied by Sun.
+ * <p>
+ * BuddhistChronology is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class BuddhistChronology extends AssembledChronology {
+    
+    static final long serialVersionUID = -3474595157769370126L;
+
+    /**
+     * Constant value for 'Buddhist Era', equivalent to the value returned
+     * for AD/CE.
+     */
+    public static final int BE = DateTimeConstants.CE;
+
+    /** Number of years difference in calendars. */
+    private static final int BUDDHIST_OFFSET = 543;
+
+    /** Cache of zone to chronology */
+    private static final Map cCache = new HashMap();
+
+    /** UTC instance of the chronology */
+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     * <p>
+     * The time zone of the returned instance is UTC.
+     */
+    public static BuddhistChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     */
+    public static BuddhistChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault());
+    }
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     *
+     * @param zone  the time zone to use, null is default
+     */
+    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);
+        if (chrono == null) {
+            // First create without a lower limit.
+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
+            // Impose lower limit and make another BuddhistChronology.
+            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");
+            cCache.put(zone, chrono);
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+    
+    /**
+     * Restricted constructor.
+     *
+     * @param param if non-null, then don't change the field set
+     */
+    private BuddhistChronology(Chronology base, Object param) {
+        super(base, param);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        String str = "BuddhistChronology";
+        DateTimeZone zone = getDateTimeZone();
+        if (zone != null) {
+            str = str + '[' + zone.getID() + ']';
+        }
+        return str;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getParam() == null) {
+            DateTimeField field = fields.year;
+            fields.year = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+            fields.yearOfEra = fields.year;
+            
+            field = fields.weekyear;
+            fields.weekyear = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+            
+            field = new OffsetDateTimeField(fields.yearOfEra, "", 99);
+            fields.centuryOfEra = new DividedDateTimeField(field, "centuryOfEra", "centuries", 100);
+            
+            field = new RemainderDateTimeField
+                ((DividedDateTimeField)fields.centuryOfEra, "");
+            fields.yearOfCentury = new OffsetDateTimeField(field, "yearOfCentury", 1);
+            
+            fields.era = BuddhistEraDateTimeField.INSTANCE;
+        }
+    }
+   
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
new file mode 100644
index 0000000..95d653b
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
@@ -0,0 +1,196 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the buddhist era component of time.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class BuddhistEraDateTimeField extends AbstractDateTimeField {
+    
+    static final long serialVersionUID = -9175876774456816364L;
+
+    /**
+     * Singleton instance
+     */
+    static final DateTimeField INSTANCE = new BuddhistEraDateTimeField();
+
+    /**
+     * Restricted constructor
+     */
+    private BuddhistEraDateTimeField() {
+        super("era");
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to query.
+     * @return the era extracted from the input.
+     */
+    public int get(long instant) {
+        return BuddhistChronology.BE;
+    }
+
+    /**
+     * Set the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to update.
+     * @param era  the era (BuddhistChronology.BE) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
+     */
+    public long set(long instant, int era) {
+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
+
+        return instant;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#set(long, String, Locale)
+     */
+    public long set(long instant, String text, Locale locale) {
+        if ("BE".equals(text) == false) {
+            throw new IllegalArgumentException("Invalid era text: " + text);
+        }
+        return instant;
+    }
+
+    public long roundFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundCeiling(long instant) {
+        return Long.MAX_VALUE;
+    }
+
+    public long roundHalfFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfEven(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public int getMinimumValue() {
+        return BuddhistChronology.BE;
+    }
+
+    public int getMaximumValue() {
+        return BuddhistChronology.BE;
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return "BE";
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return 2;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsText(long instant, Locale locale) {
+        return "BE";
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return 2;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
new file mode 100644
index 0000000..54cbd56
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -0,0 +1,286 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationField;
+
+/**
+ * 
+ *
+ * @author Brian S O'Neill
+ */
+public final class CopticChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -5972804258688333942L;
+
+    /**
+     * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent
+     * to the value returned for AD/CE.
+     */
+    public static final int AM = DateTimeConstants.CE;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    private static final DurationField cMonthsField;
+
+    /** Singleton instance of a UTC CopticChronology */
+    private static final CopticChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        cMonthsField =  new PreciseDurationField
+            ("months", 30L * DateTimeConstants.MILLIS_PER_DAY);
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static CopticChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static CopticChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static CopticChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        CopticChronology chrono;
+        synchronized (cCache) {
+            CopticChronology[] chronos = (CopticChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new CopticChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    // First create without a lower limit.
+                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);
+                    // Impose lower limit and make another CopticChronology.
+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+                    chrono = new CopticChronology
+                        (LimitChronology.getInstance(chrono, lowerLimit, null),
+                         null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new CopticChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    boolean isLeapYear(int year) {
+        return (year & 3) == 3;
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.
+        // Calculate relative to the nearest leap year and account for the
+        // difference later.
+
+        int relativeYear = year - 1687;
+        int leapYears;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers.
+            leapYears = (relativeYear + 3) >> 2;
+        } else {
+            leapYears = relativeYear >> 2;
+            // For post 1687 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+
+        // Adjust to account for difference between 1687-01-01 and 1686-04-23.
+
+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return 1;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        // TODO
+        return 292272992;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+            // Coptic, like Julian, has no year zero.
+            fields.year = new JulianChronology.NoYearZeroField(this, fields.year);
+            fields.weekyear = new JulianChronology.NoWeekyearZeroField(this, fields.weekyear);
+            
+            fields.era = CopticEraDateTimeField.INSTANCE;
+            fields.months = cMonthsField;
+            fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);
+            fields.dayOfMonth = new CopticDayOfMonthDateTimeField(this, fields.days);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
new file mode 100644
index 0000000..ccc443c
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
@@ -0,0 +1,108 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * Provides time calculations for the day of the month component of time.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class CopticDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -5441610762799659434L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    CopticDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {
+        super("dayOfMonth", days);
+        iChronology = chronology;
+    }
+
+    public int get(long instant) {
+        return (iChronology.getDayOfYear(instant) - 1) % 30 + 1;
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.months();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 30;
+    }
+
+    public int getMaximumValue(long instant) {
+		if (((iChronology.getDayOfYear(instant) - 1) / 30) < 12) {
+			return 30;
+		}
+		return iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.dayOfMonth();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
new file mode 100644
index 0000000..b1adfd9
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
@@ -0,0 +1,195 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the coptic era component of time.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class CopticEraDateTimeField extends AbstractDateTimeField {
+    
+    static final long serialVersionUID = 4090856468123006167L;
+
+    /**
+     * Singleton instance
+     */
+    static final DateTimeField INSTANCE = new CopticEraDateTimeField();
+
+    /**
+     * Restricted constructor
+     */
+    private CopticEraDateTimeField() {
+        super("era");
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to query.
+     * @return the era extracted from the input.
+     */
+    public int get(long instant) {
+        return CopticChronology.AM;
+    }
+
+    /**
+     * Set the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to update.
+     * @param era  the era (CopticChronology.AM) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
+     */
+    public long set(long instant, int era) {
+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
+
+        return instant;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#set(long, String, Locale)
+     */
+    public long set(long instant, String text, Locale locale) {
+        if ("AM".equals(text) == false) {
+            throw new IllegalArgumentException("Invalid era text: " + text);
+        }
+        return instant;
+    }
+
+    public long roundFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundCeiling(long instant) {
+        return Long.MAX_VALUE;
+    }
+
+    public long roundHalfFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfEven(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public int getMinimumValue() {
+        return CopticChronology.AM;
+    }
+
+    public int getMaximumValue() {
+        return CopticChronology.AM;
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return "AM";
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return 2;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsText(long instant, Locale locale) {
+        return "AM";
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return 2;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
new file mode 100644
index 0000000..b7a7f06
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
@@ -0,0 +1,113 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * 
+ *
+ * @author Brian S O'Neill
+ */
+final class CopticMonthOfYearDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = 7741038885247700323L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    CopticMonthOfYearDateTimeField(AbstractGJChronology chronology, DurationField months) {
+        super("monthOfYear", months);
+        iChronology = chronology;
+    }
+
+    public int get(long instant) {
+        return (iChronology.getDayOfYear(instant) - 1) / 30 + 1;
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
+    }
+
+    public boolean isLeap(long instant) {
+        return get(instant) > 12 && iChronology.isLeapYear(iChronology.getYear(instant));
+    }
+
+    public int getLeapAmount(long instant) {
+        return isLeap(instant) ? 1 : 0;
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 13;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.monthOfYear();
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
deleted file mode 100644
index 5c9b892..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-
-/**
- * <code>DecoratedChronology</code> extends {@link Chronology}, implementing
- * only the minimum required set of methods. These implemented methods delegate
- * to a wrapped field. The withUTC, withDateTimeZone, and toString methods are
- * exceptions, and are left abstract.
- * <p>
- * This design allows new Chronology types to be defined that piggyback on top
- * of another, inheriting all the safe method implementations from
- * Chronology. Should any method require pure delegation to the wrapped field,
- * simply override and use the provided getWrappedChronology method.
- * <p>
- * DecoratedChronology is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DelegatedChronology
- */
-public abstract class DecoratedChronology extends Chronology {
-
-    static final long serialVersionUID = 7094038875466049631L;
-
-    /** The Chronology being wrapped */
-    private final Chronology iChronology;
-    
-    /**
-     * Create a DecoratedChronology for any chronology.
-     *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
-     */
-    protected DecoratedChronology(Chronology chrono) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        iChronology = chrono;
-    }
-    
-    /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Get the Chronology in the UTC time zone.
-     * 
-     * @return Chronology in UTC
-     */
-    public abstract Chronology withUTC();
-
-    /**
-     * Get the Chronology in the any time zone.
-     * 
-     * @return Chronology in ant time zone
-     */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
-
-    /**
-     * Gets the time zone that this chronology is using.
-     * 
-     * @return the DateTimeZone
-     */
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
deleted file mode 100644
index 2e99333..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},
- * implementing only the minimum required set of methods. These implemented
- * methods delegate to a wrapped field.
- * <p>
- * This design allows new DateTimeField types to be defined that piggyback on
- * top of another, inheriting all the safe method implementations from
- * AbstractDateTimeField. Should any method require pure delegation to the
- * wrapped field, simply override and use the provided getWrappedField method.
- * <p>
- * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DelegatedDateTimeField
- */
-public class DecoratedDateTimeField extends AbstractDateTimeField {
-
-    static final long serialVersionUID = 203115783733757597L;
-
-    /** The DateTimeField being wrapped */
-    private final DateTimeField iField;
-
-    /**
-     * @param name allow name to be overridden
-     */
-    public DecoratedDateTimeField(DateTimeField field, String name) {
-        super(name);
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        if (!field.isSupported()) {
-            throw new IllegalArgumentException("The field must be supported");
-        }
-        iField = field;
-    }
-
-    /**
-     * Gets the wrapped date time field.
-     * 
-     * @return the wrapped DateTimeField
-     */
-    public final DateTimeField getWrappedField() {
-        return iField;
-    }
-
-    public boolean isLenient() {
-        return iField.isLenient();
-    }
-
-    public int get(long instant) {
-        return iField.get(instant);
-    }
-
-    public long set(long instant, int value) {
-        return iField.set(instant, value);
-    }
-
-    public DurationField getDurationField() {
-        return iField.getDurationField();
-    }
-
-    public DurationField getRangeDurationField() {
-        return iField.getRangeDurationField();
-    }
-
-    public int getMinimumValue() {
-        return iField.getMinimumValue();
-    }
-
-    public int getMaximumValue() {
-        return iField.getMaximumValue();
-    }
-
-    public long roundFloor(long instant) {
-        return iField.roundFloor(instant);
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
deleted file mode 100644
index 85cd687..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DurationField;
-
-/**
- * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},
- * implementing only the minimum required set of methods. These implemented
- * methods delegate to a wrapped field.
- * <p>
- * This design allows new DurationField types to be defined that piggyback on
- * top of another, inheriting all the safe method implementations from
- * AbstractDurationField. Should any method require pure delegation to the
- * wrapped field, simply override and use the provided getWrappedField method.
- * <p>
- * DecoratedDurationField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @see DelegatedDurationField
- */
-public class DecoratedDurationField extends AbstractDurationField {
-
-    static final long serialVersionUID = 8019982251647420015L;
-
-    /** The DurationField being wrapped */
-    private final DurationField iField;
-
-    /**
-     * @param name allow name to be overridden
-     */
-    public DecoratedDurationField(DurationField field, String name) {
-        super(name);
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        if (!field.isSupported()) {
-            throw new IllegalArgumentException("The field must be supported");
-        }
-        iField = field;
-    }
-
-    /**
-     * Gets the wrapped duration field.
-     * 
-     * @return the wrapped DurationField
-     */
-    public final DurationField getWrappedField() {
-        return iField;
-    }
-
-    public boolean isPrecise() {
-        return iField.isPrecise();
-    }
-
-    public long getValueAsLong(long duration, long instant) {
-        return iField.getValueAsLong(duration, instant);
-    }
-
-    public long getMillis(int value, long instant) {
-        return iField.getMillis(value, instant);
-    }
-
-    public long getMillis(long value, long instant) {
-        return iField.getMillis(value, instant);
-    }
-
-    public long add(long instant, int value) {
-        return iField.add(instant, value);
-    }
-
-    public long add(long instant, long value) {
-        return iField.add(instant, value);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
deleted file mode 100644
index e494205..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
+++ /dev/null
@@ -1,494 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-
-/**
- * <code>DelegatedChronology</code> delegates each method call to the
- * chronology it wraps.
- * <p>
- * DelegatedChronology is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- * @see DecoratedChronology
- */
-public abstract class DelegatedChronology extends Chronology {
-    
-    static final long serialVersionUID = 216867504527676612L;
-
-    /** The Chronology being wrapped */
-    private final Chronology iChronology;
-    
-    /**
-     * Create a DelegatedChronology for any chronology.
-     *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
-     */
-    protected DelegatedChronology(Chronology chrono) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        iChronology = chrono;
-    }
-    
-    /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Get the Chronology in the UTC time zone.
-     * 
-     * @return Chronology in UTC
-     */
-    public abstract Chronology withUTC();
-
-    /**
-     * Get the Chronology in the any time zone.
-     * 
-     * @return Chronology in ant time zone
-     */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
-
-    /**
-     * Gets the time zone that this chronolog is using.
-     * 
-     * @return the DateTimeZone
-     */
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
-    public long getDateOnlyMillis(long instant) {
-        return iChronology.getDateOnlyMillis(instant);
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(long instant) {
-        return iChronology.getTimeOnlyMillis(instant);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    // Millis
-    //------------------------------------------------------------
-
-    /**
-     * Get the millis duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField millis() {
-        return iChronology.millis();
-    }
-
-    /**
-     * Get the millis of second field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfSecond() {
-        return iChronology.millisOfSecond();
-    }
-
-    /**
-     * Get the millis of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfDay() {
-        return iChronology.millisOfDay();
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    /**
-     * Get the seconds duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField seconds() {
-        return iChronology.seconds();
-    }
-
-    /**
-     * Get the second of minute field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfMinute() {
-        return iChronology.secondOfMinute();
-    }
-
-    /**
-     * Get the second of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfDay() {
-        return iChronology.secondOfDay();
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    /**
-     * Get the minutes duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField minutes() {
-        return iChronology.minutes();
-    }
-
-    /**
-     * Get the minute of hour field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfHour() {
-        return iChronology.minuteOfHour();
-    }
-
-    /**
-     * Get the minute of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfDay() {
-        return iChronology.minuteOfDay();
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    /**
-     * Get the hours duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField hours() {
-        return iChronology.hours();
-    }
-
-    /**
-     * Get the hour of day (0-23) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfDay() {
-        return iChronology.hourOfDay();
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfDay() {
-        return iChronology.clockhourOfDay();
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfHalfday() {
-        return iChronology.hourOfHalfday();
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfHalfday() {
-        return iChronology.clockhourOfHalfday();
-    }
-
-    /**
-     * Get the AM(0) PM(1) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField halfdayOfDay() {
-        return iChronology.halfdayOfDay();
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    /**
-     * Get the days duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField days() {
-        return iChronology.days();
-    }
-
-    /**
-     * Get the day of week field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfWeek() {
-        return iChronology.dayOfWeek();
-    }
-
-    /**
-     * Get the day of month field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfMonth() {
-        return iChronology.dayOfMonth();
-    }
-
-    /**
-     * Get the day of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfYear() {
-        return iChronology.dayOfYear();
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    /**
-     * Get the weeks duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weeks() {
-        return iChronology.weeks();
-    }
-
-    /**
-     * Get the week of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekOfWeekyear() {
-        return iChronology.weekOfWeekyear();
-    }
-
-    /**
-     * Get the weekyears duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weekyears() {
-        return iChronology.weekyears();
-    }
-
-    /**
-     * Get the year of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekyear() {
-        return iChronology.weekyear();
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    /**
-     * Get the months duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField months() {
-        return iChronology.months();
-    }
-
-    /**
-     * Get the month of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField monthOfYear() {
-        return iChronology.monthOfYear();
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    /**
-     * Get the years duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField years() {
-        return iChronology.years();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField year() {
-        return iChronology.year();
-    }
-
-    /**
-     * Get the year of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfEra() {
-        return iChronology.yearOfEra();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfCentury() {
-        return iChronology.yearOfCentury();
-    }
-
-    /**
-     * Get the centuries duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField centuries() {
-        return iChronology.centuries();
-    }
-
-    /**
-     * Get the century of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField centuryOfEra() {
-        return iChronology.centuryOfEra();
-    }
-
-    /**
-     * Get the eras duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField eras() {
-        return iChronology.eras();
-    }
-
-    /**
-     * Get the era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField era() {
-        return iChronology.era();
-    }
-    
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
deleted file mode 100644
index 313fc30..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import java.util.Locale;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * <code>DelegatedDateTimeField</code> delegates each method call to the
- * date time field it wraps.
- * <p>
- * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DecoratedDateTimeField
- */
-public class DelegatedDateTimeField implements DateTimeField, Serializable {
-
-    static final long serialVersionUID = -4730164440214502503L;
-
-    /** The DateTimeField being wrapped */
-    private final DateTimeField iField;
-    /** A desriptive name for the field */
-    private final String iName;
-
-    protected DelegatedDateTimeField(DateTimeField field) {
-        this(field, null);
-    }
-
-    protected DelegatedDateTimeField(DateTimeField field, String name) {
-        super();
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        iField = field;
-        iName = name;
-    }
-
-    /**
-     * Gets the wrapped date time field.
-     * 
-     * @return the wrapped DateTimeField
-     */
-    public final DateTimeField getWrappedField() {
-        return iField;
-    }
-
-    public String getName() {
-        return (iName == null) ? iField.getName() : iName;
-    }
-
-    public boolean isSupported() {
-        return iField.isSupported();
-    }
-
-    public boolean isLenient() {
-        return iField.isLenient();
-    }
-
-    public int get(long instant) {
-        return iField.get(instant);
-    }
-
-    public String getAsText(long instant, Locale locale) {
-        return iField.getAsText(instant, locale);
-    }
-
-    public String getAsText(long instant) {
-        return iField.getAsText(instant);
-    }
-
-    public String getAsShortText(long instant, Locale locale) {
-        return iField.getAsShortText(instant, locale);
-    }
-
-    public String getAsShortText(long instant) {
-        return iField.getAsShortText(instant);
-    }
-
-    public long add(long instant, int value) {
-        return iField.add(instant, value);
-    }
-
-    public long add(long instant, long value) {
-        return iField.add(instant, value);
-    }
-
-    public long addWrapped(long instant, int value) {
-        return iField.addWrapped(instant, value);
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return iField.getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    public long set(long instant, int value) {
-        return iField.set(instant, value);
-    }
-
-    public long set(long instant, String text, Locale locale) {
-        return iField.set(instant, text, locale);
-    }
-
-    public long set(long instant, String text) {
-        return iField.set(instant, text);
-    }
-
-    public DurationField getDurationField() {
-        return iField.getDurationField();
-    }
-
-    public DurationField getRangeDurationField() {
-        return iField.getRangeDurationField();
-    }
-
-    public boolean isLeap(long instant) {
-        return iField.isLeap(instant);
-    }
-
-    public int getLeapAmount(long instant) {
-        return iField.getLeapAmount(instant);
-    }
-
-    public DurationField getLeapDurationField() {
-        return iField.getLeapDurationField();
-    }
-
-    public int getMinimumValue() {
-        return iField.getMinimumValue();
-    }
-
-    public int getMinimumValue(long instant) {
-        return iField.getMinimumValue(instant);
-    }
-
-    public int getMaximumValue() {
-        return iField.getMaximumValue();
-    }
-
-    public int getMaximumValue(long instant) {
-        return iField.getMaximumValue(instant);
-    }
-
-    public int getMaximumTextLength(Locale locale) {
-        return iField.getMaximumTextLength(locale);
-    }
-
-    public int getMaximumShortTextLength(Locale locale) {
-        return iField.getMaximumShortTextLength(locale);
-    }
-
-    public long roundFloor(long instant) {
-        return iField.roundFloor(instant);
-    }
-
-    public long roundCeiling(long instant) {
-        return iField.roundCeiling(instant);
-    }
-
-    public long roundHalfFloor(long instant) {
-        return iField.roundHalfFloor(instant);
-    }
-
-    public long roundHalfCeiling(long instant) {
-        return iField.roundHalfCeiling(instant);
-    }
-
-    public long roundHalfEven(long instant) {
-        return iField.roundHalfEven(instant);
-    }
-
-    public long remainder(long instant) {
-        return iField.remainder(instant);
-    }
-
-    public String toString() {
-        return (iName == null) ? iField.toString() :
-            ("DateTimeField[" + iName + ']');
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
deleted file mode 100644
index 2d191e7..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import org.joda.time.DurationField;
-
-/**
- * <code>DelegatedDurationField</code> delegates each method call to the
- * duration field it wraps.
- * <p>
- * DelegatedDurationField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @see DecoratedDurationField
- */
-public class DelegatedDurationField implements DurationField, Serializable {
-
-    static final long serialVersionUID = -5576443481242007829L;
-
-    /** The DurationField being wrapped */
-    private final DurationField iField;
-    /** A desriptive name for the field */
-    private final String iName;
-
-    protected DelegatedDurationField(DurationField field) {
-        this(field, null);
-    }
-
-    /**
-     * @param name allow name to be overridden
-     */
-    protected DelegatedDurationField(DurationField field, String name) {
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        iField = field;
-        iName = name;
-    }
-
-    /**
-     * Gets the wrapped duration field.
-     * 
-     * @return the wrapped DurationField
-     */
-    public final DurationField getWrappedField() {
-        return iField;
-    }
-
-    public String getName() {
-        return (iName == null) ? iField.getName() : iName;
-    }
-
-    /**
-     * Returns true if this field is supported.
-     */
-    public boolean isSupported() {
-        return iField.isSupported();
-    }
-
-    public boolean isPrecise() {
-        return iField.isPrecise();
-    }
-    
-    public int getValue(long duration) {
-        return iField.getValue(duration);
-    }
-
-    public long getValueAsLong(long duration) {
-        return iField.getValueAsLong(duration);
-    }
-
-    public int getValue(long duration, long instant) {
-        return iField.getValue(duration, instant);
-    }
-
-    public long getValueAsLong(long duration, long instant) {
-        return iField.getValueAsLong(duration, instant);
-    }
-
-    public long getMillis(int value) {
-        return iField.getMillis(value);
-    }
-
-    public long getMillis(long value) {
-        return iField.getMillis(value);
-    }
-
-    public long getMillis(int value, long instant) {
-        return iField.getMillis(value, instant);
-    }
-
-    public long getMillis(long value, long instant) {
-        return iField.getMillis(value, instant);
-    }
-
-    public long add(long instant, int value) {
-        return iField.add(instant, value);
-    }
-
-    public long add(long instant, long value) {
-        return iField.add(instant, value);
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return iField.getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
-    }
-
-    public int compareTo(Object durationField) {
-        return iField.compareTo(durationField);
-    }
-
-    public String toString() {
-        return (iName == null) ? iField.toString() :
-            ("DurationField[" + iName + ']');
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
deleted file mode 100644
index a8e9f41..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * Divides a DateTimeField such that the retrieved values are reduced by a
- * fixed divisor. The field's unit duration is scaled accordingly, but the
- * range duration is unchanged.
- * <p>
- * DividedDateTimeField is thread-safe and immutable.
- *
- * @see RemainderDateTimeField
- * 
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class DividedDateTimeField extends DecoratedDateTimeField {
-
-    static final long serialVersionUID = 8318475124230605365L;
-
-    // Shared with RemainderDateTimeField.
-    final int iDivisor;
-    final DurationField iDurationField;
-
-    private final int iMin;
-    private final int iMax;
-
-    /**
-     * Constructor.
-     * 
-     * @param field  the field to wrap, like "year()".
-     * @param name  short, descriptive name, like "century".
-     * @param durationName  short, descriptive name, like "centuries".
-     * @param divisor  divisor, such as 100 years in a century
-     * @throws IllegalArgumentException if divisor is less than two
-     */
-    public DividedDateTimeField(DateTimeField field,
-                                String name, String durationName, int divisor) {
-        super(field, name);
-                
-        if (divisor < 2) {
-            throw new IllegalArgumentException("The divisor must be at least 2");
-        }
-
-        DurationField unitField = field.getDurationField();
-        if (unitField == null) {
-            iDurationField = null;
-        } else {
-            iDurationField = new ScaledDurationField(unitField, durationName, divisor);
-        }
-
-        iDivisor = divisor;
-
-        int i = field.getMinimumValue();
-        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
-
-        int j = field.getMaximumValue();
-        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
-
-        iMin = min;
-        iMax = max;
-    }
-
-    /**
-     * Construct a DividedDateTimeField that compliments the given
-     * RemainderDateTimeField.
-     *
-     * @param remainderField  complimentary remainder field, like "yearOfCentury()".
-     * @param name  short, descriptive name, like "century".
-     */
-    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {
-        super(remainderField.getWrappedField(), name);
-        int divisor = iDivisor = remainderField.iDivisor;
-        iDurationField = remainderField.iRangeField;
-
-        DateTimeField field = getWrappedField();
-        int i = field.getMinimumValue();
-        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
-
-        int j = field.getMaximumValue();
-        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
-
-        iMin = min;
-        iMax = max;
-    }
-
-    /**
-     * Get the amount of scaled units from the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the amount of scaled units extracted from the input.
-     */
-    public int get(long instant) {
-        int value = getWrappedField().get(instant);
-        if (value >= 0) {
-            return value / iDivisor;
-        } else {
-            return ((value + 1) / iDivisor) - 1;
-        }
-    }
-
-    /**
-     * Add the specified amount of scaled units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of scaled units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int amount) {
-        return getWrappedField().add(instant, amount * iDivisor);
-    }
-
-    /**
-     * Add the specified amount of scaled units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of scaled units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, long amount) {
-        return getWrappedField().add(instant, amount * iDivisor);
-    }
-
-    /**
-     * Add to the scaled component of the specified time instant,
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of scaled units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;
-    }
-
-    /**
-     * Set the specified amount of scaled units to the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param value  value of scaled units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, iMin, iMax);
-        int remainder = getRemainder(getWrappedField().get(instant));
-        return getWrappedField().set(instant, value * iDivisor + remainder);
-    }
-
-    /**
-     * Returns a scaled version of the wrapped field's unit duration field.
-     */
-    public DurationField getDurationField() {
-        return iDurationField;
-    }
-
-    /**
-     * Get the minimum value for the field.
-     * 
-     * @return the minimum value
-     */
-    public int getMinimumValue() {
-        return iMin;
-    }
-
-    /**
-     * Get the maximum value for the field.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iMax;
-    }
-
-    public long roundFloor(long instant) {
-        DateTimeField field = getWrappedField();
-        return field.roundFloor(field.set(instant, get(instant) * iDivisor));
-    }
-
-    public long remainder(long instant) {
-        return set(instant, get(getWrappedField().remainder(instant)));
-    }
-
-    /**
-     * Returns the divisor applied, in the field's units.
-     * 
-     * @return the divisor
-     */
-    public int getDivisor() {
-        return iDivisor;
-    }
-
-    private int getRemainder(int value) {
-        if (value >= 0) {
-            return value % iDivisor;
-        } else {
-            return (iDivisor - 1) + ((value + 1) % iDivisor);
-        }
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
new file mode 100644
index 0000000..34946b8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -0,0 +1,1063 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+// Import for @link support
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.Instant;
+import org.joda.time.ReadableInstant;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.DecoratedDurationField;
+import org.joda.time.format.DateTimePrinter;
+import org.joda.time.format.ISODateTimeFormat;
+
+/**
+ * GJChronology provides access to the individual date time fields for the
+ * Gregorian/Julian defined chronological calendar system.
+ * <p>
+ * The Gregorian calendar replaced the Julian calendar, and the point in time
+ * when this chronology switches can be controlled using the second parameter
+ * of the getInstance method. By default this cutover is set to the date the
+ * Gregorian calendar was first instituted, October 15, 1582.
+ * <p>
+ * Before this date, this chronology uses the proleptic Julian calendar
+ * (proleptic means extending indefinitely). The Julian calendar has leap 
+ * years every four years, whereas the Gregorian has special rules for 100 
+ * and 400 years. A meaningful result will thus be obtained for all input 
+ * values. However before March 1, 4 CE, Julian leap years were irregular,
+ * and before 45 BCE there was no Julian calendar.
+ * <p>
+ * This chronology differs from {@link java.util.GregorianCalendar
+ * java.util.GregorianCalendar} in that years in BCE are returned
+ * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra
+ * field produces results compatible with GregorianCalendar.
+ * <p>
+ * The Julian calendar does not have a year zero, and so year -1 is followed by
+ * year 1. If the Gregorian cutover date is specified at or before year -1
+ * (Julian), year zero is defined. In other words, the proleptic Gregorian
+ * chronology implemented by this class has a year zero.
+ * <p>
+ * To create a pure proleptic Julian chronology, use {@link JulianChronology},
+ * and to create a pure proleptic Gregorian chronology, use
+ * {@link GregorianChronology}.
+ * <p>
+ * GJChronology is thread-safe and immutable.
+ * 
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class GJChronology extends AssembledChronology {
+
+    static final long serialVersionUID = -2545574827706931671L;
+
+    /**
+     * Convert a datetime from one chronology to another.
+     */
+    private static long convertByYear(long instant, Chronology from, Chronology to) {
+        return to.getDateTimeMillis
+            (from.year().get(instant),
+             from.monthOfYear().get(instant),
+             from.dayOfMonth().get(instant),
+             from.millisOfDay().get(instant));
+    }
+
+    /**
+     * Convert a datetime from one chronology to another.
+     */
+    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {
+        long newInstant;
+        newInstant = to.weekyear().set(0, from.weekyear().get(instant));
+        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));
+        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));
+        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));
+        return newInstant;
+    }
+
+    /**
+     * The default GregorianJulian cutover point
+     */
+    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);
+
+    /** Cache of zone to chronology list */
+    private static final Map cCache = new HashMap();
+
+    /**
+     * Factory method returns instances of the default GJ cutover
+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
+     * October 15, 1582 (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * <p>The time zone of the returned instance is UTC.
+     */
+    public static GJChronology getInstanceUTC() {
+        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);
+    }
+
+    /**
+     * Factory method returns instances of the default GJ cutover
+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
+     * October 15, 1582 (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * <p>The returned chronology is in the default time zone.
+     */
+    public static GJChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
+    }
+
+    /**
+     * Factory method returns instances of the GJ cutover chronology. This uses
+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
+     * value, October 4, 1582 (Julian) is followed by October 15, 1582
+     * (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * @param zone  the time zone to use, null is default
+     */
+    public static GJChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, DEFAULT_CUTOVER, 4);
+    }
+
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use, null means default
+     */
+    public static GJChronology getInstance(DateTimeZone zone,
+                                           ReadableInstant gregorianCutover) 
+    {
+        return getInstance(zone, gregorianCutover, 4);
+    }
+    
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use, null means default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     */
+    public static synchronized GJChronology getInstance(DateTimeZone zone,
+                                                        ReadableInstant gregorianCutover,
+                                                        int minDaysInFirstWeek)
+    {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        Instant cutoverInstant;
+        if (gregorianCutover == null) {
+            cutoverInstant = DEFAULT_CUTOVER;
+        } else {
+            cutoverInstant = gregorianCutover.toInstant();
+        }
+
+        GJChronology chrono;
+
+        ArrayList chronos = (ArrayList)cCache.get(zone);
+        if (chronos == null) {
+            chronos = new ArrayList(2);
+            cCache.put(zone, chronos);
+        } else {
+            for (int i=chronos.size(); --i>=0; ) {
+                chrono = (GJChronology)chronos.get(i);
+                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
+                    cutoverInstant.equals(chrono.getGregorianCutover())) {
+                    
+                    return chrono;
+                }
+            }
+        }
+
+        if (zone == DateTimeZone.UTC) {
+            chrono = new GJChronology
+                (JulianChronology.getInstance(zone, minDaysInFirstWeek),
+                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),
+                 cutoverInstant);
+        } else {
+            chrono = getInstance(DateTimeZone.UTC, gregorianCutover, minDaysInFirstWeek);
+            chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone));
+        }
+
+        chronos.add(chrono);
+
+        return chrono;
+    }
+
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     */
+    public static synchronized GJChronology getInstance(DateTimeZone zone,
+                                                        long gregorianCutover,
+                                                        int minDaysInFirstWeek)
+    {
+        Instant cutoverInstant;
+        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {
+            cutoverInstant = null;
+        } else {
+            cutoverInstant = new Instant(gregorianCutover);
+        }
+        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);
+    }
+
+    private JulianChronology iJulianChronology;
+    private GregorianChronology iGregorianChronology;
+    private Instant iCutoverInstant;
+
+    long iCutoverMillis;
+    long iGapDuration;
+
+    /**
+     * @param julian chronology used before the cutover instant
+     * @param gregorian chronology used at and after the cutover instant
+     * @param cutoverInstant instant when the gregorian chronology began
+     */
+    private GJChronology(JulianChronology julian,
+                         GregorianChronology gregorian,
+                         Instant cutoverInstant) {
+        super(null, new Object[] {julian, gregorian, cutoverInstant});
+    }
+
+    /**
+     * Called when applying a time zone.
+     */
+    private GJChronology(Chronology base) {
+        super(base, null);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getDateTimeZone(), iCutoverInstant, getMinimumDaysInFirstWeek());
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeZone();
+        }
+        return DateTimeZone.UTC;
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return withDateTimeZone(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
+        // Time fields are same for Julian and Gregorian.
+        return iGregorianChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+
+        // Assume date is Gregorian.
+        long instant = iGregorianChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth, millisOfDay);
+        if (instant < iCutoverMillis) {
+            // Maybe it's Julian.
+            instant = iJulianChronology.getDateTimeMillis
+                (year, monthOfYear, dayOfMonth, millisOfDay);
+            if (instant >= iCutoverMillis) {
+                // Okay, it's in the illegal cutover gap.
+                throw new IllegalArgumentException("Specified date does not exist");
+            }
+        }
+        return instant;
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
+        return getDateOnlyMillis(instant)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (year, monthOfYear, dayOfMonth,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    /**
+     * Gets the cutover instant between Gregorian and Julian chronologies.
+     * @return the cutover instant
+     */
+    public Instant getGregorianCutover() {
+        Instant cutover = iCutoverInstant;
+        if (cutover == null) {
+            iCutoverInstant = cutover = new Instant(iCutoverMillis);
+        }
+        return cutover;
+    }
+
+    public final int getMinimumDaysInFirstWeek() {
+        return iGregorianChronology.getMinimumDaysInFirstWeek();
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer(60);
+        sb.append("GJCutoverChronology");
+        sb.append('[');
+        sb.append(getDateTimeZone().getID());
+        sb.append(", ");
+
+        sb.append("cutover=");
+        ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());
+        DateTimePrinter printer;
+        if (withUTC().getTimeOnlyMillis(iCutoverMillis) == 0) {
+            printer = format.date();
+        } else {
+            printer = format.dateTime();
+        }
+        printer.printTo(sb, iCutoverMillis);
+
+        sb.append(", mdfw=");
+        sb.append(getMinimumDaysInFirstWeek());
+        sb.append(']');
+
+        return sb.toString();
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() != null) {
+            return;
+        }
+
+        Object[] params = (Object[])getParam();
+
+        JulianChronology julian = (JulianChronology)params[0];
+        GregorianChronology gregorian = (GregorianChronology)params[1];
+        Instant cutoverInstant = (Instant)params[2];
+        iCutoverMillis = cutoverInstant.getMillis();
+
+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
+            throw new IllegalArgumentException();
+        }
+
+        iJulianChronology = julian;
+        iGregorianChronology = gregorian;
+        iCutoverInstant = cutoverInstant;
+
+        // Compute difference between the chronologies at the cutover instant
+        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);
+
+        // Begin field definitions.
+
+        // First just copy all the Gregorian fields and then override those
+        // that need special attention.
+        fields.copyFieldsFrom(gregorian);
+        
+        // Assuming cutover is at midnight, all time of day fields can be
+        // gregorian since they are unaffected by cutover.
+
+        // Verify assumption.
+        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {
+            // Cutover is sometime in the day, so cutover fields are required
+            // for time of day.
+
+            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond);
+            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay);
+            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute);
+            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay);
+            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour);
+            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay);
+            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay);
+            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday);
+            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay);
+            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),
+                                                         fields.clockhourOfHalfday);
+            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay);
+        }
+
+        // These fields just require basic cutover support.
+        {
+            fields.era = new CutoverField(julian.era(), fields.era);
+            fields.dayOfMonth = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth);
+        }
+
+        // DayOfYear and weekOfWeekyear require special handling since cutover
+        // year has fewer days and weeks. Extend the cutover to the start of
+        // the next year or weekyear. This keeps the sequence unbroken during
+        // the cutover year.
+
+        {
+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);
+            fields.dayOfYear = new CutoverField
+                (julian.dayOfYear(), fields.dayOfYear, cutover);
+        }
+
+        {
+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
+            fields.weekOfWeekyear = new CutoverField
+                (julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);
+        }
+
+        // These fields are special because they have imprecise durations. The
+        // family of addition methods need special attention. Override affected
+        // duration fields as well.
+        {
+            fields.year = new ImpreciseCutoverField(julian.year(), fields.year);
+            fields.years = fields.year.getDurationField();
+            fields.yearOfEra = new ImpreciseCutoverField
+                (julian.yearOfEra(), fields.yearOfEra, fields.years);
+            fields.yearOfCentury = new ImpreciseCutoverField
+                (julian.yearOfCentury(), fields.yearOfCentury, fields.years);
+            
+            fields.centuryOfEra = new ImpreciseCutoverField
+                (julian.centuryOfEra(), fields.centuryOfEra);
+            fields.centuries = fields.centuryOfEra.getDurationField();
+            
+            fields.monthOfYear = new ImpreciseCutoverField
+                (julian.monthOfYear(), fields.monthOfYear);
+            fields.months = fields.monthOfYear.getDurationField();
+            
+            fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, true);
+            fields.weekyears = fields.weekyear.getDurationField();
+        }
+    }
+
+    long julianToGregorianByYear(long instant) {
+        return convertByYear(instant, iJulianChronology, iGregorianChronology);
+    }
+
+    long gregorianToJulianByYear(long instant) {
+        return convertByYear(instant, iGregorianChronology, iJulianChronology);
+    }
+
+    long julianToGregorianByWeekyear(long instant) {
+        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);
+    }
+
+    long gregorianToJulianByWeekyear(long instant) {
+        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);
+    }
+
+    /**
+     * This basic cutover field adjusts calls to 'get' and 'set' methods, and
+     * assumes that calls to add and addWrapped are unaffected by the cutover.
+     */
+    private class CutoverField extends AbstractDateTimeField {
+        static final long serialVersionUID = 3528501219481026402L;
+
+        final DateTimeField iJulianField;
+        final DateTimeField iGregorianField;
+        final long iCutover;
+        final boolean iConvertByWeekyear;
+
+        protected DurationField iDurationField;
+
+        /**
+         * @param julianField field from the chronology used before the cutover instant
+         * @param gregorianField field from the chronology used at and after the cutover
+         */
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField) {
+            this(julianField, gregorianField, iCutoverMillis, false);
+        }
+
+        /**
+         * @param julianField field from the chronology used before the cutover instant
+         * @param gregorianField field from the chronology used at and after the cutover
+         * @param convertByWeekyear
+         */
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, boolean convertByWeekyear) {
+            this(julianField, gregorianField, iCutoverMillis, convertByWeekyear);
+        }
+
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {
+            this(julianField, gregorianField, cutoverMillis, false);
+        }
+
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                     long cutoverMillis, boolean convertByWeekyear) {
+            super(gregorianField.getName());
+            iJulianField = julianField;
+            iGregorianField = gregorianField;
+            iCutover = cutoverMillis;
+            iConvertByWeekyear = convertByWeekyear;
+            // Although average length of Julian and Gregorian years differ,
+            // use the Gregorian duration field because it is more accurate.
+            iDurationField = gregorianField.getDurationField();
+        }
+
+        public boolean isLenient() {
+            return false;
+        }
+
+        public int get(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.get(instant);
+            } else {
+                return iJulianField.get(instant);
+            }
+        }
+
+        public String getAsText(long instant, Locale locale) {
+            if (instant >= iCutover) {
+                return iGregorianField.getAsText(instant, locale);
+            } else {
+                return iJulianField.getAsText(instant, locale);
+            }
+        }
+
+        public String getAsShortText(long instant, Locale locale) {
+            if (instant >= iCutover) {
+                return iGregorianField.getAsShortText(instant, locale);
+            } else {
+                return iJulianField.getAsShortText(instant, locale);
+            }
+        }
+
+        public long add(long instant, int value) {
+            return iGregorianField.add(instant, value);
+        }
+
+        public long add(long instant, long value) {
+            return iGregorianField.add(instant, value);
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+
+        public long set(long instant, int value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.set(instant, value);
+                if (instant < iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
+                    }
+                    // Verify that new value stuck.
+                    if (get(instant) != value) {
+                        throw new IllegalArgumentException
+                            ("Illegal value for " + iGregorianField.getName() + ": " + value);
+                    }
+                }
+            } else {
+                instant = iJulianField.set(instant, value);
+                if (instant >= iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
+                    }
+                    // Verify that new value stuck.
+                    if (get(instant) != value) {
+                        throw new IllegalArgumentException
+                            ("Illegal value for " + iJulianField.getName() + ": " + value);
+                    }
+                }
+            }
+            return instant;
+        }
+
+        public long set(long instant, String text, Locale locale) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.set(instant, text, locale);
+                if (instant < iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
+                    }
+                    // Cannot verify that new value stuck because set may be lenient.
+                }
+            } else {
+                instant = iJulianField.set(instant, text, locale);
+                if (instant >= iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
+                    }
+                    // Cannot verify that new value stuck because set may be lenient.
+                }
+            }
+            return instant;
+        }
+
+        public DurationField getDurationField() {
+            return iDurationField;
+        }
+
+        public DurationField getRangeDurationField() {
+            DurationField rangeField = iGregorianField.getRangeDurationField();
+            if (rangeField == null) {
+                rangeField = iJulianField.getRangeDurationField();
+            }
+            return rangeField;
+        }
+
+        public boolean isLeap(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.isLeap(instant);
+            } else {
+                return iJulianField.isLeap(instant);
+            }
+        }
+
+        public int getLeapAmount(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getLeapAmount(instant);
+            } else {
+                return iJulianField.getLeapAmount(instant);
+            }
+        }
+
+        public DurationField getLeapDurationField() {
+            return iGregorianField.getLeapDurationField();
+        }
+
+
+        public int getMinimumValue() {
+            // For all precise fields, the Julian and Gregorian limits are
+            // identical. Choose Julian to tighten up the year limits.
+            return iJulianField.getMinimumValue();
+        }
+        
+        public int getMinimumValue(long instant) {
+            if (instant < iCutover) {
+                return iJulianField.getMinimumValue(instant);
+            }
+
+            int min = iGregorianField.getMinimumValue(instant);
+
+            // Because the cutover may reduce the length of this field, verify
+            // the minimum by setting it.
+            instant = iGregorianField.set(instant, min);
+            if (instant < iCutover) {
+                min = iGregorianField.get(iCutover);
+            }
+
+            return min;
+        }
+
+        public int getMaximumValue() {
+            // For all precise fields, the Julian and Gregorian limits are
+            // identical.
+            return iGregorianField.getMaximumValue();
+        }
+
+        public int getMaximumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMaximumValue(instant);
+            }
+
+            int max = iJulianField.getMaximumValue(instant);
+
+            // Because the cutover may reduce the length of this field, verify
+            // the maximum by setting it.
+            instant = iJulianField.set(instant, max);
+            if (instant >= iCutover) {
+                max = iJulianField.get(iJulianField.add(iCutover, -1));
+            }
+
+            return max;
+        }
+
+        public long roundFloor(long instant) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.roundFloor(instant);
+                if (instant < iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
+                    }
+                }
+            } else {
+                instant = iJulianField.roundFloor(instant);
+            }
+            return instant;
+        }
+
+        public long roundCeiling(long instant) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.roundCeiling(instant);
+            } else {
+                instant = iJulianField.roundCeiling(instant);
+                if (instant >= iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
+                    }
+                }
+            }
+            return instant;
+        }
+
+        public int getMaximumTextLength(Locale locale) {
+            return Math.max(iJulianField.getMaximumTextLength(locale),
+                            iGregorianField.getMaximumTextLength(locale));
+        }
+
+        public int getMaximumShortTextLength(Locale locale) {
+            return Math.max(iJulianField.getMaximumShortTextLength(locale),
+                            iGregorianField.getMaximumShortTextLength(locale));
+        }
+
+        protected long julianToGregorian(long instant) {
+            if (iConvertByWeekyear) {
+                return julianToGregorianByWeekyear(instant);
+            } else {
+                return julianToGregorianByYear(instant);
+            }
+        }
+
+        protected long gregorianToJulian(long instant) {
+            if (iConvertByWeekyear) {
+                return gregorianToJulianByWeekyear(instant);
+            } else {
+                return gregorianToJulianByYear(instant);
+            }
+        }
+    }
+
+    /**
+     * Cutover field for variable length fields. These fields internally call
+     * set whenever add is called. As a result, the same correction applied to
+     * set must be applied to add and addWrapped. Knowing when to use this
+     * field requires specific knowledge of how the GJ fields are implemented.
+     */
+    private final class ImpreciseCutoverField extends CutoverField {
+        static final long serialVersionUID = 3410248757173576441L;
+
+        /**
+         * Creates a duration field that links back to this.
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {
+            this(julianField, gregorianField, null, false);
+        }
+
+        /**
+         * Creates a duration field that links back to this.
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              boolean convertByWeekyear) {
+            this(julianField, gregorianField, null, convertByWeekyear);
+        }
+
+        /**
+         * Uses a shared duration field rather than creating a new one.
+         *
+         * @param durationField shared duration field
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              DurationField durationField)
+        {
+            this(julianField, gregorianField, durationField, false);
+        }
+
+        /**
+         * Uses a shared duration field rather than creating a new one.
+         *
+         * @param durationField shared duration field
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              DurationField durationField, boolean convertByWeekyear)
+        {
+            super(julianField, gregorianField, convertByWeekyear);
+            if (durationField == null) {
+                durationField = new LinkedDurationField(iDurationField, this);
+            }
+            iDurationField = durationField;
+        }
+
+        public long add(long instant, int value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.add(instant, value);
+                if (instant < iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
+                    }
+                }
+            } else {
+                instant = iJulianField.add(instant, value);
+                if (instant >= iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
+                    }
+                }
+            }
+            return instant;
+        }
+        
+        public long add(long instant, long value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.add(instant, value);
+                if (instant < iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
+                    }
+                }
+            } else {
+                instant = iJulianField.add(instant, value);
+                if (instant >= iCutover) {
+                    // Only adjust if gap fully crossed.
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
+                    }
+                }
+            }
+            return instant;
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            if (minuendInstant >= iCutover) {
+                if (subtrahendInstant >= iCutover) {
+                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
+                }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Julian, convert minuend to Julian to match.
+                minuendInstant = gregorianToJulian(minuendInstant);
+                return iJulianField.getDifference(minuendInstant, subtrahendInstant);
+            } else {
+                if (subtrahendInstant < iCutover) {
+                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);
+                }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Gregorian, convert minuend to Gregorian to match.
+                minuendInstant = julianToGregorian(minuendInstant);
+                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
+            }
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            if (minuendInstant >= iCutover) {
+                if (subtrahendInstant >= iCutover) {
+                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+                }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Julian, convert minuend to Julian to match.
+                minuendInstant = gregorianToJulian(minuendInstant);
+                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+            } else {
+                if (subtrahendInstant < iCutover) {
+                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+                }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Gregorian, convert minuend to Gregorian to match.
+                minuendInstant = julianToGregorian(minuendInstant);
+                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+            }
+        }
+
+        // Since the imprecise fields have durations longer than the gap
+        // duration, keep these methods simple. The inherited implementations
+        // produce incorrect results.
+        //
+        // Degenerate case: If this field is a month, and the cutover is set
+        // far into the future, then the gap duration may be so large as to
+        // reduce the number of months in a year. If the missing month(s) are
+        // at the beginning or end of the year, then the minimum and maximum
+        // values are not 1 and 12. I don't expect this case to ever occur.
+
+        public int getMinimumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMinimumValue(instant);
+            } else {
+                return iJulianField.getMinimumValue(instant);
+            }
+        }
+
+        public int getMaximumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMaximumValue(instant);
+            } else {
+                return iJulianField.getMaximumValue(instant);
+            }
+        }
+    }
+
+    /**
+     * Links the duration back to a ImpreciseCutoverField.
+     */
+    private static class LinkedDurationField extends DecoratedDurationField {
+        static final long serialVersionUID = 4097975388007713084L;
+
+        private final ImpreciseCutoverField iField;
+
+        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {
+            super(durationField, durationField.getName());
+            iField = dateTimeField;
+        }
+
+        public long add(long instant, int value) {
+            return iField.add(instant, value);
+        }
+
+        public long add(long instant, long value) {
+            return iField.add(instant, value);
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return iField.getDifference(minuendInstant, subtrahendInstant);
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
new file mode 100644
index 0000000..092424f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
@@ -0,0 +1,119 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * Provides time calculations for the day of the month component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -4677223814028011723L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    GJDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {
+        super("dayOfMonth", days);
+        iChronology = chronology;
+    }
+
+    /**
+     * Get the day of the month component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the day of the month extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getDayOfMonth(instant);
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.months();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 31;
+    }
+
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.getYear(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
+        return iChronology.getDaysInYearMonth(thisYear, thisMonth);
+    }
+
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 28 ? getMaximumValue(instant) : 28;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.dayOfMonth();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
new file mode 100644
index 0000000..2b6ad26
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
@@ -0,0 +1,177 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * GJDayOfWeekDateTimeField provides time calculations for the
+ * day of the week component of time.
+ *
+ * @since 1.0
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ */
+final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {
+    
+    static final long serialVersionUID = -3857947176719041436L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    GJDayOfWeekDateTimeField(AbstractGJChronology chronology, DurationField days) {
+        super("dayOfWeek", days);
+        iChronology = chronology;
+    }
+
+    /**
+     * Get the value of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query
+     * @return the day of the week extracted from the input
+     */
+    public int get(long instant) {
+        return iChronology.getDayOfWeek(instant);
+    }
+
+    /**
+     * Get the textual value of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query
+     * @param locale  the locale to use
+     * @return the day of the week, such as 'Monday'
+     */
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));
+    }
+
+    /**
+     * Get the abbreviated textual value of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query
+     * @param locale  the locale to use
+     * @return the day of the week, such as 'Mon'
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));
+    }
+
+    /**
+     * Set the value of the specified time instant from text.
+     * 
+     * @param instant  the time instant in millis to update
+     * @param text  the text to set from
+     * @param locale  the locale to use
+     * @return the updated millis
+     */
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.weeks();
+    }
+
+    /**
+     * Get the minimum value that this field can have.
+     * 
+     * @return the field's minimum value
+     */
+    public int getMinimumValue() {
+        return DateTimeConstants.MONDAY;
+    }
+
+    /**
+     * Get the maximum value that this field can have.
+     * 
+     * @return the field's maximum value
+     */
+    public int getMaximumValue() {
+        return DateTimeConstants.SUNDAY;
+    }
+
+    /**
+     * Get the maximum length of the text returned by this field.
+     * 
+     * @param locale  the locale to use
+     * @return the maximum textual length
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();
+    }
+
+    /**
+     * Get the maximum length of the abbreviated text returned by this field.
+     * 
+     * @param locale  the locale to use
+     * @return the maximum abbreviated textual length
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.dayOfWeek();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
new file mode 100644
index 0000000..45ad5b6
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
@@ -0,0 +1,119 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * Provides time calculations for the day of the year component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -6821236822336841037L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJDayOfYearDateTimeField(AbstractGJChronology chronology, DurationField days) {
+        super("dayOfYear", days);
+        iChronology = chronology;
+    }
+
+    /**
+     * Get the day of the year component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the day of the year extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getDayOfYear(instant);
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 366;
+    }
+
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.getYear(instant);
+        return iChronology.getDaysInYear(thisYear);
+    }
+
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 365 ? getMaximumValue(instant) : 365;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.dayOfYear();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
new file mode 100644
index 0000000..093764a
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
@@ -0,0 +1,188 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the era component of time.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @version 1.0
+ * @since 1.0
+ */
+final class GJEraDateTimeField extends AbstractDateTimeField {
+    
+    static final long serialVersionUID = 4240986525305515528L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJEraDateTimeField(AbstractGJChronology chronology) {
+        super("era");
+        iChronology = chronology;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Era component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     */
+    public int get(long instant) {
+        if (iChronology.getYear(instant) <= 0) {
+            return DateTimeConstants.BCE;
+        } else {
+            return DateTimeConstants.CE;
+        }
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));
+    }
+
+    /**
+     * Set the Era component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param era  the era to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
+     */
+    public long set(long instant, int era) {
+        FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);
+            
+        int oldEra = get(instant);
+        if (oldEra != era) {
+            int year = iChronology.getYear(instant);
+            return iChronology.setYear(instant, -year);
+        } else {
+            return instant;
+        }
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));
+    }
+
+    public long roundFloor(long instant) {
+        if (get(instant) == DateTimeConstants.CE) {
+            return iChronology.setYear(0, 1);
+        } else {
+            return Long.MIN_VALUE;
+        }
+    }
+
+    public long roundCeiling(long instant) {
+        if (get(instant) == DateTimeConstants.BCE) {
+            return iChronology.setYear(0, 1);
+        } else {
+            return Long.MAX_VALUE;
+        }
+    }
+
+    public long roundHalfFloor(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
+    }
+
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public int getMinimumValue() {
+        return DateTimeConstants.BCE;
+    }
+
+    public int getMaximumValue() {
+        return DateTimeConstants.CE;
+    }
+
+    public int getMaximumTextLength(Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.era();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
new file mode 100644
index 0000000..cea8005
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -0,0 +1,259 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.lang.ref.WeakReference;
+import java.text.DateFormatSymbols;
+import java.util.WeakHashMap;
+import java.util.Locale;
+
+/**
+ * Utility class used by a few of the GJDateTimeFields.
+ *
+ * @author Brian S O'Neill
+ */
+class GJLocaleSymbols {
+    private static final int FAST_CACHE_SIZE = 64;
+
+    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
+
+    private static WeakHashMap cCache = new WeakHashMap();
+
+    public static GJLocaleSymbols forLocale(Locale locale) {
+        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
+        GJLocaleSymbols symbols = cFastCache[index];
+        if (symbols != null && symbols.iLocale.get() == locale) {
+            return symbols;
+        }
+        synchronized (cCache) {
+            symbols = (GJLocaleSymbols) cCache.get(locale);
+            if (symbols == null) {
+                symbols = new GJLocaleSymbols(locale);
+                cCache.put(locale, symbols);
+            }
+        }
+        cFastCache[index] = symbols;
+        return symbols;
+    }
+
+    private static String[] realignMonths(String[] months) {
+        String[] a = new String[13];
+        for (int i=1; i<13; i++) {
+            a[i] = months[i - 1];
+        }
+        return a;
+    }
+
+    private static String[] realignDaysOfWeek(String[] daysOfWeek) {
+        String[] a = new String[8];
+        for (int i=1; i<8; i++) {
+            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];
+        }
+        return a;
+    }
+
+    private static int maxLength(String[] a) {
+        int max = 0;
+        for (int i=a.length; --i>=0; ) {
+            String s = a[i];
+            if (s != null) {
+                int len = s.length();
+                if (len > max) {
+                    max = len;
+                }
+            }
+        }
+        return max;
+    }
+
+    private final WeakReference iLocale;
+
+    private final String[] iEras;
+    private final String[] iDaysOfWeek;
+    private final String[] iShortDaysOfWeek;
+    private final String[] iMonths;
+    private final String[] iShortMonths;
+    private final String[] iHalfday;
+
+    private final int iMaxEraLength;
+    private final int iMaxDayOfWeekLength;
+    private final int iMaxShortDayOfWeekLength;
+    private final int iMaxMonthLength;
+    private final int iMaxShortMonthLength;
+    private final int iMaxHalfdayLength;
+
+    private GJLocaleSymbols(Locale locale) {
+        if (locale == null) {
+            locale = Locale.getDefault();
+        }
+
+        iLocale = new WeakReference(locale);
+
+        DateFormatSymbols dfs = new DateFormatSymbols(locale);
+
+        iEras = dfs.getEras();
+        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());
+        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());
+        iMonths = realignMonths(dfs.getMonths());
+        iShortMonths = realignMonths(dfs.getShortMonths());
+        iHalfday = dfs.getAmPmStrings();
+
+        iMaxEraLength = maxLength(iEras);
+        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);
+        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);
+        iMaxMonthLength = maxLength(iMonths);
+        iMaxShortMonthLength = maxLength(iShortMonths);
+        iMaxHalfdayLength = maxLength(iHalfday);
+    }
+
+    public String eraValueToText(int value) {
+        return iEras[value];
+    }
+
+    public int eraTextToValue(String text) {
+        String[] eras = iEras;
+        for (int i=eras.length; --i>=0; ) {
+            if (eras[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("Illegal era text: " + text);
+    }
+
+    public int getEraMaxTextLength() {
+        return iMaxEraLength;
+    }
+
+    public String monthOfYearValueToText(int value) {
+        return iMonths[value];
+    }
+
+    public String monthOfYearValueToShortText(int value) {
+        return iShortMonths[value];
+    }
+
+    public int monthOfYearTextToValue(String text) {
+        String[] months = iMonths;
+        for (int i=months.length; --i>=1; ) {
+            if (months[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        months = iShortMonths;
+        for (int i=months.length; --i>=1; ) {
+            if (months[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
+    }
+
+    public int getMonthMaxTextLength() {
+        return iMaxMonthLength;
+    }
+
+    public int getMonthMaxShortTextLength() {
+        return iMaxShortMonthLength;
+    }
+
+    public String dayOfWeekValueToText(int value) {
+        return iDaysOfWeek[value];
+    }
+
+    public String dayOfWeekValueToShortText(int value) {
+        return iShortDaysOfWeek[value];
+    }
+
+    public int dayOfWeekTextToValue(String text) {
+        String[] daysOfWeek = iDaysOfWeek;
+        for (int i=daysOfWeek.length; --i>=1; ) {
+            if (daysOfWeek[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        daysOfWeek = iShortDaysOfWeek;
+        for (int i=daysOfWeek.length; --i>=1; ) {
+            if (daysOfWeek[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);
+    }
+
+    public int getDayOfWeekMaxTextLength() {
+        return iMaxDayOfWeekLength;
+    }
+
+    public int getDayOfWeekMaxShortTextLength() {
+        return iMaxShortDayOfWeekLength;
+    }
+
+    public String halfdayValueToText(int value) {
+        return iHalfday[value];
+    }
+
+    public int halfdayTextToValue(String text) {
+        String[] halfday = iHalfday;
+        for (int i = halfday.length; --i>=0; ) {
+            if (halfday[i].equalsIgnoreCase(text)) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("Illegal halfday text: " + text);
+    }
+
+    public int getHalfdayMaxTextLength() {
+        return iMaxHalfdayLength;
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
new file mode 100644
index 0000000..c453b38
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
@@ -0,0 +1,380 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the month of the year component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @version 1.0
+ * @since 1.0
+ */
+final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
+
+    static final long serialVersionUID = -4748157875845286249L;
+
+    private static final int MIN = DateTimeConstants.JANUARY;
+    private static final int MAX = DateTimeConstants.DECEMBER;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJMonthOfYearDateTimeField(AbstractGJChronology chronology) {
+        super("monthOfYear", "months", chronology.getAverageMillisPerMonth());
+        iChronology = chronology;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Month component of the specified time instant.
+     *
+     * @see org.joda.time.DateTimeField#get(long)
+     * @see org.joda.time.ReadableDateTime#getMonthOfYear()
+     * @param instant  the time instant in millis to query.
+     * @return the month extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getMonthOfYear(instant);
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));
+    }
+
+    public String getAsShortText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));
+    }
+
+    /**
+     * Add the specified month to the specified time instant.
+     * The amount added may be negative.<p>
+     * If the new month has less total days than the specified
+     * day of the month, this value is coerced to the nearest
+     * sane value. e.g.<p>
+     * 07-31 - (1 month) = 06-30<p>
+     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>
+     * 
+     * @see org.joda.time.DateTimeField#add
+     * @see org.joda.time.ReadWritableDateTime#addMonths(int)
+     * @param instant  the time instant in millis to update.
+     * @param months  the months to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int months) {
+        if (months == 0) {
+            return instant; // the easy case
+        }
+        //
+        // Save time part first.
+        //
+        long timePart = iChronology.getMillisOfDay(instant);
+        //
+        //
+        // Get this year and month.
+        //
+        int thisYear = iChronology.getYear(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
+        // ----------------------------------------------------------
+        //
+        // Do not refactor without careful consideration.
+        // Order of calculation is important.
+        //
+        int yearToUse;
+        // Initially, monthToUse is zero-based
+        int monthToUse = thisMonth - 1 + months;
+        if (monthToUse >= 0) {
+            yearToUse = thisYear + (monthToUse / MAX);
+            monthToUse = (monthToUse % MAX) + 1;
+        } else {
+            yearToUse = thisYear + (monthToUse / MAX) - 1;
+            monthToUse = Math.abs(monthToUse);
+            int remMonthToUse = monthToUse % MAX;
+            // Take care of the boundary condition
+            if (remMonthToUse == 0) {
+                remMonthToUse = MAX;
+            }
+            monthToUse = MAX - remMonthToUse + 1;
+            // Take care of the boundary condition
+            if (monthToUse == 1) {
+                yearToUse += 1;
+            }
+        }
+        // End of do not refactor.
+        // ----------------------------------------------------------
+
+        //
+        // Quietly force DOM to nearest sane value.
+        //
+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
+        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
+        if (dayToUse > maxDay) {
+            dayToUse = maxDay;
+        }
+        //
+        // get proper date part, and return result
+        //
+        long datePart =
+            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);
+        return datePart + timePart;
+    }
+
+    public long add(long instant, long months) {
+        int i_months = (int)months;
+        if (i_months == months) {
+            return add(instant, i_months);
+        }
+
+        // Copied from add(long, int) and modified slightly:
+
+        long timePart = iChronology.getMillisOfDay(instant);
+
+        int thisYear = iChronology.getYear(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
+
+        long yearToUse;
+        long monthToUse = thisMonth - 1 + months;
+        if (monthToUse >= 0) {
+            yearToUse = thisYear + (monthToUse / MAX);
+            monthToUse = (monthToUse % MAX) + 1;
+        } else {
+            yearToUse = thisYear + (monthToUse / MAX) - 1;
+            monthToUse = Math.abs(monthToUse);
+            int remMonthToUse = (int)(monthToUse % MAX);
+            if (remMonthToUse == 0) {
+                remMonthToUse = MAX;
+            }
+            monthToUse = MAX - remMonthToUse + 1;
+            if (monthToUse == 1) {
+                yearToUse += 1;
+            }
+        }
+
+        if (yearToUse < iChronology.getMinYear() ||
+            yearToUse > iChronology.getMaxYear()) {
+
+            throw new IllegalArgumentException
+                ("Magnitude of add amount is too large: " + months);
+        }
+
+        int i_yearToUse = (int)yearToUse;
+        int i_monthToUse = (int)monthToUse;
+
+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
+        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);
+        if (dayToUse > maxDay) {
+            dayToUse = maxDay;
+        }
+
+        long datePart =
+            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);
+        return datePart + timePart;
+    }
+
+    /**
+     * Add to the Month component of the specified time instant
+     * wrapping around within that component if necessary.
+     * 
+     * @see org.joda.time.DateTimeField#addWrapped
+     * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)
+     * @param instant  the time instant in millis to update.
+     * @param months  the months to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int months) {
+        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
+        }
+
+        int minuendYear = iChronology.getYear(minuendInstant);
+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);
+        int subtrahendYear = iChronology.getYear(subtrahendInstant);
+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);
+
+        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;
+
+        // Before adjusting for remainder, account for special case of add
+        // where the day-of-month is forced to the nearest sane value.
+        int minuendDom = iChronology.getDayOfMonth
+            (minuendInstant, minuendYear, minuendMonth);
+        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {
+            // Last day of the minuend month...
+            int subtrahendDom = iChronology.getDayOfMonth
+                (subtrahendInstant, subtrahendYear, subtrahendMonth);
+            if (subtrahendDom > minuendDom) {
+                // ...and day of subtrahend month is larger.
+                // TODO: Don't depend on other fields
+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);
+            }
+        }
+
+        // Inlined remainder method to avoid duplicate calls.
+        long minuendRem = minuendInstant
+            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);
+        long subtrahendRem = subtrahendInstant
+            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);
+
+        if (minuendRem < subtrahendRem) {
+            difference--;
+        }
+
+        return difference;
+    }
+
+    /**
+     * Set the Month component of the specified time instant.<p>
+     * If the new month has less total days than the specified
+     * day of the month, this value is coerced to the nearest
+     * sane value. e.g.<p>
+     * 07-31 to month 6 = 06-30<p>
+     * 03-31 to month 2 = 02-28 or 02-29 depending<p>
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param month  the month (1,12) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if month is invalid
+     */
+    public long set(long instant, int month) {
+        FieldUtils.verifyValueBounds(this, month, MIN, MAX);
+        //
+        int thisYear = iChronology.getYear(instant);
+        //
+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);
+        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);
+        if (thisDom > maxDom) {
+            // Quietly force DOM to nearest sane value.
+            thisDom = maxDom;
+        }
+        // Return newly calculated millis value
+        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +
+            iChronology.getMillisOfDay(instant);
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
+    }
+
+    public boolean isLeap(long instant) {
+        int thisYear = iChronology.getYear(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
+        if (thisMonth != 2) {
+            return false;
+        } else {
+            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);
+        }
+    }
+
+    public int getLeapAmount(long instant) {
+        return isLeap(instant) ? 1 : 0;
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
+    }
+
+    public int getMinimumValue() {
+        return MIN;
+    }
+
+    public int getMaximumValue() {
+        return MAX;
+    }
+
+    public int getMaximumTextLength(Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();
+    }
+
+    public int getMaximumShortTextLength(Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();
+    }
+
+    public long roundFloor(long instant) {
+        int year = iChronology.getYear(instant);
+        int month = iChronology.getMonthOfYear(instant, year);
+        return iChronology.getYearMonthMillis(year, month);
+    }
+
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.monthOfYear();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
new file mode 100644
index 0000000..074fb40
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
@@ -0,0 +1,139 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * Provides time calculations for the week of a week based year component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @version 1.0
+ * @since 1.0
+ */
+final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -1587436826395135328L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJWeekOfWeekyearDateTimeField(AbstractGJChronology chronology, DurationField weeks) {
+        super("weekOfWeekyear", weeks);
+        iChronology = chronology;
+    }
+
+    /**
+     * Get the week of a week based year component of the specified time instant.
+     * 
+     * @see org.joda.time.DateTimeField#get(long)
+     * @param instant  the time instant in millis to query.
+     * @return the week of the year extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getWeekOfWeekyear(instant);
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.weekyears();
+    }
+
+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to
+    // apply a corrective alignment since weeks begin on day of week 1, Monday.
+
+    public long roundFloor(long instant) {
+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
+            - 3 * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    public long roundCeiling(long instant) {
+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
+            - 3 * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    public long remainder(long instant) {
+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 53;
+    }
+
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.getWeekyear(instant);
+        return iChronology.getWeeksInYear(thisYear);
+    }
+
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 52 ? getMaximumValue(instant) : 52;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.weekOfWeekyear();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
new file mode 100644
index 0000000..b7c1950
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
@@ -0,0 +1,290 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the week of the weekyear component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @version 1.0
+ * @since 1.0
+ * @see org.joda.time.DateTimeField
+ */
+final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {
+    
+    static final long serialVersionUID = 6215066916806820644L;
+
+    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJWeekyearDateTimeField(AbstractGJChronology chronology) {
+        super("weekyear", "weekyears", chronology.getAverageMillisPerYear());
+        iChronology = chronology;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Year of a week based year component of the specified time instant.
+     * 
+     * @see org.joda.time.DateTimeField#get
+     * @param instant  the time instant in millis to query.
+     * @return the year extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getWeekyear(instant);
+    }
+
+    /**
+     * Add the specified years to the specified time instant.
+     * 
+     * @see org.joda.time.DateTimeField#add
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int years) {
+        if (years == 0) {
+            return instant;
+        }
+        return set(instant, get(instant) + years);
+    }
+
+    public long add(long instant, long value) {
+        return add(instant, FieldUtils.safeToInt(value));
+    }
+
+    /**
+     * Add to the year component of the specified time instant
+     * wrapping around within that component if necessary.
+     * 
+     * @see org.joda.time.DateTimeField#addWrapped
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int years) {
+        return add(instant, years);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
+        }
+
+        int minuendWeekyear = get(minuendInstant);
+        int subtrahendWeekyear = get(subtrahendInstant);
+
+        long minuendRem = remainder(minuendInstant);
+        long subtrahendRem = remainder(subtrahendInstant);
+
+        // Balance leap weekyear differences on remainders.
+        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {
+            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;
+        }
+
+        int difference = minuendWeekyear - subtrahendWeekyear;
+        if (minuendRem < subtrahendRem) {
+            difference--;
+        }
+        return difference;
+    }
+
+    /**
+     * Set the Year of a week based year component of the specified time instant.
+     *
+     * @see org.joda.time.DateTimeField#set
+     * @param instant  the time instant in millis to update.
+     * @param year  the year (-9999,9999) to set the date to.
+     * @return the updated DateTime.
+     * @throws IllegalArgumentException  if year is invalid.
+     */
+    public long set(long instant, int year) {
+        FieldUtils.verifyValueBounds(this, Math.abs(year),
+                                     iChronology.getMinYear(), iChronology.getMaxYear());
+        //
+        // Do nothing if no real change is requested.
+        //
+        int thisWeekyear = get( instant );
+        if ( thisWeekyear == year ) {
+            return instant;
+        }
+        //
+        // Calculate the DayOfWeek (to be preserved).
+        //
+        int thisDow = iChronology.getDayOfWeek(instant);
+        //
+        // Calculate the maximum weeks in the target year.
+        //
+        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );
+        int weeksInToYear = iChronology.getWeeksInYear( year );
+        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?
+            weeksInToYear : weeksInFromYear;
+        //
+        // Get the current week of the year. This will be preserved in
+        // the output unless it is greater than the maximum possible
+        // for the target weekyear.  In that case it is adjusted
+        // to the maximum possible.
+        //
+        int setToWeek = iChronology.getWeekOfWeekyear(instant);
+        if ( setToWeek > maxOutWeeks ) {
+            setToWeek = maxOutWeeks;
+        }
+        //
+        // Get a wroking copy of the current date-time.
+        // This can be a convenience for debugging.
+        //
+        long workInstant = instant; // Get a copy
+        //
+        // Attempt to get close to the proper weekyear.
+        // Note - we cannot currently call ourself, so we just call
+        // set for the year.  This at least gets us close.
+        //
+        workInstant = iChronology.setYear( workInstant, year );
+        //
+        // Calculate the weekyear number for the get close to value
+        // (which might not be equal to the year just set).
+        //
+        int workWoyYear = get( workInstant );
+
+        //
+        // At most we are off by one year, which can be "fixed" by
+        // adding/subtracting a week.
+        //
+        if ( workWoyYear < year ) {
+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;
+        } else if ( workWoyYear > year ) {
+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;
+        }
+        //
+        // Set the proper week in the current weekyear.
+        //
+
+        // BEGIN: possible set WeekOfWeekyear logic.
+        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);
+        // No range check required (we already know it is OK).
+        workInstant = workInstant + (setToWeek - currentWoyWeek)
+            * (long)DateTimeConstants.MILLIS_PER_WEEK;
+        // END: possible set WeekOfWeekyear logic.
+
+        //
+        // Reset DayOfWeek to previous value.
+        //
+        // TODO: Don't depend on other fields
+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );
+        //
+        // Return result.
+        //
+        return workInstant;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public boolean isLeap(long instant) {
+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;
+    }
+
+    public int getLeapAmount(long instant) {
+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.weeks();
+    }
+
+    public int getMinimumValue() {
+        return iChronology.getMinYear();
+    }
+
+    public int getMaximumValue() {
+        return iChronology.getMaxYear();
+    }
+
+    public long roundFloor(long instant) {
+        // TODO: Don't depend on other fields
+        instant = iChronology.weekOfWeekyear().roundFloor(instant);
+        int wow = iChronology.getWeekOfWeekyear(instant);
+        if (wow > 1) {
+            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);
+        }
+        return instant;
+    }
+
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.weekyear();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
new file mode 100644
index 0000000..c7312a8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
@@ -0,0 +1,235 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DurationField;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the year component of time.
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class GJYearDateTimeField extends ImpreciseDateTimeField {
+
+    static final long serialVersionUID = -679076949530018869L;
+
+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    GJYearDateTimeField(AbstractGJChronology chronology) {
+        super("year", "years", chronology.getAverageMillisPerYear());
+        iChronology = chronology;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Year component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the year extracted from the input.
+     */
+    public int get(long instant) {
+        return iChronology.getYear(instant);
+    }
+
+    /**
+     * Add the specified year to the specified time instant.
+     * The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int years) {
+        if (years == 0) {
+            return instant;
+        }
+        int thisYear = get(instant);
+        int newYear = thisYear + years;
+        return set(instant, newYear);
+    }
+
+    public long add(long instant, long years) {
+        return add(instant, FieldUtils.safeToInt(years));
+    }
+
+    /**
+     * Add to the Year component of the specified time instant
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int years) {
+        if (years == 0) {
+            return instant;
+        }
+        // Return newly calculated millis value
+        int thisYear = iChronology.getYear(instant);
+        int wrappedYear = FieldUtils.getWrappedValue
+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());
+        return set(instant, wrappedYear);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
+        }
+
+        int minuendYear = get(minuendInstant);
+        int subtrahendYear = get(subtrahendInstant);
+
+        // Inlined remainder method to avoid duplicate calls to get.
+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);
+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);
+
+        // Balance leap year differences on remainders.
+        if (subtrahendRem >= FEB_29) {
+            if (iChronology.isLeapYear(subtrahendYear)) {
+                if (!iChronology.isLeapYear(minuendYear)) {
+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;
+                }
+            } else if (minuendRem >= FEB_29 && iChronology.isLeapYear(minuendYear)) {
+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;
+            }
+        }
+
+        int difference = minuendYear - subtrahendYear;
+        if (minuendRem < subtrahendRem) {
+            difference--;
+        }
+        return difference;
+    }
+
+    /**
+     * Set the Year component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param year  the year (-292269055,292278994) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if year is invalid.
+     */
+    public long set(long instant, int year) {
+        FieldUtils.verifyValueBounds
+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());
+        return iChronology.setYear(instant, year);
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public boolean isLeap(long instant) {
+        return iChronology.isLeapYear(get(instant));
+    }
+
+    public int getLeapAmount(long instant) {
+        if (iChronology.isLeapYear(get(instant))) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
+    }
+
+    public int getMinimumValue() {
+        return iChronology.getMinYear();
+    }
+
+    public int getMaximumValue() {
+        return iChronology.getMaxYear();
+    }
+
+    public long roundFloor(long instant) {
+        return iChronology.getYearMillis(get(instant));
+    }
+
+    public long roundCeiling(long instant) {
+        int year = get(instant);
+        long yearStartMillis = iChronology.getYearMillis(year);
+        if (instant != yearStartMillis) {
+            // Bump up to start of next year.
+            instant = iChronology.getYearMillis(year + 1);
+        }
+        return instant;
+    }
+
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.year();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
new file mode 100644
index 0000000..2a84c4f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -0,0 +1,172 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.field.DecoratedDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the year of era component of time.
+ * 
+ * @author Brian S O'Neill
+ */
+final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = -5961050944769862059L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    GJYearOfEraDateTimeField(DateTimeField yearField, AbstractGJChronology chronology) {
+        super(yearField, "yearOfEra");
+        iChronology = chronology;
+    }
+
+    /**
+     * Get the year of era component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the year of era extracted from the input.
+     */
+    public int get(long instant) {
+        int year = getWrappedField().get(instant);
+        if (year <= 0) {
+            year = 1 - year;
+        }
+        return year;
+    }
+
+    /**
+     * Add the specified year to the specified time instant.
+     * The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int years) {
+        return getWrappedField().add(instant, years);
+    }
+
+    public long add(long instant, long years) {
+        return getWrappedField().add(instant, years);
+    }
+
+    /**
+     * Add to the year component of the specified time instant
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param years  the years to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int years) {
+        return getWrappedField().addWrapped(instant, years);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Set the year component of the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param year  the year (0,292278994) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if year is invalid.
+     */
+    public long set(long instant, int year) {
+        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());
+        if (iChronology.getYear(instant) <= 0) {
+            year = 1 - year;
+        }
+        return super.set(instant, year);
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return getWrappedField().getMaximumValue();
+    }
+
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.yearOfEra();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
new file mode 100644
index 0000000..d7654d6
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -0,0 +1,267 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ * 
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ */
+public final class GregorianChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -861407383323710522L;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    /** Singleton instance of a UTC GregorianChronology */
+    private static final GregorianChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static GregorianChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static GregorianChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static GregorianChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        GregorianChronology chrono;
+        synchronized (cCache) {
+            GregorianChronology[] chronos = (GregorianChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new GregorianChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new GregorianChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+        }
+    }
+
+    boolean isLeapYear(int year) {
+        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Calculate relative to 2000 as that is on a 400 year boundary
+        // and that makes the sum easier
+        int relativeYear = year - 2000;
+        // Initial value is just temporary.
+        int leapYears = relativeYear / 100;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers. When the expression is written as
+            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),
+            // it works for both positive and negative values, except this optimization
+            // eliminates two divisions.
+            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);
+        } else {
+            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);
+            // For post 2000 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+        
+        // Previous line was reduced from this to eliminate a multiplication.
+        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;
+        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y
+        
+        return millis + MILLIS_1970_TO_2000;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return -292275054;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        return 292278993;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1970L * MILLIS_PER_YEAR;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
new file mode 100644
index 0000000..2eb9af3
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -0,0 +1,241 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ * ISOChronology provides access to the individual date time fields 
+ * for the ISO8601 defined chronological calendar system. When ISO 
+ * does not define a field, but it can be determined (such as AM/PM)
+ * it is included.
+ * <p>
+ * ISOChronology is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class ISOChronology extends AssembledChronology {
+    
+    static final long serialVersionUID = -6212696554273812441L;
+
+    /** Singleton instance of a UTC ISOChronology */
+    private static final ISOChronology INSTANCE_UTC =
+        new ISOChronology(GregorianChronology.getInstanceUTC());
+        
+    private static final int FAST_CACHE_SIZE = 64;
+
+    /** Fast cache of zone to chronology */
+    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];
+
+    /** Cache of zone to chronology */
+    private static final Map cCache = new HashMap();
+    static {
+        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);
+    }
+
+    /**
+     * Gets an instance of the ISOChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static ISOChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the ISOChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static ISOChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault());
+    }
+
+    /**
+     * Gets an instance of the ISOChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static ISOChronology getInstance(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);
+        ISOChronology chrono = cFastCache[index];
+        if (chrono != null && chrono.getDateTimeZone() == zone) {
+            return chrono;
+        }
+        synchronized (cCache) {
+            chrono = (ISOChronology) cCache.get(zone);
+            if (chrono == null) {
+                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));
+                cCache.put(zone, chrono);
+            }
+        }
+        cFastCache[index] = chrono;
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    private ISOChronology(Chronology base) {
+        super(base, null);
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        String str = "ISOChronology";
+        DateTimeZone zone = getDateTimeZone();
+        if (zone != null) {
+            str = str + '[' + zone.getID() + ']';
+        }
+        return str;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase().getDateTimeZone() == DateTimeZone.UTC) {
+            // Use zero based century and year of century.
+            fields.centuryOfEra = new DividedDateTimeField
+                (fields.yearOfEra, "centuryOfEra", "centuries", 100);
+            fields.yearOfCentury = new RemainderDateTimeField
+                ((DividedDateTimeField)fields.centuryOfEra, "yearOfCentury");
+
+            fields.centuries = fields.centuryOfEra.getDurationField();
+        }
+    }
+
+    /**
+     * Serialize ISOChronology instances using a small stub. This reduces the
+     * serialized size, and deserialized instances come from the cache.
+     */
+    private Object writeReplace() {
+        return new Stub(getDateTimeZone());
+    }
+
+    private static final class Stub implements Serializable {
+        static final long serialVersionUID = -6212696554273812441L;
+
+        private transient DateTimeZone iZone;
+
+        Stub(DateTimeZone zone) {
+            iZone = zone;
+        }
+
+        private Object readResolve() {
+            return ISOChronology.getInstance(iZone);
+        }
+
+        private void writeObject(ObjectOutputStream out) throws IOException {
+            out.writeObject(iZone);
+        }
+
+        private void readObject(ObjectInputStream in)
+            throws IOException, ClassNotFoundException
+        {
+            iZone = (DateTimeZone)in.readObject();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
deleted file mode 100644
index ff7da04..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DurationField;
-
-/**
- * Abstract datetime field class that defines its own DurationField, which
- * delegates back into this ImpreciseDateTimeField.
- * <p>
- * This DateTimeField is useful for defining DateTimeFields that are composed
- * of imprecise durations. If both duration fields are precise, then a
- * {@link PreciseDateTimeField} should be used instead.
- * <p>
- * When defining imprecise DateTimeFields where a matching DurationField is
- * already available, just extend AbstractDateTimeField directly so as not to
- * create redundant DurationField instances.
- * <p>
- * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @see PreciseDateTimeField
- */
-public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {
-
-    static final long serialVersionUID = 7190739608550251860L;
-
-    final long iUnitMillis;
-    private final DurationField iDurationField;
-
-    /**
-     * Constructor.
-     * 
-     * @param name  short, descriptive name, like "monthOfYear".
-     * @param durationName  short, descriptive name, like "months".
-     * @param unitMillis  the average duration unit milliseconds
-     */
-    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {
-        super(name);
-        iUnitMillis = unitMillis;
-        iDurationField = new LinkedDurationField(durationName);
-    }
-
-    public abstract int get(long instant);
-
-    public abstract long set(long instant, int value);
-
-    public abstract long add(long instant, int value);
-
-    public abstract long add(long instant, long value);
-
-    /**
-     * Computes the difference between two instants, as measured in the units
-     * of this field. Any fractional units are dropped from the result. Calling
-     * getDifference reverses the effect of calling add. In the following code:
-     *
-     * <pre>
-     * long instant = ...
-     * int v = ...
-     * int age = getDifference(add(instant, v), instant);
-     * </pre>
-     *
-     * The value 'age' is the same as the value 'v'.
-     * <p>
-     * The default implementation call getDifferenceAsLong and converts the
-     * return value to an int.
-     *
-     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract from
-     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract off the minuend
-     * @return the difference in the units of this field
-     */
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
-    }
-
-    /**
-     * Computes the difference between two instants, as measured in the units
-     * of this field. Any fractional units are dropped from the result. Calling
-     * getDifference reverses the effect of calling add. In the following code:
-     *
-     * <pre>
-     * long instant = ...
-     * long v = ...
-     * long age = getDifferenceAsLong(add(instant, v), instant);
-     * </pre>
-     *
-     * The value 'age' is the same as the value 'v'.
-     * <p>
-     * The default implementation performs a guess-and-check algorithm using
-     * getDurationField().getUnitMillis() and the add() method. Subclasses are
-     * encouraged to provide a more efficient implementation.
-     *
-     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract from
-     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
-     * subtract off the minuend
-     * @return the difference in the units of this field
-     */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        if (minuendInstant < subtrahendInstant) {
-            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);
-        }
-        
-        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;
-        if (add(subtrahendInstant, difference) < minuendInstant) {
-            do {
-                difference++;
-            } while (add(subtrahendInstant, difference) <= minuendInstant);
-            difference--;
-        } else if (add(subtrahendInstant, difference) > minuendInstant) {
-            do {
-                difference--;
-            } while (add(subtrahendInstant, difference) > minuendInstant);
-        }
-        return difference;
-    }
-
-    public final DurationField getDurationField() {
-        return iDurationField;
-    }
-
-    public abstract DurationField getRangeDurationField();
-
-    public abstract long roundFloor(long instant);
-
-    protected final long getDurationUnitMillis() {
-        return iUnitMillis;
-    }
-
-    private final class LinkedDurationField extends AbstractDurationField {
-        static final long serialVersionUID = -203813474600094134L;
-
-        LinkedDurationField(String name) {
-            super(name);
-        }
-    
-        public boolean isPrecise() {
-            return false;
-        }
-    
-        public long getUnitMillis() {
-            return iUnitMillis;
-        }
-
-        public int getValue(long duration, long instant) {
-            return ImpreciseDateTimeField.this
-                .getDifference(instant + duration, instant);
-        }
-
-        public long getValueAsLong(long duration, long instant) {
-            return ImpreciseDateTimeField.this
-                .getDifferenceAsLong(instant + duration, instant);
-        }
-        
-        public long getMillis(int value, long instant) {
-            return ImpreciseDateTimeField.this.add(instant, value) - instant;
-        }
-
-        public long getMillis(long value, long instant) {
-            return ImpreciseDateTimeField.this.add(instant, value) - instant;
-        }
-
-        public long add(long instant, int value) {
-            return ImpreciseDateTimeField.this.add(instant, value);
-        }
-        
-        public long add(long instant, long value) {
-            return ImpreciseDateTimeField.this.add(instant, value);
-        }
-        
-        public int getDifference(long minuendInstant, long subtrahendInstant) {
-            return ImpreciseDateTimeField.this
-                .getDifference(minuendInstant, subtrahendInstant);
-        }
-        
-        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-            return ImpreciseDateTimeField.this
-                .getDifferenceAsLong(minuendInstant, subtrahendInstant);
-        }
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
new file mode 100644
index 0000000..1c0fc4f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -0,0 +1,334 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.field.DelegatedDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ *
+ * @author Guy Allard
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ */
+public final class JulianChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -8731039522547897247L;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    /** Singleton instance of a UTC JulianChronology */
+    private static final JulianChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    static int adjustYearForSet(int year) {
+        if (year <= 0) {
+            if (year == 0) {
+                throw new IllegalArgumentException("Invalid year: " + year);
+            }
+            year++;
+        }
+        return year;
+    }
+
+    /**
+     * Gets an instance of the JulianChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static JulianChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static JulianChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static JulianChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        JulianChronology chrono;
+        synchronized (cCache) {
+            JulianChronology[] chronos = (JulianChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new JulianChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new JulianChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return super.getDateOnlyMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);
+    }
+
+    boolean isLeapYear(int year) {
+        return (year & 3) == 0;
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.
+        // Calculate relative to the nearest leap year and account for the
+        // difference later.
+
+        int relativeYear = year - 1968;
+        int leapYears;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers.
+            leapYears = (relativeYear + 3) >> 2;
+        } else {
+            leapYears = relativeYear >> 2;
+            // For post 1968 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+
+        // Adjust to account for difference between 1968-01-01 and 1969-12-19.
+
+        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return -292269053;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        return 292272992;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+            // Julian chronology has no year zero.
+            fields.year = new NoYearZeroField(this, fields.year);
+            fields.weekyear = new NoWeekyearZeroField(this, fields.weekyear);
+        }
+    }
+
+    static class NoYearZeroField extends DelegatedDateTimeField {
+        static final long serialVersionUID = -8869148464118507846L;
+
+        final AbstractGJChronology iChronology;
+        private transient int iMinYear;
+
+        NoYearZeroField(AbstractGJChronology chronology, DateTimeField field) {
+            super(field);
+            iChronology = chronology;
+            int min = super.getMinimumValue();
+            if (min < 0) {
+                iMinYear = min - 1;
+            } else if (min == 0) {
+                iMinYear = 1;
+            } else {
+                iMinYear = min;
+            }
+        }
+        
+        public int get(long millis) {
+            int year = super.get(millis);
+            if (year <= 0) {
+                year--;
+            }
+            return year;
+        }
+
+        public long set(long millis, int year) {
+            FieldUtils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
+            return super.set(millis, adjustYearForSet(year));
+        }
+
+        public int getMinimumValue() {
+            return iMinYear;
+        }
+
+        private Object readResolve() {
+            return iChronology.year();
+        }
+    }
+
+    static class NoWeekyearZeroField extends NoYearZeroField {
+        static final long serialVersionUID = -5013429014495501104L;
+
+        NoWeekyearZeroField(AbstractGJChronology chronology, DateTimeField field) {
+            super(chronology, field);
+        }
+        
+        private Object readResolve() {
+            return iChronology.weekyear();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
index c075cbd..1a8e1b2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -56,6 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.field.LenientDateTimeField;
 
 /**
  * Wraps another chronology, ensuring all the fields are lenient.
@@ -66,304 +67,90 @@
  * @see LenientDateTimeField
  * @see StrictChronology
  */
-public class LenientChronology extends DelegatedChronology {
+public final class LenientChronology extends AssembledChronology {
 
     static final long serialVersionUID = -3148237568046877177L;
 
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
+    /**
+     * Create a LenientChronology for any chronology.
+     *
+     * @param base the chronology to wrap
+     * @throws IllegalArgumentException if chronology is null
+     */
+    public static LenientChronology getInstance(Chronology base) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
+        }
+        return new LenientChronology(base);
+    }
 
     private transient Chronology iWithUTC;
 
     /**
      * Create a LenientChronology for any chronology.
      *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
+     * @param base the chronology to wrap
      */
-    public LenientChronology(Chronology chrono) {
-        super(chrono);
+    private LenientChronology(Chronology base) {
+        super(base, null);
     }
 
     public Chronology withUTC() {
         if (iWithUTC == null) {
-            iWithUTC = new LenientChronology(getWrappedChronology().withUTC());
+            if (getDateTimeZone() == DateTimeZone.UTC) {
+                iWithUTC = this;
+            } else {
+                iWithUTC = LenientChronology.getInstance(getBase().withUTC());
+            }
         }
         return iWithUTC;
     }
 
     public Chronology withDateTimeZone(DateTimeZone zone) {
-        return new LenientChronology(getWrappedChronology().withDateTimeZone(zone));
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DateTimeField millisOfSecond() {
-        if (iMillisOfDayField == null) {
-            iMillisOfSecondField = LenientDateTimeField.getInstance(super.millisOfSecond());
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
         }
-        return iMillisOfSecondField;
+        if (zone == DateTimeZone.UTC) {
+            return withUTC();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return LenientChronology.getInstance(getBase().withDateTimeZone(zone));
     }
 
-    public DateTimeField millisOfDay() {
-        if (iMillisOfDayField == null) {
-            iMillisOfDayField = LenientDateTimeField.getInstance(super.millisOfDay());
-        }
-        return iMillisOfDayField;
+    protected void assemble(Fields fields) {
+        fields.year = convertField(fields.year);
+        fields.yearOfEra = convertField(fields.yearOfEra);
+        fields.yearOfCentury = convertField(fields.yearOfCentury);
+        fields.centuryOfEra = convertField(fields.centuryOfEra);
+        fields.era = convertField(fields.era);
+        fields.dayOfWeek = convertField(fields.dayOfWeek);
+        fields.dayOfMonth = convertField(fields.dayOfMonth);
+        fields.dayOfYear = convertField(fields.dayOfYear);
+        fields.monthOfYear = convertField(fields.monthOfYear);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);
+        fields.weekyear = convertField(fields.weekyear);
+
+        fields.millisOfSecond = convertField(fields.millisOfSecond);
+        fields.millisOfDay = convertField(fields.millisOfDay);
+        fields.secondOfMinute = convertField(fields.secondOfMinute);
+        fields.secondOfDay = convertField(fields.secondOfDay);
+        fields.minuteOfHour = convertField(fields.minuteOfHour);
+        fields.minuteOfDay = convertField(fields.minuteOfDay);
+        fields.hourOfDay = convertField(fields.hourOfDay);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);
     }
 
-    // Seconds
-    //------------------------------------------------------------
-
-    public DateTimeField secondOfMinute() {
-        if (iSecondOfMinuteField == null) {
-            iSecondOfMinuteField = LenientDateTimeField.getInstance(super.secondOfMinute());
-        }
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        if (iSecondOfDayField == null) {
-            iSecondOfDayField = LenientDateTimeField.getInstance(super.secondOfDay());
-        }
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DateTimeField minuteOfHour() {
-        if (iMinuteOfHourField == null) {
-            iMinuteOfHourField = LenientDateTimeField.getInstance(super.minuteOfHour());
-        }
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        if (iMinuteOfDayField == null) {
-            iMinuteOfDayField = LenientDateTimeField.getInstance(super.minuteOfDay());
-        }
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DateTimeField hourOfDay() {
-        if (iHourOfDayField == null) {
-            iHourOfDayField = LenientDateTimeField.getInstance(super.hourOfDay());
-        }
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        if (iClockhourOfDayField == null) {
-            iClockhourOfDayField = LenientDateTimeField.getInstance(super.clockhourOfDay());
-        }
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        if (iHourOfHalfdayField == null) {
-            iHourOfHalfdayField = LenientDateTimeField.getInstance(super.hourOfHalfday());
-        }
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        if (iClockhourOfHalfdayField == null) {
-            iClockhourOfHalfdayField =
-                LenientDateTimeField.getInstance(super.clockhourOfHalfday());
-        }
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        if (iHalfdayOfDayField == null) {
-            iHalfdayOfDayField = LenientDateTimeField.getInstance(super.halfdayOfDay());
-        }
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DateTimeField dayOfWeek() {
-        if (iDayOfWeekField == null) {
-            iDayOfWeekField = LenientDateTimeField.getInstance(super.dayOfWeek());
-        }
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        if (iDayOfMonthField == null) {
-            iDayOfMonthField = LenientDateTimeField.getInstance(super.dayOfMonth());
-        }
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        if (iDayOfYearField == null) {
-            iDayOfYearField = LenientDateTimeField.getInstance(super.dayOfYear());
-        }
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DateTimeField weekOfWeekyear() {
-        if (iWeekOfWeekyearField == null) {
-            iWeekOfWeekyearField = LenientDateTimeField.getInstance(super.weekOfWeekyear());
-        }
-        return iWeekOfWeekyearField;
-    }
-
-    public DateTimeField weekyear() {
-        if (iWeekyearField == null) {
-            iWeekyearField = LenientDateTimeField.getInstance(super.weekyear());
-        }
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DateTimeField monthOfYear() {
-        if (iMonthOfYearField == null) {
-            iMonthOfYearField = LenientDateTimeField.getInstance(super.monthOfYear());
-        }
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DateTimeField year() {
-        if (iYearField == null) {
-            iYearField = LenientDateTimeField.getInstance(super.year());
-        }
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        if (iYearOfEraField == null) {
-            iYearOfEraField = LenientDateTimeField.getInstance(super.yearOfEra());
-        }
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            iYearOfCenturyField = LenientDateTimeField.getInstance(super.yearOfCentury());
-        }
-        return iYearOfCenturyField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            iCenturyOfEraField = LenientDateTimeField.getInstance(super.centuryOfEra());
-        }
-        return iCenturyOfEraField;
-    }
-
-    public DateTimeField era() {
-        if (iEraField == null) {
-            iEraField = LenientDateTimeField.getInstance(super.era());
-        }
-        return iEraField;
+    private static final DateTimeField convertField(DateTimeField field) {
+        return LenientDateTimeField.getInstance(field);
     }
 
     public String toString() {
-        return "LenientChronology[" + getWrappedChronology().toString() + ']';
+        return "LenientChronology[" + getBase().toString() + ']';
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
deleted file mode 100644
index 00f8de9..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-
-/**
- * Converts a strict DateTimeField into a lenient one. By being lenient, the
- * set method accepts out of bounds values, performing an addition instead.
- * <p>
- * LenientDateTimeField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- * @see StrictDateTimeField
- */
-public class LenientDateTimeField extends DelegatedDateTimeField {
-
-    static final long serialVersionUID = 8714085824173290599L;
-
-    /**
-     * Returns a lenient version of the given field. If it is already lenient,
-     * then it is returned as-is. Otherwise, a new LenientDateTimeField is
-     * returned.
-     */
-    public static DateTimeField getInstance(DateTimeField field) {
-        if (field == null) {
-            return null;
-        }
-        if (field instanceof StrictDateTimeField) {
-            field = ((StrictDateTimeField)field).getWrappedField();
-        }
-        if (field.isLenient()) {
-            return field;
-        }
-        return new LenientDateTimeField(field);
-    }
-
-    protected LenientDateTimeField(DateTimeField field) {
-        super(field);
-    }
-
-    public final boolean isLenient() {
-        return true;
-    }
-
-    /**
-     * Set values which may be out of bounds. If the value is out of bounds,
-     * the instant is first set to the minimum allowed value, and then the
-     * difference is added.
-     */
-    public long set(long instant, int value) {
-        int min = getMinimumValue(instant);
-        if (value >= min && value < getMaximumValue(instant)) {
-            return super.set(instant, value);
-        }
-        return add(super.set(instant, min), value - min);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index 41fdf2d..1963cc4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -67,6 +67,8 @@
 import org.joda.time.DurationField;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableDateTime;
+import org.joda.time.field.DecoratedDateTimeField;
+import org.joda.time.field.DecoratedDurationField;
 import org.joda.time.format.DateTimePrinter;
 import org.joda.time.format.ISODateTimeFormat;
 
@@ -85,54 +87,45 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public class LimitChronology extends Chronology {
+public final class LimitChronology extends AssembledChronology {
 
     static final long serialVersionUID = 7670866536893052522L;
 
-    private final Chronology iChronology;
+    /**
+     * Wraps another chronology, with datetime limits. When withUTC or
+     * withDateTimeZone is called, the returned LimitChronology instance has
+     * the same limits, except they are time zone adjusted.
+     *
+     * @param base base chronology to wrap
+     * @param lowerLimit  inclusive lower limit, or null if none
+     * @param upperLimit  exclusive upper limit, or null if none
+     * @throws IllegalArgumentException if chronology is null or limits are invalid
+     */
+    public static LimitChronology getInstance(Chronology base,
+                                              ReadableDateTime lowerLimit,
+                                              ReadableDateTime upperLimit) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
+        }
+
+        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();
+        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();
+
+        if (lowerLimit != null && upperLimit != null) {
+            if (!lowerLimit.isBefore(upperLimit)) {
+                throw new IllegalArgumentException
+                    ("The lower limit must be come before than the upper limit");
+            }
+        }
+
+        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);
+    }
 
     final DateTime iLowerLimit;
     final DateTime iUpperLimit;
 
     private transient LimitChronology iWithUTC;
 
-    private transient DurationField iErasField;
-    private transient DurationField iCenturiesField;
-    private transient DurationField iYearsField;
-    private transient DurationField iMonthsField;
-    private transient DurationField iWeekyearsField;
-    private transient DurationField iWeeksField;
-    private transient DurationField iDaysField;
-
-    private transient DurationField iHoursField;
-    private transient DurationField iMinutesField;
-    private transient DurationField iSecondsField;
-    private transient DurationField iMillisField;
-
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
-
     /**
      * Wraps another chronology, with datetime limits. When withUTC or
      * withDateTimeZone is called, the returned LimitChronology instance has
@@ -140,104 +133,13 @@
      *
      * @param lowerLimit  inclusive lower limit, or null if none
      * @param upperLimit  exclusive upper limit, or null if none
-     * @throws IllegalArgumentException if chronology is null or limits are invalid
      */
-    public LimitChronology(Chronology chrono,
-                           ReadableDateTime lowerLimit, ReadableDateTime upperLimit) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("Must supply a chronology");
-        }
-
-        iChronology = chrono;
-
-        iLowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();
-        iUpperLimit = upperLimit == null ? null : upperLimit.toDateTime();
-
-        if (iLowerLimit != null && iUpperLimit != null) {
-            if (!iLowerLimit.isBefore(iUpperLimit)) {
-                throw new IllegalArgumentException
-                    ("The lower limit must be come before than the upper limit");
-            }
-        }
-
-        setFields();
-    }
-
-    private void setFields() {
-        Chronology c = iChronology;
-
-        // Keep a local cache of converted fields so as not to create redundant
-        // objects.
-        HashMap converted = new HashMap();
-
-        // Convert duration fields...
-
-        iErasField = convertField(c.eras(), converted);
-        iCenturiesField = convertField(c.centuries(), converted);
-        iYearsField = convertField(c.years(), converted);
-        iMonthsField = convertField(c.months(), converted);
-        iWeekyearsField = convertField(c.weekyears(), converted);
-        iWeeksField = convertField(c.weeks(), converted);
-        iDaysField = convertField(c.days(), converted);
-
-        iHoursField = convertField(c.hours(), converted);
-        iMinutesField = convertField(c.minutes(), converted);
-        iSecondsField = convertField(c.seconds(), converted);
-        iMillisField = convertField(c.millis(), converted);
-
-        // Convert datetime fields...
-
-        iYearField = convertField(c.year(), converted);
-        iYearOfEraField = convertField(c.yearOfEra(), converted);
-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
-        iEraField = convertField(c.era(), converted);
-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
-        iDayOfYearField = convertField(c.dayOfYear(), converted);
-        iMonthOfYearField = convertField(c.monthOfYear(), converted);
-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
-        iWeekyearField = convertField(c.weekyear(), converted);
-
-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
-        iMillisOfDayField = convertField(c.millisOfDay(), converted);
-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
-        iSecondOfDayField = convertField(c.secondOfDay(), converted);
-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
-        iHourOfDayField = convertField(c.hourOfDay(), converted);
-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
-    }
-
-    private DurationField convertField(DurationField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DurationField)converted.get(field);
-        }
-        LimitDurationField limitField = new LimitDurationField(field);
-        converted.put(field, limitField);
-        return limitField;
-    }
-
-    private DateTimeField convertField(DateTimeField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DateTimeField)converted.get(field);
-        }
-        LimitDateTimeField limitField =
-            new LimitDateTimeField(field,
-                                   convertField(field.getDurationField(), converted),
-                                   convertField(field.getRangeDurationField(), converted),
-                                   convertField(field.getLeapDurationField(), converted));
-        converted.put(field, limitField);
-        return limitField;
+    private LimitChronology(Chronology base,
+                            DateTime lowerLimit, DateTime upperLimit) {
+        super(base, null);
+        // These can be set after assembly.
+        iLowerLimit = lowerLimit;
+        iUpperLimit = upperLimit;
     }
 
     /**
@@ -254,20 +156,11 @@
      * 
      * @return upper limit
      */
-    public DateTime getUpperBound() {
+    public DateTime getUpperLimit() {
         return iUpperLimit;
     }
 
     /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
-    /**
      * If this LimitChronology is already UTC, then this is
      * returned. Otherwise, a new instance is returned, with the limits
      * adjusted to the new time zone.
@@ -307,8 +200,8 @@
             upperLimit = mdt.toDateTime();
         }
         
-        LimitChronology chrono = new LimitChronology
-            (iChronology.withDateTimeZone(zone), lowerLimit, upperLimit);
+        LimitChronology chrono = getInstance
+            (getBase().withDateTimeZone(zone), lowerLimit, upperLimit);
 
         if (zone == DateTimeZone.UTC) {
             iWithUTC = chrono;
@@ -317,13 +210,9 @@
         return chrono;
     }
 
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
     public long getDateOnlyMillis(long instant) {
         checkLimits(instant, null);
-        instant = iChronology.getDateOnlyMillis(instant);
+        instant = getBase().getDateOnlyMillis(instant);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -331,14 +220,14 @@
     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        long instant = getBase().getDateOnlyMillis(year, monthOfYear, dayOfMonth);
         checkLimits(instant, "resulting");
         return instant;
     }
 
     public long getTimeOnlyMillis(long instant) {
         checkLimits(instant, null);
-        instant = iChronology.getTimeOnlyMillis(instant);
+        instant = getBase().getTimeOnlyMillis(instant);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -347,7 +236,7 @@
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getTimeOnlyMillis
+        long instant = getBase().getTimeOnlyMillis
             (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
@@ -357,7 +246,7 @@
                                   int millisOfDay)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -368,7 +257,7 @@
         throws IllegalArgumentException
     {
         checkLimits(instant, null);
-        instant = iChronology.getDateTimeMillis
+        instant = getBase().getDateTimeMillis
             (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
@@ -379,178 +268,90 @@
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateTimeMillis
+        long instant = getBase().getDateTimeMillis
             (year, monthOfYear, dayOfMonth,
              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
     }
 
-    // Milliseconds
-    //------------------------------------------------------------
+    protected void assemble(Fields fields) {
+        // Keep a local cache of converted fields so as not to create redundant
+        // objects.
+        HashMap converted = new HashMap();
 
-    public DurationField millis() {
-        return iMillisField;
+        // Convert duration fields...
+
+        fields.eras = convertField(fields.eras, converted);
+        fields.centuries = convertField(fields.centuries, converted);
+        fields.years = convertField(fields.years, converted);
+        fields.months = convertField(fields.months, converted);
+        fields.weekyears = convertField(fields.weekyears, converted);
+        fields.weeks = convertField(fields.weeks, converted);
+        fields.days = convertField(fields.days, converted);
+
+        fields.hours = convertField(fields.hours, converted);
+        fields.minutes = convertField(fields.minutes, converted);
+        fields.seconds = convertField(fields.seconds, converted);
+        fields.millis = convertField(fields.millis, converted);
+
+        // Convert datetime fields...
+
+        fields.year = convertField(fields.year, converted);
+        fields.yearOfEra = convertField(fields.yearOfEra, converted);
+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);
+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);
+        fields.era = convertField(fields.era, converted);
+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);
+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);
+        fields.dayOfYear = convertField(fields.dayOfYear, converted);
+        fields.monthOfYear = convertField(fields.monthOfYear, converted);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);
+        fields.weekyear = convertField(fields.weekyear, converted);
+
+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);
+        fields.millisOfDay = convertField(fields.millisOfDay, converted);
+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);
+        fields.secondOfDay = convertField(fields.secondOfDay, converted);
+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);
+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);
+        fields.hourOfDay = convertField(fields.hourOfDay, converted);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);
     }
 
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
+    private DurationField convertField(DurationField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DurationField)converted.get(field);
+        }
+        LimitDurationField limitField = new LimitDurationField(field);
+        converted.put(field, limitField);
+        return limitField;
     }
 
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DurationField years() {
-        return iYearsField;
-    }
-
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
-
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
-    }
-
-    public DurationField eras() {
-        return iErasField;
-    }
-
-    public DateTimeField era() {
-        return iEraField;
+    private DateTimeField convertField(DateTimeField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DateTimeField)converted.get(field);
+        }
+        LimitDateTimeField limitField =
+            new LimitDateTimeField(field,
+                                   convertField(field.getDurationField(), converted),
+                                   convertField(field.getRangeDurationField(), converted),
+                                   convertField(field.getLeapDurationField(), converted));
+        converted.put(field, limitField);
+        return limitField;
     }
 
     public String toString() {
-        return iChronology.toString();
-    }
-
-    private void readObject(ObjectInputStream in)
-        throws IOException, ClassNotFoundException
-    {
-        in.defaultReadObject();
-        setFields();
+        return getBase().toString();
     }
 
     void checkLimits(long instant, String desc) {
@@ -587,18 +388,18 @@
             }
             buf.append(" instant is ");
 
-            DateTimePrinter p = ISODateTimeFormat.getInstance(getWrappedChronology()).dateTime();
+            DateTimePrinter p = ISODateTimeFormat.getInstance(getBase()).dateTime();
 
             if (iIsLow) {
                 buf.append("below the supported minimum of ");
-                p.printTo(buf, iLowerLimit);
+                p.printTo(buf, getLowerLimit());
             } else {
                 buf.append("above the supported maximum of ");
-                p.printTo(buf, iUpperLimit);
+                p.printTo(buf, getUpperLimit());
             }
             
             buf.append(" (");
-            buf.append(getWrappedChronology());
+            buf.append(getBase());
             buf.append(')');
 
             return buf.toString();
diff --git a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
deleted file mode 100644
index 438c219..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import org.joda.time.DurationField;
-
-/**
- * Duration field class representing a field with a fixed unit length of one
- * millisecond.
- * <p>
- * MillisDurationField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- */
-public final class MillisDurationField implements DurationField, Serializable {
-    
-    static final long serialVersionUID = 2656707858124633367L;
-
-    public static final DurationField INSTANCE = new MillisDurationField();
-
-    private MillisDurationField() {
-    }
-    
-    //------------------------------------------------------------------------
-    public String getName() {
-        return "millis";
-    }
-
-    /**
-     * @return true always
-     */
-    public boolean isSupported() {
-        return true;
-    }
-
-    /**
-     * This field is precise.
-     * 
-     * @return true always
-     */
-    public final boolean isPrecise() {
-        return true;
-    }
-    
-    /**
-     * Returns the amount of milliseconds per unit value of this field.
-     *
-     * @return one always
-     */
-    public final long getUnitMillis() {
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    public int getValue(long duration) {
-        return Utils.safeToInt(duration);
-    }
-
-    public long getValueAsLong(long duration) {
-        return duration;
-    }
-
-    public int getValue(long duration, long instant) {
-        return Utils.safeToInt(duration);
-    }
-
-    public long getValueAsLong(long duration, long instant) {
-        return duration;
-    }
-
-    public long getMillis(int value) {
-        return value;
-    }
-
-    public long getMillis(long value) {
-        return value;
-    }
-
-    public long getMillis(int value, long instant) {
-        return value;
-    }
-
-    public long getMillis(long value, long instant) {
-        return value;
-    }
-
-    public long add(long instant, int value) {
-        return instant + value;
-    }
-
-    public long add(long instant, long value) {
-        return instant + value;
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(minuendInstant - subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return minuendInstant - subtrahendInstant;
-    }
-
-    //------------------------------------------------------------------------
-    public int compareTo(Object durationField) {
-        DurationField otherField = (DurationField) durationField;
-        long otherMillis = otherField.getUnitMillis();
-        long thisMillis = getUnitMillis();
-        // cannot do (thisMillis - otherMillis) as can overflow
-        if (thisMillis == otherMillis) {
-            return 0;
-        }
-        if (thisMillis < otherMillis) {
-            return -1;
-        } else {
-            return 1;
-        }
-    }
-
-    /**
-     * Get a suitable debug string.
-     * 
-     * @return debug string
-     */
-    public String toString() {
-        return "DurationField[" + getName() + ']';
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return INSTANCE;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
deleted file mode 100644
index f083bb9..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * Wraps another field such that zero values are replaced with one more than
- * it's maximum. This is particularly useful for implementing an clockhourOfDay
- * field, where the midnight value of 0 is replaced with 24.
- * <p>
- * NonZeroDateTimeField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- * @since 1.0
- */
-public final class NonZeroDateTimeField extends DecoratedDateTimeField {
-
-    static final long serialVersionUID = 961749798233026866L;
-
-    /**
-     * @param name  short, descriptive name, like "clockhourOfDay".
-     * @throws IllegalArgumentException if wrapped field's minimum value is not zero
-     */
-    public NonZeroDateTimeField(DateTimeField field, String name) {
-        super(field, name);
-        if (field.getMinimumValue() != 0) {
-            throw new IllegalArgumentException("Wrapped field's minumum value must be zero");
-        }
-    }
-
-    public int get(long instant) {
-        int value = getWrappedField().get(instant);
-        if (value == 0) {
-            value = getMaximumValue();
-        }
-        return value;
-    }
-
-    public long add(long instant, int value) {
-        return getWrappedField().add(instant, value);
-    }
-
-    public long add(long instant, long value) {
-        return getWrappedField().add(instant, value);
-    }
-
-    public long addWrapped(long instant, int value) {
-        return getWrappedField().addWrapped(instant, value);
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    public long set(long instant, int value) {
-        int max = getMaximumValue();
-        Utils.verifyValueBounds(this, value, 1, max);
-        if (value == max) {
-            value = 0;
-        }
-        return getWrappedField().set(instant, value);
-    }
-
-    public boolean isLeap(long instant) {
-        return getWrappedField().isLeap(instant);
-    }
-
-    public int getLeapAmount(long instant) {
-        return getWrappedField().getLeapAmount(instant);
-    }
-
-    public DurationField getLeapDurationField() {
-        return getWrappedField().getLeapDurationField();
-    }
-
-    /**
-     * Always returns 1.
-     * 
-     * @return the minimum value of 1
-     */
-    public int getMinimumValue() {
-        return 1;
-    }
-
-    /**
-     * Always returns 1.
-     * 
-     * @return the minimum value of 1
-     */
-    public int getMinimumValue(long instant) {
-        return 1;
-    }
-
-    /**
-     * Get the maximum value for the field, which is one more than the wrapped
-     * field's maximum value.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return getWrappedField().getMaximumValue() + 1;
-    }
-
-    /**
-     * Get the maximum value for the field, which is one more than the wrapped
-     * field's maximum value.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue(long instant) {
-        return getWrappedField().getMaximumValue(instant) + 1;
-    }
-
-    public long roundFloor(long instant) {
-        return getWrappedField().roundFloor(instant);
-    }
-
-    public long roundCeiling(long instant) {
-        return getWrappedField().roundCeiling(instant);
-    }
-
-    public long roundHalfFloor(long instant) {
-        return getWrappedField().roundHalfFloor(instant);
-    }
-
-    public long roundHalfCeiling(long instant) {
-        return getWrappedField().roundHalfCeiling(instant);
-    }
-
-    public long roundHalfEven(long instant) {
-        return getWrappedField().roundHalfEven(instant);
-    }
-
-    public long remainder(long instant) {
-        return getWrappedField().remainder(instant);
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
deleted file mode 100644
index adf65d4..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * Generic offset adjusting datetime field.
- * <p>
- * OffsetDateTimeField is thread-safe and immutable.
- * 
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class OffsetDateTimeField extends DecoratedDateTimeField {
-    static final long serialVersionUID = 3145790132623583142L;
-
-    private final int iOffset;
-
-    private final int iMin;
-    private final int iMax;
-
-    /**
-     * Constructor
-     * 
-     * @param field  the field to wrap, like "year()".
-     * @param name  short, descriptive name, like "offsetYear".
-     * @param offset  offset to add to field values
-     * @throws IllegalArgumentException if offset is zero
-     */
-    public OffsetDateTimeField(DateTimeField field, String name, int offset) {
-        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);
-    }
-
-    /**
-     * Constructor
-     * 
-     * @param field  the field to wrap, like "year()".
-     * @param name  short, descriptive name, like "offsetYear".
-     * @param offset  offset to add to field values
-     * @param minValue  minimum allowed value
-     * @param maxValue  maximum allowed value
-     * @throws IllegalArgumentException if offset is zero
-     */
-    public OffsetDateTimeField(DateTimeField field, String name, int offset,
-                               int minValue, int maxValue) {
-        super(field, name);
-                
-        if (offset == 0) {
-            throw new IllegalArgumentException("The offset cannot be zero");
-        }
-
-        iOffset = offset;
-
-        if (minValue < (field.getMinimumValue() + offset)) {
-            iMin = field.getMinimumValue() + offset;
-        } else {
-            iMin = minValue;
-        }
-        if (maxValue > (field.getMaximumValue() + offset)) {
-            iMax = field.getMaximumValue() + offset;
-        } else {
-            iMax = maxValue;
-        }
-    }
-
-    /**
-     * Get the amount of offset units from the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the amount of units extracted from the input.
-     */
-    public int get(long instant) {
-        return super.get(instant) + iOffset;
-    }
-
-    /**
-     * Add the specified amount of offset units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int amount) {
-        instant = super.add(instant, amount);
-        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
-        return instant;
-    }
-
-    /**
-     * Add the specified amount of offset units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, long amount) {
-        instant = super.add(instant, amount);
-        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
-        return instant;
-    }
-
-    /**
-     * Add to the offset component of the specified time instant,
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
-    }
-
-    /**
-     * Set the specified amount of offset units to the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param value  value of units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, iMin, iMax);
-        return super.set(instant, value - iOffset);
-    }
-
-    public boolean isLeap(long instant) {
-        return getWrappedField().isLeap(instant);
-    }
-
-    public int getLeapAmount(long instant) {
-        return getWrappedField().getLeapAmount(instant);
-    }
-
-    public DurationField getLeapDurationField() {
-        return getWrappedField().getLeapDurationField();
-    }
-
-    /**
-     * Get the minimum value for the field.
-     * 
-     * @return the minimum value
-     */
-    public int getMinimumValue() {
-        return iMin;
-    }
-
-    /**
-     * Get the maximum value for the field.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iMax;
-    }
-    
-    public long roundFloor(long instant) {
-        return getWrappedField().roundFloor(instant);
-    }
-
-    public long roundCeiling(long instant) {
-        return getWrappedField().roundCeiling(instant);
-    }
-
-    public long roundHalfFloor(long instant) {
-        return getWrappedField().roundHalfFloor(instant);
-    }
-
-    public long roundHalfCeiling(long instant) {
-        return getWrappedField().roundHalfCeiling(instant);
-    }
-
-    public long roundHalfEven(long instant) {
-        return getWrappedField().roundHalfEven(instant);
-    }
-
-    public long remainder(long instant) {
-        return getWrappedField().remainder(instant);
-    }
-
-    /**
-     * Returns the offset added to the field values.
-     * 
-     * @return the offset
-     */
-    public int getOffset() {
-        return iOffset;
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
deleted file mode 100644
index 0b4c4c0..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DurationField;
-
-/**
- * Precise datetime field, composed of two precise duration fields.
- * <p>
- * This DateTimeField is useful for defining DateTimeFields that are composed
- * of precise durations, like time of day fields. If either duration field is
- * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.
- * <p>
- * PreciseDateTimeField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- * @see ImpreciseDateTimeField
- */
-public class PreciseDateTimeField extends PreciseDurationDateTimeField {
-
-    static final long serialVersionUID = -5586801265774496376L;
-
-    /** The maximum range in the correct units */
-    private final int iRange;
-
-    private final DurationField iRangeField;
-
-    /**
-     * Constructor.
-     * 
-     * @param name  short, descriptive name, like "secondOfMinute".
-     * @param unit  precise unit duration, like "seconds()".
-     * @param range precise range duration, preferably a multiple of the unit,
-     * like "minutes()".
-     * @throws IllegalArgumentException if either duration field is imprecise
-     * @throws IllegalArgumentException if unit milliseconds is less than one
-     * or effective value range is less than two.
-     */
-    public PreciseDateTimeField(String name,
-                                DurationField unit, DurationField range) {
-        super(name, unit);
-
-        if (!range.isPrecise()) {
-            throw new IllegalArgumentException("Range duration field must be precise");
-        }
-
-        long rangeMillis = range.getUnitMillis();
-        iRange = (int)(rangeMillis / getUnitMillis());
-        if (iRange < 2) {
-            throw new IllegalArgumentException("The effective range must be at least 2");
-        }
-
-        iRangeField = range;
-    }
-
-    /**
-     * Get the amount of fractional units from the specified time instant.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @return the amount of fractional units extracted from the input.
-     */
-    public int get(long instant) {
-        if (instant >= 0) {
-            return (int) ((instant / getUnitMillis()) % iRange);
-        } else {
-            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);
-        }
-    }
-
-    /**
-     * Add to the component of the specified time instant, wrapping around
-     * within that component if necessary.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int amount) {
-        int thisValue = get(instant);
-        int wrappedValue = Utils.getWrappedValue
-            (thisValue, amount, getMinimumValue(), getMaximumValue());
-        // copy code from set() to avoid repeat call to get()
-        return instant + (wrappedValue - thisValue) * getUnitMillis();
-    }
-
-    /**
-     * Set the specified amount of units to the specified time instant.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param value  value of units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
-        return instant + (value - get(instant)) * iUnitMillis;
-    }
-
-    /**
-     * Returns the range duration of this field. For example, if this field
-     * represents "minute of hour", then the range duration field is an hours.
-     *
-     * @return the range duration of this field, or null if field has no range
-     */
-    public DurationField getRangeDurationField() {
-        return iRangeField;
-    }
-
-    /**
-     * Get the maximum value for the field.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iRange - 1;
-    }
-    
-    /**
-     * Returns the range of the field in the field's units.
-     * <p>
-     * For example, 60 for seconds per minute. The field is allowed values
-     * from 0 to range - 1.
-     * 
-     * @return unit range
-     */
-    public int getRange() {
-        return iRange;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
deleted file mode 100644
index aa9cbe4..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DurationField;
-
-/**
- * Precise datetime field, which has a precise unit duration field.
- * <p>
- * PreciseDurationDateTimeField is thread-safe and immutable, and its
- * subclasses must be as well.
- *
- * @author Brian S O'Neill
- */
-public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {
-
-    static final long serialVersionUID = 5004523158306266035L;
-
-    /** The fractional unit in millis */
-    final long iUnitMillis;
-
-    private final DurationField iUnitField;
-
-    /**
-     * Constructor.
-     * 
-     * @param name  short, descriptive name, like "dayOfMonth".
-     * @param unit  precise unit duration, like "days()".
-     * @throws IllegalArgumentException if duration field is imprecise
-     * @throws IllegalArgumentException if unit milliseconds is less than one
-     */
-    public PreciseDurationDateTimeField(String name, DurationField unit) {
-        super(name);
-
-        if (!unit.isPrecise()) {
-            throw new IllegalArgumentException("Unit duration field must be precise");
-        }
-
-        iUnitMillis = unit.getUnitMillis();
-        if (iUnitMillis < 1) {
-            throw new IllegalArgumentException("The unit milliseconds must be at least 1");
-        }
-
-        iUnitField = unit;
-    }
-
-    /**
-     * Returns false by default.
-     */
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Add the specified amount of units to the specified time instant. The
-     * amount added may be negative.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int amount) {
-        return instant + amount * iUnitMillis;
-    }
-
-    /**
-     * Add the specified amount of units to the specified time instant. The
-     * amount added may be negative.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param amount  the amount of units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, long amount) {
-        return instant + amount * iUnitMillis;
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return (minuendInstant - subtrahendInstant) / iUnitMillis;
-    }
-
-    /**
-     * Set the specified amount of units to the specified time instant.
-     * 
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
-     * @param value  value of units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, getMinimumValue(),
-                                getMaximumValueForSet(instant, value));
-        return instant + (value - get(instant)) * iUnitMillis;
-    }
-
-    /**
-     * This method assumes that this field is properly rounded on
-     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
-     * method as follows:
-     * <pre>
-     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
-     * </pre>
-     */
-    public long roundFloor(long instant) {
-        if (instant >= 0) {
-            return instant - instant % iUnitMillis;
-        } else {
-            instant += 1;
-            return instant - instant % iUnitMillis - iUnitMillis;
-        }
-    }
-
-    /**
-     * This method assumes that this field is properly rounded on
-     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
-     * method as follows:
-     * <pre>
-     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
-     * </pre>
-     */
-    public long roundCeiling(long instant) {
-        if (instant >= 0) {
-            instant -= 1;
-            return instant - instant % iUnitMillis + iUnitMillis;
-        } else {
-            return instant - instant % iUnitMillis;
-        }
-    }
-
-    /**
-     * This method assumes that this field is properly rounded on
-     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
-     * method as follows:
-     * <pre>
-     * return super.remainder(instant + ALIGNMENT_MILLIS);
-     * </pre>
-     */
-    public long remainder(long instant) {
-        if (instant >= 0) {
-            return instant % iUnitMillis;
-        } else {
-            return (instant + 1) % iUnitMillis + iUnitMillis - 1;
-        }
-    }
-
-    /**
-     * Returns the duration per unit value of this field. For example, if this
-     * field represents "minute of hour", then the duration field is minutes.
-     *
-     * @return the duration of this field, or UnsupportedDurationField if field
-     * has no duration
-     */
-    public DurationField getDurationField() {
-        return iUnitField;
-    }
-
-    /**
-     * Get the minimum value for the field.
-     * 
-     * @return the minimum value
-     */
-    public int getMinimumValue() {
-        return 0;
-    }
-
-    public final long getUnitMillis() {
-        return iUnitMillis;
-    }
-
-    /**
-     * Called by the set method to get the maximum allowed value. By default,
-     * returns getMaximumValue(instant). Override to provide a faster
-     * implementation.
-     */
-    protected int getMaximumValueForSet(long instant, int value) {
-        return getMaximumValue(instant);
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
deleted file mode 100644
index 8935379..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-/**
- * Duration field class representing a field with a fixed unit length.
- * <p>
- * PreciseDurationField is thread-safe and immutable.
- * 
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class PreciseDurationField extends AbstractDurationField {
-    
-    static final long serialVersionUID = -8346152187724495365L;
-
-    /** The size of the unit */
-    private final long iUnitMillis;
-
-    /**
-     * Constructor.
-     * 
-     * @param name  the name of the field, like "seconds"
-     * @param unitMillis  the unit milliseconds
-     */    
-    public PreciseDurationField(String name, long unitMillis) {
-        super(name);
-        iUnitMillis = unitMillis;
-    }
-    
-    //------------------------------------------------------------------------
-    /**
-     * This field is precise.
-     * 
-     * @return true always
-     */
-    public final boolean isPrecise() {
-        return true;
-    }
-    
-    /**
-     * Returns the amount of milliseconds per unit value of this field.
-     *
-     * @return the unit size of this field, in milliseconds
-     */
-    public final long getUnitMillis() {
-        return iUnitMillis;
-    }
-
-    //------------------------------------------------------------------------
-    /**
-     * Get the value of this field from the milliseconds.
-     * 
-     * @param duration  the milliseconds to query, which may be negative
-     * @param instant  ignored
-     * @return the value of the field, in the units of the field, which may be
-     * negative
-     */
-    public long getValueAsLong(long duration, long instant) {
-        return duration / iUnitMillis;
-    }
-
-    /**
-     * Get the millisecond duration of this field from its value.
-     * 
-     * @param value  the value of the field, which may be negative
-     * @param instant  ignored
-     * @return the milliseconds that the field represents, which may be
-     * negative
-     */
-    public long getMillis(int value, long instant) {
-        return value * iUnitMillis;
-    }
-
-    /**
-     * Get the millisecond duration of this field from its value.
-     * 
-     * @param value  the value of the field, which may be negative
-     * @param instant  ignored
-     * @return the milliseconds that the field represents, which may be
-     * negative
-     */
-    public long getMillis(long value, long instant) {
-        return value * iUnitMillis;
-    }
-
-    public long add(long instant, int value) {
-        return instant + value * iUnitMillis;
-    }
-
-    public long add(long instant, long value) {
-        return instant + value * iUnitMillis;
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return (minuendInstant - subtrahendInstant) / iUnitMillis;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
deleted file mode 100644
index 62d499b..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * Counterpart remainder datetime field to {@link DividedDateTimeField}. The
- * field's unit duration is unchanged, but the range duration is scaled
- * accordingly.
- * <p>
- * RemainderDateTimeField is thread-safe and immutable.
- *
- * @see DividedDateTimeField
- *
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class RemainderDateTimeField extends DecoratedDateTimeField {
-
-    static final long serialVersionUID = 5708241235177666790L;
-
-    // Shared with DividedDateTimeField.
-    final int iDivisor;
-    final DurationField iRangeField;
-
-    /**
-     * Constructor.
-     * 
-     * @param field  the field to wrap, like "year()".
-     * @param name  short, descriptive name, like "yearOfCentury".
-     * @param rangeName  short, descriptive name, like "centuries".
-     * @param divisor  divisor, such as 100 years in a century
-     * @throws IllegalArgumentException if divisor is less than two
-     */
-    public RemainderDateTimeField(DateTimeField field,
-                                  String name, String rangeName, int divisor) {
-        super(field, name);
-
-        if (divisor < 2) {
-            throw new IllegalArgumentException("The divisor must be at least 2");
-        }
-
-        DurationField rangeField = field.getDurationField();
-        if (rangeField == null) {
-            iRangeField = null;
-        } else {
-            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);
-        }
-
-        iDivisor = divisor;
-    }
-
-    /**
-     * Construct a RemainderDateTimeField that compliments the given
-     * DividedDateTimeField.
-     *
-     * @param dividedField  complimentary divided field, like "century()".
-     * @param name  short, descriptive name, like "yearOfCentury".
-     */
-    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {
-        super(dividedField.getWrappedField(), name);
-        iDivisor = dividedField.iDivisor;
-        iRangeField = dividedField.iDurationField;
-    }
-
-    /**
-     * Get the remainder from the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the remainder extracted from the input.
-     */
-    public int get(long instant) {
-        int value = getWrappedField().get(instant);
-        if (value >= 0) {
-            return value % iDivisor;
-        } else {
-            return (iDivisor - 1) + ((value + 1) % iDivisor);
-        }
-    }
-
-    /**
-     * Add the specified amount to the specified time instant, wrapping around
-     * within the remainder range if necessary. The amount added may be
-     * negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
-    }
-
-    /**
-     * Set the specified amount of remainder units to the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param value  value of remainder units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, 0, iDivisor - 1);
-        int divided = getDivided(getWrappedField().get(instant));
-        return getWrappedField().set(instant, divided * iDivisor + value);
-    }
-
-    /**
-     * Returns a scaled version of the wrapped field's unit duration field.
-     */
-    public DurationField getRangeDurationField() {
-        return iRangeField;
-    }
-
-    /**
-     * Get the minimum value for the field, which is always zero.
-     * 
-     * @return the minimum value of zero.
-     */
-    public int getMinimumValue() {
-        return 0;
-    }
-
-    /**
-     * Get the maximum value for the field, which is always one less than the
-     * divisor.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iDivisor - 1;
-    }
-
-    public long roundFloor(long instant) {
-        return getWrappedField().roundFloor(instant);
-    }
-
-    public long roundCeiling(long instant) {
-        return getWrappedField().roundCeiling(instant);
-    }
-
-    public long roundHalfFloor(long instant) {
-        return getWrappedField().roundHalfFloor(instant);
-    }
-
-    public long roundHalfCeiling(long instant) {
-        return getWrappedField().roundHalfCeiling(instant);
-    }
-
-    public long roundHalfEven(long instant) {
-        return getWrappedField().roundHalfEven(instant);
-    }
-
-    public long remainder(long instant) {
-        return getWrappedField().remainder(instant);
-    }
-
-    /**
-     * Returns the divisor applied, in the field's units.
-     * 
-     * @return the divisor
-     */
-    public int getDivisor() {
-        return iDivisor;
-    }
-
-    private int getDivided(int value) {
-        if (value >= 0) {
-            return value / iDivisor;
-        } else {
-            return ((value + 1) / iDivisor) - 1;
-        }
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
deleted file mode 100644
index fc9f362..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DurationField;
-
-/**
- * Scales a DurationField such that it's unit millis becomes larger in
- * magnitude.
- * <p>
- * ScaledDurationField is thread-safe and immutable.
- *
- * @see PreciseDurationField
- *
- * @author Brian S O'Neill
- */
-public class ScaledDurationField extends DecoratedDurationField {
-
-    static final long serialVersionUID = -3205227092378684157L;
-
-    private final int iScalar;
-
-    /**
-     * Constructor
-     * 
-     * @param field  the field to wrap, like "year()".
-     * @param name  short, descriptive name, like "centuries".
-     * @param scalar  scalar, such as 100 years in a century
-     * @throws IllegalArgumentException if scalar is zero or one.
-     */
-    public ScaledDurationField(DurationField field, String name, int scalar) {
-        super(field, name);
-        if (scalar == 0 || scalar == 1) {
-            throw new IllegalArgumentException("The scalar must not be 0 or 1");
-        }
-        iScalar = scalar;
-    }
-
-    public int getValue(long duration) {
-        return getWrappedField().getValue(duration) / iScalar;
-    }
-
-    public long getValueAsLong(long duration) {
-        return getWrappedField().getValueAsLong(duration) / iScalar;
-    }
-
-    public int getValue(long duration, long instant) {
-        return getWrappedField().getValue(duration, instant) / iScalar;
-    }
-
-    public long getValueAsLong(long duration, long instant) {
-        return getWrappedField().getValueAsLong(duration, instant) / iScalar;
-    }
-
-    public long getMillis(int value) {
-        return getWrappedField().getMillis(value * iScalar);
-    }
-
-    public long getMillis(long value) {
-        return getWrappedField().getMillis(value * iScalar);
-    }
-
-    public long getMillis(int value, long instant) {
-        return getWrappedField().getMillis(value * iScalar, instant);
-    }
-
-    public long getMillis(long value, long instant) {
-        return getWrappedField().getMillis(value * iScalar, instant);
-    }
-
-    public long add(long instant, int value) {
-        return getWrappedField().add(instant, value * iScalar);
-    }
-
-    public long add(long instant, long value) {
-        return getWrappedField().add(instant, value * iScalar);
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;
-    }
-
-    public long getUnitMillis() {
-        return getWrappedField().getUnitMillis() * iScalar;
-    }
-
-    /**
-     * Returns the scalar applied, in the field's units.
-     * 
-     * @return the scalar
-     */
-    public int getScalar() {
-        return iScalar;
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
index 3eb0e51..9ed16c7 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -56,6 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.field.StrictDateTimeField;
 
 /**
  * Wraps another chronology, ensuring all the fields are strict.
@@ -66,304 +67,90 @@
  * @see StrictDateTimeField
  * @see LenientChronology
  */
-public class StrictChronology extends DelegatedChronology {
+public final class StrictChronology extends AssembledChronology {
 
     static final long serialVersionUID = 6633006628097111960L;
 
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
+    /**
+     * Create a StrictChronology for any chronology.
+     *
+     * @param base the chronology to wrap
+     * @throws IllegalArgumentException if chronology is null
+     */
+    public static StrictChronology getInstance(Chronology base) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
+        }
+        return new StrictChronology(base);
+    }
 
     private transient Chronology iWithUTC;
 
     /**
      * Create a StrictChronology for any chronology.
      *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
+     * @param base the chronology to wrap
      */
-    public StrictChronology(Chronology chrono) {
-        super(chrono);
+    private StrictChronology(Chronology base) {
+        super(base, null);
     }
 
     public Chronology withUTC() {
         if (iWithUTC == null) {
-            iWithUTC = new StrictChronology(getWrappedChronology().withUTC());
+            if (getDateTimeZone() == DateTimeZone.UTC) {
+                iWithUTC = this;
+            } else {
+                iWithUTC = StrictChronology.getInstance(getBase().withUTC());
+            }
         }
         return iWithUTC;
     }
 
     public Chronology withDateTimeZone(DateTimeZone zone) {
-        return new StrictChronology(getWrappedChronology().withDateTimeZone(zone));
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DateTimeField millisOfSecond() {
-        if (iMillisOfDayField == null) {
-            iMillisOfSecondField = StrictDateTimeField.getInstance(super.millisOfSecond());
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
         }
-        return iMillisOfSecondField;
+        if (zone == DateTimeZone.UTC) {
+            return withUTC();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return StrictChronology.getInstance(getBase().withDateTimeZone(zone));
     }
 
-    public DateTimeField millisOfDay() {
-        if (iMillisOfDayField == null) {
-            iMillisOfDayField = StrictDateTimeField.getInstance(super.millisOfDay());
-        }
-        return iMillisOfDayField;
+    protected void assemble(Fields fields) {
+        fields.year = convertField(fields.year);
+        fields.yearOfEra = convertField(fields.yearOfEra);
+        fields.yearOfCentury = convertField(fields.yearOfCentury);
+        fields.centuryOfEra = convertField(fields.centuryOfEra);
+        fields.era = convertField(fields.era);
+        fields.dayOfWeek = convertField(fields.dayOfWeek);
+        fields.dayOfMonth = convertField(fields.dayOfMonth);
+        fields.dayOfYear = convertField(fields.dayOfYear);
+        fields.monthOfYear = convertField(fields.monthOfYear);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);
+        fields.weekyear = convertField(fields.weekyear);
+
+        fields.millisOfSecond = convertField(fields.millisOfSecond);
+        fields.millisOfDay = convertField(fields.millisOfDay);
+        fields.secondOfMinute = convertField(fields.secondOfMinute);
+        fields.secondOfDay = convertField(fields.secondOfDay);
+        fields.minuteOfHour = convertField(fields.minuteOfHour);
+        fields.minuteOfDay = convertField(fields.minuteOfDay);
+        fields.hourOfDay = convertField(fields.hourOfDay);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);
     }
 
-    // Seconds
-    //------------------------------------------------------------
-
-    public DateTimeField secondOfMinute() {
-        if (iSecondOfMinuteField == null) {
-            iSecondOfMinuteField = StrictDateTimeField.getInstance(super.secondOfMinute());
-        }
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        if (iSecondOfDayField == null) {
-            iSecondOfDayField = StrictDateTimeField.getInstance(super.secondOfDay());
-        }
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DateTimeField minuteOfHour() {
-        if (iMinuteOfHourField == null) {
-            iMinuteOfHourField = StrictDateTimeField.getInstance(super.minuteOfHour());
-        }
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        if (iMinuteOfDayField == null) {
-            iMinuteOfDayField = StrictDateTimeField.getInstance(super.minuteOfDay());
-        }
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DateTimeField hourOfDay() {
-        if (iHourOfDayField == null) {
-            iHourOfDayField = StrictDateTimeField.getInstance(super.hourOfDay());
-        }
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        if (iClockhourOfDayField == null) {
-            iClockhourOfDayField = StrictDateTimeField.getInstance(super.clockhourOfDay());
-        }
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        if (iHourOfHalfdayField == null) {
-            iHourOfHalfdayField = StrictDateTimeField.getInstance(super.hourOfHalfday());
-        }
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        if (iClockhourOfHalfdayField == null) {
-            iClockhourOfHalfdayField =
-                StrictDateTimeField.getInstance(super.clockhourOfHalfday());
-        }
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        if (iHalfdayOfDayField == null) {
-            iHalfdayOfDayField = StrictDateTimeField.getInstance(super.halfdayOfDay());
-        }
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DateTimeField dayOfWeek() {
-        if (iDayOfWeekField == null) {
-            iDayOfWeekField = StrictDateTimeField.getInstance(super.dayOfWeek());
-        }
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        if (iDayOfMonthField == null) {
-            iDayOfMonthField = StrictDateTimeField.getInstance(super.dayOfMonth());
-        }
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        if (iDayOfYearField == null) {
-            iDayOfYearField = StrictDateTimeField.getInstance(super.dayOfYear());
-        }
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DateTimeField weekOfWeekyear() {
-        if (iWeekOfWeekyearField == null) {
-            iWeekOfWeekyearField = StrictDateTimeField.getInstance(super.weekOfWeekyear());
-        }
-        return iWeekOfWeekyearField;
-    }
-
-    public DateTimeField weekyear() {
-        if (iWeekyearField == null) {
-            iWeekyearField = StrictDateTimeField.getInstance(super.weekyear());
-        }
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DateTimeField monthOfYear() {
-        if (iMonthOfYearField == null) {
-            iMonthOfYearField = StrictDateTimeField.getInstance(super.monthOfYear());
-        }
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DateTimeField year() {
-        if (iYearField == null) {
-            iYearField = StrictDateTimeField.getInstance(super.year());
-        }
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        if (iYearOfEraField == null) {
-            iYearOfEraField = StrictDateTimeField.getInstance(super.yearOfEra());
-        }
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            iYearOfCenturyField = StrictDateTimeField.getInstance(super.yearOfCentury());
-        }
-        return iYearOfCenturyField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            iCenturyOfEraField = StrictDateTimeField.getInstance(super.centuryOfEra());
-        }
-        return iCenturyOfEraField;
-    }
-
-    public DateTimeField era() {
-        if (iEraField == null) {
-            iEraField = StrictDateTimeField.getInstance(super.era());
-        }
-        return iEraField;
+    private static final DateTimeField convertField(DateTimeField field) {
+        return StrictDateTimeField.getInstance(field);
     }
 
     public String toString() {
-        return "StrictChronology[" + getWrappedChronology().toString() + ']';
+        return "StrictChronology[" + getBase().toString() + ']';
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
deleted file mode 100644
index 1047b0b..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-
-/**
- * Converts a lenient DateTimeField into a strict one. By being strict, the set
- * throws an IllegalArgumentException if the value is out of bounds.
- * <p>
- * StrictDateTimeField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- * @see LenientDateTimeField
- */
-public class StrictDateTimeField extends DelegatedDateTimeField {
-
-    static final long serialVersionUID = 3154803964207950910L;
-
-    /**
-     * Returns a strict version of the given field. If it is already strict,
-     * then it is returned as-is. Otherwise, a new StrictDateTimeField is
-     * returned.
-     */
-    public static DateTimeField getInstance(DateTimeField field) {
-        if (field == null) {
-            return null;
-        }
-        if (field instanceof LenientDateTimeField) {
-            field = ((LenientDateTimeField)field).getWrappedField();
-        }
-        if (!field.isLenient()) {
-            return field;
-        }
-        return new StrictDateTimeField(field);
-    }
-
-    protected StrictDateTimeField(DateTimeField field) {
-        super(field);
-    }
-
-    public final boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Does a bounds check before setting the value.
-     *
-     * @throws IllegalArgumentException if the value is invalid
-     */
-    public long set(long instant, int value) {
-        Utils.verifyValueBounds
-            (this, value, getMinimumValue(instant), getMaximumValue(instant));
-        return super.set(instant, value);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
deleted file mode 100644
index b270d81..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Locale;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * A placeholder implementation to use when a datetime field is not supported.
- * <p>
- * UnsupportedDateTimeField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- */
-public final class UnsupportedDateTimeField implements DateTimeField, Serializable {
-
-    static final long serialVersionUID = -1934618396111902255L;
-
-    /**
-     * Instance with the name "unsupported".
-     */
-    public static final UnsupportedDateTimeField INSTANCE =
-        getInstance("unsupported", UnsupportedDurationField.INSTANCE);
-
-    private static HashMap cCache;
-
-    /**
-     * @throws IllegalArgumentException if durationField is null
-     */
-    public static synchronized UnsupportedDateTimeField getInstance
-        (String name, DurationField durationField) {
-
-        UnsupportedDateTimeField field;
-        if (cCache == null) {
-            cCache = new HashMap(7);
-            field = null;
-        } else {
-            field = (UnsupportedDateTimeField)cCache.get(name);
-            if (field != null && field.getDurationField() != durationField) {
-                field = null;
-            }
-        }
-        if (field == null) {
-            field = new UnsupportedDateTimeField(name, durationField);
-            cCache.put(name, field);
-        }
-        return field;
-    }
-
-    private final String iName;
-    private final DurationField iDurationField;
-
-    private UnsupportedDateTimeField(String name, DurationField durationField) {
-        if (durationField == null) {
-            throw new IllegalArgumentException();
-        }
-        iName = name;
-        iDurationField = durationField;
-    }
-
-    // Design note: Simple accessors return a suitable value, but methods
-    // intended to perform calculations throw an UnsupportedOperationException.
-
-    public String getName() {
-        return iName;
-    }
-
-    /**
-     * This field is not supported.
-     *
-     * @return false always
-     */
-    public boolean isSupported() {
-        return false;
-    }
-
-    /**
-     * This field is not lenient.
-     *
-     * @return false always
-     */
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int get(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public String getAsText(long instant, Locale locale) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public String getAsText(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public String getAsShortText(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Delegates to the duration field.
-     *
-     * @throws UnsupportedOperationException if the duration is unsupported
-     */
-    public long add(long instant, int value) {
-        return getDurationField().add(instant, value);
-    }
-
-    /**
-     * Delegates to the duration field.
-     *
-     * @throws UnsupportedOperationException if the duration is unsupported
-     */
-    public long add(long instant, long value) {
-        return getDurationField().add(instant, value);
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long addWrapped(long instant, int value) {
-        throw unsupported();
-    }
-
-    /**
-     * Delegates to the duration field.
-     *
-     * @throws UnsupportedOperationException if the duration is unsupported
-     */
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Delegates to the duration field.
-     *
-     * @throws UnsupportedOperationException if the duration is unsupported
-     */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long set(long instant, int value) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long set(long instant, String text, Locale locale) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long set(long instant, String text) {
-        throw unsupported();
-    }
-
-    /**
-     * Even though this DateTimeField is unsupported, the duration field might
-     * be supported.
-     *
-     * @return a possibly supported DurationField
-     */
-    public DurationField getDurationField() {
-        return iDurationField;
-    }
-
-    /**
-     * Always returns null.
-     *
-     * @return null always
-     */
-    public DurationField getRangeDurationField() {
-        return null;
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public boolean isLeap(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getLeapAmount(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always returns null.
-     *
-     * @return null always
-     */
-    public DurationField getLeapDurationField() {
-        return null;
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMinimumValue() {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMinimumValue(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMaximumValue() {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMaximumValue(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMaximumTextLength(Locale locale) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long roundFloor(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long roundCeiling(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long roundHalfFloor(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long roundHalfCeiling(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long roundHalfEven(long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long remainder(long instant) {
-        throw unsupported();
-    }
-
-    //------------------------------------------------------------------------
-    /**
-     * Get a suitable debug string.
-     * 
-     * @return debug string
-     */
-    public String toString() {
-        return "UnsupportedDateTimeField";
-    }
-
-    /**
-     * Ensure proper singleton serialization
-     */
-    private Object readResolve() {
-        return getInstance(iName, iDurationField);
-    }
-
-    private UnsupportedOperationException unsupported() {
-        return new UnsupportedOperationException(iName + " field is unsupported");
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
deleted file mode 100644
index 0ba2378..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import org.joda.time.DurationField;
-
-/**
- * A placeholder implementation to use when a duration field is not supported.
- * <p>
- * UnsupportedDurationField is thread-safe and immutable.
- *
- * @author Brian S O'Neill
- */
-public final class UnsupportedDurationField implements DurationField, Serializable {
-
-    static final long serialVersionUID = -6390301302770925357L;
-
-    /**
-     * Instance with the name "unsupported".
-     */
-    public static final UnsupportedDurationField INSTANCE = getInstance("unsupported");
-
-    private static HashMap cCache;
-
-    public static synchronized UnsupportedDurationField getInstance(String name) {
-        UnsupportedDurationField field;
-        if (cCache == null) {
-            cCache = new HashMap(7);
-            field = null;
-        } else {
-            field = (UnsupportedDurationField)cCache.get(name);
-        }
-        if (field == null) {
-            field = new UnsupportedDurationField(name);
-            cCache.put(name, field);
-        }
-        return field;
-    }
-
-    private final String iName;
-
-    private UnsupportedDurationField(String name) {
-        iName = name;
-    }
-
-    // Design note: Simple Accessors return a suitable value, but methods
-    // intended to perform calculations throw an UnsupportedOperationException.
-
-    public String getName() {
-        return iName;
-    }
-
-    /**
-     * This field is not supported.
-     *
-     * @return false always
-     */
-    public boolean isSupported() {
-        return false;
-    }
-
-    /**
-     * This field is precise.
-     * 
-     * @return true always
-     */
-    public boolean isPrecise() {
-        return true;
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getValue(long duration) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getValueAsLong(long duration) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getValue(long duration, long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getValueAsLong(long duration, long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getMillis(int value) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getMillis(long value) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getMillis(int value, long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getMillis(long value, long instant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long add(long instant, int value) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long add(long instant, long value) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always throws UnsupportedOperationException
-     *
-     * @throws UnsupportedOperationException
-     */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        throw unsupported();
-    }
-
-    /**
-     * Always returns zero.
-     *
-     * @return zero always
-     */
-    public long getUnitMillis() {
-        return 0;
-    }
-
-    /**
-     * Always returns zero, indicating that sort order is not relevent.
-     *
-     * @return zero always
-     */
-    public int compareTo(Object durationField) {
-        return 0;
-    }
-
-    //------------------------------------------------------------------------
-    /**
-     * Get a suitable debug string.
-     * 
-     * @return debug string
-     */
-    public String toString() {
-        return "UnsupportedDurationField";
-    }
-
-    /**
-     * Ensure proper singleton serialization
-     */
-    private Object readResolve() {
-        return getInstance(iName);
-    }
-
-    private UnsupportedOperationException unsupported() {
-        return new UnsupportedOperationException(iName + " field is unsupported");
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/Utils.java b/JodaTime/src/java/org/joda/time/chrono/Utils.java
deleted file mode 100644
index 63b9660..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/Utils.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-
-/**
- * General utilities that don't fit elsewhere.
- * <p>
- * Utils is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @since 1.0
- */
-public class Utils {
-
-    /**
-     * Restricted constructor.
-     */
-    private Utils() {
-        super();
-    }
-    
-    //------------------------------------------------------------------------
-    /**
-     * Add two values throwing an exception if overflow occurs.
-     * 
-     * @param val1  the first value
-     * @param val2  the second value
-     * @return the new total
-     */
-    public static long safeAdd(long val1, long val2) {
-        long total = val1 + val2;
-        if (val1 > 0 && val2 > 0 && total < 0) {
-            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
-        }
-        if (val1 < 0 && val2 < 0 && total > 0) {
-            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
-        }
-        return total;
-    }
-    
-    /**
-     * Multiply two values throwing an exception if overflow occurs.
-     * 
-     * @param val1  the first value
-     * @param val2  the second value
-     * @return the new total
-     */
-    public static long safeMultiply(long val1, long val2) {
-        if (val1 == 0  || val2 == 0) {
-            return 0L;
-        }
-        long total = val1 * val2;
-        if (total / val2 != val1) {
-            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" * " + val2);
-        }
-        return total;
-    }
-    
-    /**
-     * Casts to an int throwing an exception if overflow occurs.
-     * 
-     * @param value  the value
-     * @return the value as an int
-     */
-    public static int safeToInt(long value) {
-        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
-            return (int) value;
-        }
-        throw new ArithmeticException("Value cannot fit in an int: " + value);
-    }
-
-    /**
-     * Verify that input values are within specified bounds.
-     * 
-     * @param value  the value to check
-     * @param lowerBound  the lower bound allowed for value
-     * @param upperBound  the upper bound allowed for value
-     * @throws IllegalArgumentException if value is not in the specified bounds
-     */
-    public static void verifyValueBounds(DateTimeField field, 
-                                         int value, int lowerBound, int upperBound) {
-        if ((value < lowerBound) || (value > upperBound)) {
-            throw new IllegalArgumentException(
-                "Value "
-                    + value
-                    + " for "
-                    + field.getName()
-                    + " must be in the range ["
-                    + lowerBound
-                    + ','
-                    + upperBound
-                    + ']');
-        }
-    }
-
-    /**
-     * Verify that input values are within specified bounds.
-     * 
-     * @param value  the value to check
-     * @param lowerBound  the lower bound allowed for value
-     * @param upperBound  the upper bound allowed for value
-     * @throws IllegalArgumentException if value is not in the specified bounds
-     */
-    public static void verifyValueBounds(String fieldName,
-                                         int value, int lowerBound, int upperBound) {
-        if ((value < lowerBound) || (value > upperBound)) {
-            throw new IllegalArgumentException(
-                "Value "
-                    + value
-                    + " for "
-                    + fieldName
-                    + " must be in the range ["
-                    + lowerBound
-                    + ','
-                    + upperBound
-                    + ']');
-        }
-    }
-
-    /**
-     * Utility method used by addWrapped implementations to ensure the new
-     * value lies within the field's legal value range.
-     *
-     * @param currentValue the current value of the data, which may lie outside
-     * the wrapped value range
-     * @param wrapValue  the value to add to current value before
-     *  wrapping.  This may be negative.
-     * @param minValue the wrap range minimum value.
-     * @param maxValue the wrap range maximum value.  This must be
-     *  greater than minValue (checked by the method).
-     * @return the wrapped value
-     * @throws IllegalArgumentException if minValue is greater
-     *  than or equal to maxValue
-     */
-    public static int getWrappedValue(int currentValue, int wrapValue,
-                                      int minValue, int maxValue) {
-        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
-    }
-
-    /**
-     * Utility method that ensures the given value lies within the field's
-     * legal value range.
-     * 
-     * @param value  the value to fit into the wrapped value range
-     * @param minValue the wrap range minimum value.
-     * @param maxValue the wrap range maximum value.  This must be
-     *  greater than minValue (checked by the method).
-     * @return the wrapped value
-     * @throws IllegalArgumentException if minValue is greater
-     *  than or equal to maxValue
-     */
-    public static int getWrappedValue(int value, int minValue, int maxValue) {
-        if (minValue >= maxValue) {
-            throw new IllegalArgumentException("MIN > MAX");
-        }
-
-        int wrapRange = maxValue - minValue + 1;
-        value -= minValue;
-
-        if (value >= 0) {
-            return (value % wrapRange) + minValue;
-        }
-
-        int remByRange = (-value) % wrapRange;
-
-        if (remByRange == 0) {
-            return 0 + minValue;
-        }
-        return (wrapRange - remByRange) + minValue;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 8ba2f18..1efb307 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -53,9 +53,6 @@
  */
 package org.joda.time.chrono;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-
 import java.util.HashMap;
 import java.util.Locale;
 
@@ -64,6 +61,8 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.AbstractDurationField;
 
 /**
  * Wraps another Chronology for supporting time zones.
@@ -74,7 +73,29 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public class ZonedChronology extends Chronology {
+public final class ZonedChronology extends AssembledChronology {
+
+    /**
+     * Create a ZonedChronology for any chronology, overriding any time zone it
+     * may already have.
+     *
+     * @param base base chronology to wrap
+     * @param zone the time zone
+     * @throws IllegalArgumentException if chronology or time zone is null
+     */
+    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
+        }
+        base = base.withUTC();
+        if (base == null) {
+            throw new IllegalArgumentException("UTC chronology must not be null");
+        }
+        if (zone == null) {
+            throw new IllegalArgumentException("DateTimeZone must not be null");
+        }
+        return new ZonedChronology(base, zone);
+    }
 
     static final long serialVersionUID = -1079258847191166848L;
 
@@ -84,118 +105,139 @@
         return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
     }
 
-    private final Chronology iChronology;
-    private final DateTimeZone iZone;
-
-    private transient DurationField iErasField;
-    private transient DurationField iCenturiesField;
-    private transient DurationField iYearsField;
-    private transient DurationField iMonthsField;
-    private transient DurationField iWeekyearsField;
-    private transient DurationField iWeeksField;
-    private transient DurationField iDaysField;
-
-    private transient DurationField iHoursField;
-    private transient DurationField iMinutesField;
-    private transient DurationField iSecondsField;
-    private transient DurationField iMillisField;
-
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
-
     /**
-     * Create a ZonedChronology for any chronology, overriding any time zone it
-     * may already have.
+     * Restricted constructor
      *
-     * @param chrono the chronology
+     * @param base base chronology to wrap
      * @param zone the time zone
-     * @throws IllegalArgumentException if chronology or time zone is null
      */
-    public ZonedChronology(Chronology chrono, DateTimeZone zone) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("Must supply a chronology");
-        }
-        chrono = chrono.withUTC();
-        if (chrono == null) {
-            throw new IllegalArgumentException("UTC chronology must not be null");
-        }
-        if (zone == null) {
-            throw new IllegalArgumentException("DateTimeZone must not be null");
-        }
-
-        iChronology = chrono;
-        iZone = zone;
-        setFields();
+    private ZonedChronology(Chronology base, DateTimeZone zone) {
+        super(base, zone);
     }
 
-    private void setFields() {
-        Chronology c = iChronology;
+    public DateTimeZone getDateTimeZone() {
+        return (DateTimeZone)getParam();
+    }
 
+    public Chronology withUTC() {
+        return getBase();
+    }
+
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getParam()) {
+            return this;
+        }
+        if (zone == DateTimeZone.UTC) {
+            return getBase();
+        }
+        return new ZonedChronology(getBase(), zone);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return localToUTC(getBase().getDateOnlyMillis
+                          (year, monthOfYear, dayOfMonth));
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(getBase().getTimeOnlyMillis
+                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        return localToUTC(getBase().getDateTimeMillis
+                          (year, monthOfYear, dayOfMonth, millisOfDay));
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(getBase().getDateTimeMillis
+                          (instant + getDateTimeZone().getOffset(instant),
+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(getBase().getDateTimeMillis
+                          (year, monthOfYear, dayOfMonth, 
+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    /**
+     * @param instant instant from 1970-01-01T00:00:00 local time
+     */
+    private long localToUTC(long instant) {
+        DateTimeZone zone = getDateTimeZone();
+        int offset = zone.getOffsetFromLocal(instant);
+        instant -= offset;
+        if (offset != zone.getOffset(instant)) {
+            throw new IllegalArgumentException
+                ("Illegal instant due to time zone offset transition");
+        }
+        return instant;
+    }
+
+    protected void assemble(Fields fields) {
         // Keep a local cache of converted fields so as not to create redundant
         // objects.
         HashMap converted = new HashMap();
 
         // Convert duration fields...
 
-        iErasField = convertField(c.eras(), converted);
-        iCenturiesField = convertField(c.centuries(), converted);
-        iYearsField = convertField(c.years(), converted);
-        iMonthsField = convertField(c.months(), converted);
-        iWeekyearsField = convertField(c.weekyears(), converted);
-        iWeeksField = convertField(c.weeks(), converted);
-        iDaysField = convertField(c.days(), converted);
+        fields.eras = convertField(fields.eras, converted);
+        fields.centuries = convertField(fields.centuries, converted);
+        fields.years = convertField(fields.years, converted);
+        fields.months = convertField(fields.months, converted);
+        fields.weekyears = convertField(fields.weekyears, converted);
+        fields.weeks = convertField(fields.weeks, converted);
+        fields.days = convertField(fields.days, converted);
 
-        iHoursField = convertField(c.hours(), converted);
-        iMinutesField = convertField(c.minutes(), converted);
-        iSecondsField = convertField(c.seconds(), converted);
-        iMillisField = convertField(c.millis(), converted);
+        fields.hours = convertField(fields.hours, converted);
+        fields.minutes = convertField(fields.minutes, converted);
+        fields.seconds = convertField(fields.seconds, converted);
+        fields.millis = convertField(fields.millis, converted);
 
         // Convert datetime fields...
 
-        iYearField = convertField(c.year(), converted);
-        iYearOfEraField = convertField(c.yearOfEra(), converted);
-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
-        iEraField = convertField(c.era(), converted);
-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
-        iDayOfYearField = convertField(c.dayOfYear(), converted);
-        iMonthOfYearField = convertField(c.monthOfYear(), converted);
-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
-        iWeekyearField = convertField(c.weekyear(), converted);
+        fields.year = convertField(fields.year, converted);
+        fields.yearOfEra = convertField(fields.yearOfEra, converted);
+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);
+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);
+        fields.era = convertField(fields.era, converted);
+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);
+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);
+        fields.dayOfYear = convertField(fields.dayOfYear, converted);
+        fields.monthOfYear = convertField(fields.monthOfYear, converted);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);
+        fields.weekyear = convertField(fields.weekyear, converted);
 
-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
-        iMillisOfDayField = convertField(c.millisOfDay(), converted);
-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
-        iSecondOfDayField = convertField(c.secondOfDay(), converted);
-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
-        iHourOfDayField = convertField(c.hourOfDay(), converted);
-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);
+        fields.millisOfDay = convertField(fields.millisOfDay, converted);
+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);
+        fields.secondOfDay = convertField(fields.secondOfDay, converted);
+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);
+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);
+        fields.hourOfDay = convertField(fields.hourOfDay, converted);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);
     }
 
     private DurationField convertField(DurationField field, HashMap converted) {
@@ -205,7 +247,7 @@
         if (converted.containsKey(field)) {
             return (DurationField)converted.get(field);
         }
-        ZonedDurationField zonedField = new ZonedDurationField(field, iZone);
+        ZonedDurationField zonedField = new ZonedDurationField(field, getDateTimeZone());
         converted.put(field, zonedField);
         return zonedField;
     }
@@ -218,7 +260,7 @@
             return (DateTimeField)converted.get(field);
         }
         ZonedDateTimeField zonedField =
-            new ZonedDateTimeField(field, iZone,
+            new ZonedDateTimeField(field, getDateTimeZone(),
                                    convertField(field.getDurationField(), converted),
                                    convertField(field.getRangeDurationField(), converted),
                                    convertField(field.getLeapDurationField(), converted));
@@ -226,248 +268,8 @@
         return zonedField;
     }
 
-    public DateTimeZone getDateTimeZone() {
-        return iZone;
-    }
-
-    public Chronology withUTC() {
-        return iChronology;
-    }
-
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == iZone) {
-            return this;
-        }
-        if (zone == DateTimeZone.UTC) {
-            return iChronology;
-        }
-        return new ZonedChronology(iChronology, zone);
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return localToUTC(iChronology.getDateOnlyMillis
-                          (year, monthOfYear, dayOfMonth));
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return localToUTC(iChronology.getTimeOnlyMillis
-                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return localToUTC(iChronology.getDateTimeMillis
-                          (year, monthOfYear, dayOfMonth, millisOfDay));
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return localToUTC(iChronology.getDateTimeMillis
-                          (instant + iZone.getOffset(instant),
-                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return localToUTC(iChronology.getDateTimeMillis
-                          (year, monthOfYear, dayOfMonth, 
-                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
-    }
-
-    /**
-     * @param instant instant from 1970-01-01T00:00:00 local time
-     */
-    private long localToUTC(long instant) {
-        int offset = iZone.getOffsetFromLocal(instant);
-        instant -= offset;
-        if (offset != iZone.getOffset(instant)) {
-            throw new IllegalArgumentException
-                ("Illegal instant due to time zone offset transition");
-        }
-        return instant;
-    }
-
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DurationField millis() {
-        return iMillisField;
-    }
-
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DurationField years() {
-        return iYearsField;
-    }
-
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
-
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
-    }
-
-    public DurationField eras() {
-        return iErasField;
-    }
-
-    public DateTimeField era() {
-        return iEraField;
-    }
-
     public String toString() {
-        return iChronology.toString();
-    }
-
-    private void readObject(ObjectInputStream in)
-        throws IOException, ClassNotFoundException
-    {
-        in.defaultReadObject();
-        setFields();
+        return "ZonedChronology[" + getBase() + ", " + getDateTimeZone().getID() + ']';
     }
 
     /*
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
deleted file mode 100644
index 38c9182..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.buddhist;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTime;
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.DecoratedChronology;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.LimitChronology;
-import org.joda.time.chrono.OffsetDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
-
-/**
- * <code>BuddhistChronology</code> provides access to the individual date
- * time fields for the Buddhist chronological calendar system.
- * <p>
- * The Buddhist calendar differs from the GregorianJulian calendar only 
- * in the year. This class is compatable with the BuddhistCalendar class 
- * supplied by Sun.
- * <p>
- * BuddhistChronology is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public final class BuddhistChronology extends DecoratedChronology {
-    
-    static final long serialVersionUID = -3474595157769370126L;
-
-    /**
-     * Constant value for 'Buddhist Era', equivalent to the value returned
-     * for AD/CE.
-     */
-    public static final int BE = DateTimeConstants.CE;
-
-    /** Number of years difference in calendars. */
-    private static final int BUDDHIST_OFFSET = 543;
-
-    /** Cache of zone to chronology */
-    private static final Map cCache = new HashMap();
-
-    /** UTC instance of the chronology */
-    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     * <p>
-     * The time zone of the returned instance is UTC.
-     */
-    public static BuddhistChronology getInstanceUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     */
-    public static BuddhistChronology getInstance() {
-        return getInstance(DateTimeZone.getDefault());
-    }
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     *
-     * @param zone  the time zone to use, null is default
-     */
-    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);
-        if (chrono == null) {
-            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null, false));
-            cCache.put(zone, chrono);
-        }
-        return chrono;
-    }
-
-    // Constructors and instance variables
-    //-----------------------------------------------------------------------
-    // Fields are transient because readResolve will always return a cached instance.
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iWeekyearField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    
-    /**
-     * Restricted constructor.
-     */
-    private BuddhistChronology(Chronology chronology) {
-        this(chronology, false);
-    }
-
-    /**
-     * Restricted constructor.
-     */
-    private BuddhistChronology(Chronology chronology, boolean unlimited) {
-        // BuddhistChronology is constructed in three magic steps:
-        //
-        // 1. Wrap a BuddhistChronology with proper offset, but no range limits
-        // 2. Wrap a LimitChronology, which will copy and wrap all the fields
-        // 3. Wrap a BuddhistChronology which purely delegates to LimitChronology
-        //
-        // Why is it done this way? So that the LimitChronology error message
-        // shows the limit printed using BuddhistChronology fields. This extra
-        // wrapping does not impose any additional overhead when accessing
-        // fields because LimitChronology copies them.
-        //
-        // Is this a good design? No.
-
-        super(unlimited ? chronology : limitChronology(chronology));
-
-        DateTimeField field = getWrappedChronology().year();
-        if (unlimited) {
-            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
-        }
-        iYearField = field;
-            
-        field = getWrappedChronology().weekyear();
-        if (unlimited) {
-            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
-        }
-        iWeekyearField = field;
-
-        // All other fields delegated to GJ
-    }
-
-    /**
-     * Returns a LimitChronology that wraps an unlimited BuddhistChronology
-     * that wraps the given Chronology.
-     */    
-    private static Chronology limitChronology(Chronology chrono) {
-        chrono = new BuddhistChronology(chrono, true);
-        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-        return new LimitChronology(chrono, lowerLimit, null);
-    }
-    
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return getInstance(getWrappedChronology().getDateTimeZone());
-    }
-
-    // Conversion
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the Chronology in the UTC time zone.
-     * 
-     * @return the chronology in UTC
-     */
-    public Chronology withUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Gets the Chronology in a specific time zone.
-     * 
-     * @param zone  the zone to get the chronology in, null is default
-     * @return the chronology
-     */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == getDateTimeZone()) {
-            return this;
-        }
-        return getInstance(zone);
-    }
-
-    // Millis
-    //------------------------------------------------------------
-
-    /**
-     * Get the millis duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField millis() {
-        return getWrappedChronology().millis();
-    }
-
-    /**
-     * Get the millis of second field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfSecond() {
-        return getWrappedChronology().millisOfSecond();
-    }
-
-    /**
-     * Get the millis of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfDay() {
-        return getWrappedChronology().millisOfDay();
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    /**
-     * Get the seconds duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField seconds() {
-        return getWrappedChronology().seconds();
-    }
-
-    /**
-     * Get the second of minute field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfMinute() {
-        return getWrappedChronology().secondOfMinute();
-    }
-
-    /**
-     * Get the second of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfDay() {
-        return getWrappedChronology().secondOfDay();
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    /**
-     * Get the minutes duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField minutes() {
-        return getWrappedChronology().minutes();
-    }
-
-    /**
-     * Get the minute of hour field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfHour() {
-        return getWrappedChronology().minuteOfHour();
-    }
-
-    /**
-     * Get the minute of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfDay() {
-        return getWrappedChronology().minuteOfDay();
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    /**
-     * Get the hours duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField hours() {
-        return getWrappedChronology().hours();
-    }
-
-    /**
-     * Get the hour of day (0-23) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfDay() {
-        return getWrappedChronology().hourOfDay();
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfDay() {
-        return getWrappedChronology().clockhourOfDay();
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfHalfday() {
-        return getWrappedChronology().hourOfHalfday();
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfHalfday() {
-        return getWrappedChronology().clockhourOfHalfday();
-    }
-
-    /**
-     * Get the AM(0) PM(1) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField halfdayOfDay() {
-        return getWrappedChronology().halfdayOfDay();
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    /**
-     * Get the days duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField days() {
-        return getWrappedChronology().days();
-    }
-
-    /**
-     * Get the day of week field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfWeek() {
-        return getWrappedChronology().dayOfWeek();
-    }
-
-    /**
-     * Get the day of month field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfMonth() {
-        return getWrappedChronology().dayOfMonth();
-    }
-
-    /**
-     * Get the day of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfYear() {
-        return getWrappedChronology().dayOfYear();
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    /**
-     * Get the weeks duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weeks() {
-        return getWrappedChronology().weeks();
-    }
-
-    /**
-     * Get the week of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekOfWeekyear() {
-        return getWrappedChronology().weekOfWeekyear();
-    }
-
-    /**
-     * Get the weekyears duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weekyears() {
-        return getWrappedChronology().weekyears();
-    }
-
-    /**
-     * Get the year of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    /**
-     * Get the months duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField months() {
-        return getWrappedChronology().months();
-    }
-
-    /**
-     * Get the month of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField monthOfYear() {
-        return getWrappedChronology().monthOfYear();
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    /**
-     * Get the years duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField years() {
-        return getWrappedChronology().years();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    /**
-     * Get the year of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfEra() {
-        return iYearField;
-    }
-
-    /**
-     * Get the year of century field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            DateTimeField tempField = new RemainderDateTimeField
-                ((DividedDateTimeField)centuryOfEra(), "");
-            iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
-        }
-        return iYearOfCenturyField;
-    }
-
-    /**
-     * Get the centuries duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField centuries() {
-        return getWrappedChronology().centuries();
-    }
-
-    /**
-     * Get the century of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            DateTimeField tempField = new OffsetDateTimeField(yearOfEra(), "", 99);
-            iCenturyOfEraField = new DividedDateTimeField
-                (tempField, "centuryOfEra", "centuries", 100);
-        }
-        return iCenturyOfEraField;
-    }
-
-    /**
-     * Get the era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField era() {
-        return BuddhistEraDateTimeField.INSTANCE;
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a debugging toString.
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        String str = "BuddhistChronology";
-        DateTimeZone zone = getDateTimeZone();
-        if (zone != null) {
-            str = str + '[' + zone.getID() + ']';
-        }
-        return str;
-    }
-   
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
deleted file mode 100644
index ccd869b..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.buddhist;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the buddhist era component of time.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-final class BuddhistEraDateTimeField extends AbstractDateTimeField {
-    
-    static final long serialVersionUID = -9175876774456816364L;
-
-    /**
-     * Singleton instance of BuddhistYearDateTimeField
-     */
-    static final DateTimeField INSTANCE = new BuddhistEraDateTimeField();
-
-    /**
-     * Restricted constructor
-     */
-    private BuddhistEraDateTimeField() {
-        super("era");
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return INSTANCE;
-    }
-
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Get the Era component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to query.
-     * @return the era extracted from the input.
-     */
-    public int get(long instant) {
-        return BuddhistChronology.BE;
-    }
-
-    /**
-     * Set the Era component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param era  the era (BuddhistChronology.BE) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if era is invalid.
-     */
-    public long set(long instant, int era) {
-        Utils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
-
-        return instant;
-    }
-
-    /**
-     * @see org.joda.time.DateTimeField#set(long, String, Locale)
-     */
-    public long set(long instant, String text, Locale locale) {
-        if ("BE".equals(text) == false) {
-            throw new IllegalArgumentException("Invalid era text: " + text);
-        }
-        return instant;
-    }
-
-    public long roundFloor(long instant) {
-        return Long.MIN_VALUE;
-    }
-
-    public long roundCeiling(long instant) {
-        return Long.MAX_VALUE;
-    }
-
-    public long roundHalfFloor(long instant) {
-        return Long.MIN_VALUE;
-    }
-
-    public long roundHalfCeiling(long instant) {
-        return Long.MIN_VALUE;
-    }
-
-    public long roundHalfEven(long instant) {
-        return Long.MIN_VALUE;
-    }
-
-    public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
-    }
-
-    public DurationField getRangeDurationField() {
-        return null;
-    }
-
-    public int getMinimumValue() {
-        return BuddhistChronology.BE;
-    }
-
-    public int getMaximumValue() {
-        return BuddhistChronology.BE;
-    }
-    
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        return "BE";
-    }
-    
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return 2;
-    }
-
-    /**
-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
-     */
-    public String getAsText(long instant, Locale locale) {
-        return "BE";
-    }
-
-    /**
-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
-     */
-    public int getMaximumTextLength(Locale locale) {
-        return 2;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html b/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
deleted file mode 100644
index eacc09f..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
+++ /dev/null
@@ -1,70 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-<title>org.joda.time.chrono.buddhist package</title>
-<!--
-
-   Joda Software License, Version 1.0
-  
-  
-   Copyright (c) 2001-03 Stephen Colebourne.
-   All rights reserved.
-  
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-  
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-  
-   3. The end-user documentation included with the redistribution,
-      if any, must include the following acknowledgment:
-         "This product includes software developed by the
-          Joda project (http://www.joda.org/)."
-      Alternately, this acknowledgment may appear in the software itself,
-      if and wherever such third-party acknowledgments normally appear.
-  
-   4. The name "Joda" must not be used to endorse or promote products
-      derived from this software without prior written permission. For
-      written permission, please contact licence@joda.org.
-  
-   5. Products derived from this software may not be called "Joda",
-      nor may "Joda" appear in their name, without prior written
-      permission of the Joda project.
-  
-   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
-   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
-   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
-   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-   SUCH DAMAGE.
-   ====================================================================
-  
-   This software consists of voluntary contributions made by many
-   individuals on behalf of the Joda project and was originally
-   created by Stephen Colebourne <scolebourne@joda.org>. For more
-   information on the Joda project, please see <http://www.joda.org/>.
-
--->
-</head>
-<body>
-<p>
-Provides a Buddhist Chronology implementation. The Buddhist calendar defines
-one era (BE) that runs 543 years out of sync with the Gregorian Julian
-calendar. In all other aspects the chronology follows the GJChronology. For
-example, the cutover date is the same as the default GJ cutover date.
-</p>
-</body>
-</html>
-
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
deleted file mode 100644
index c33049a..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
+++ /dev/null
@@ -1,761 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.util.Locale;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.DecoratedDurationField;
-
-/**
- * Chronology for supporting the cutover from the Julian calendar to the
- * Gregorian calendar.
- * 
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-final class CutoverChronology extends GJChronology {
-
-    static final long serialVersionUID = -2545574827706931671L;
-
-    /**
-     * Convert a datetime from one chronology to another.
-     */
-    private static long convertByYear(long instant, Chronology from, Chronology to) {
-        return to.getDateTimeMillis
-            (from.year().get(instant),
-             from.monthOfYear().get(instant),
-             from.dayOfMonth().get(instant),
-             from.millisOfDay().get(instant));
-    }
-
-    /**
-     * Convert a datetime from one chronology to another.
-     */
-    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {
-        long newInstant;
-        newInstant = to.weekyear().set(0, from.weekyear().get(instant));
-        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));
-        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));
-        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));
-        return newInstant;
-    }
-
-    private static void checkUTC(Chronology chrono) {
-        if (chrono.getDateTimeZone() != null &&
-            chrono.getDateTimeZone() != DateTimeZone.UTC) {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    private final GJChronology iJulianChronology;
-    private final GJChronology iGregorianChronology;
-
-    final long iCutoverInstant;
-    transient final long iGapDuration;
-
-    /**
-     * @param julian chronology used before the cutover instant
-     * @param gregorian chronology used at and after the cutover instant
-     * @param cutoverInstant instant when the gregorian chronology began
-     */
-    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverInstant) {
-        checkUTC(julian);
-        checkUTC(gregorian);
-
-        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
-            throw new IllegalArgumentException();
-        }
-        if (julian.isCenturyISO() != gregorian.isCenturyISO()) {
-            throw new IllegalArgumentException();
-        }
-
-        iJulianChronology = julian;
-        iGregorianChronology = gregorian;
-        iCutoverInstant = cutoverInstant;
-
-        // Compute difference between the chronologies at the cutover instant
-        iGapDuration = cutoverInstant - julianToGregorianByYear(cutoverInstant);
-
-        // Begin field definitions.
-
-        // First just copy all the Gregorian fields and then override those
-        // that need special attention.
-        copyFields(gregorian);
-        
-        // Assuming cutover is at midnight, all time of day fields can be
-        // gregorian since they are unaffected by cutover.
-
-        // Verify assumption.
-        if (gregorian.millisOfDay().get(cutoverInstant) == 0) {
-            // Cutover is sometime in the day, so cutover fields are required
-            // for time of day.
-
-            iMillisOfSecondField = new CutoverField(julian.millisOfSecond(), iMillisOfSecondField);
-            iMillisOfDayField = new CutoverField(julian.millisOfDay(), iMillisOfDayField);
-            iSecondOfMinuteField = new CutoverField(julian.secondOfMinute(), iSecondOfMinuteField);
-            iSecondOfDayField = new CutoverField(julian.secondOfDay(), iSecondOfDayField);
-            iMinuteOfHourField = new CutoverField(julian.minuteOfHour(), iMinuteOfHourField);
-            iMinuteOfDayField = new CutoverField(julian.minuteOfDay(), iMinuteOfDayField);
-            iHourOfDayField = new CutoverField(julian.hourOfDay(), iHourOfDayField);
-            iHourOfHalfdayField = new CutoverField(julian.hourOfHalfday(), iHourOfHalfdayField);
-            iClockhourOfDayField = new CutoverField(julian.clockhourOfDay(), iClockhourOfDayField);
-            iClockhourOfHalfdayField = new CutoverField(julian.clockhourOfHalfday(), iClockhourOfHalfdayField);
-            iHalfdayOfDayField = new CutoverField(julian.halfdayOfDay(), iHalfdayOfDayField);
-        }
-
-        // These fields just require basic cutover support.
-        {
-            iEraField = new CutoverField(julian.era(), gregorian.era());
-            iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());
-        }
-
-        // DayOfYear and weekOfWeekyear require special handling since cutover
-        // year has fewer days and weeks. Extend the cutover to the start of
-        // the next year or weekyear. This keeps the sequence unbroken during
-        // the cutover year.
-
-        {
-            long cutover = gregorian.year().roundCeiling(iCutoverInstant);
-            iDayOfYearField = new CutoverField
-                (julian.dayOfYear(), gregorian.dayOfYear(), cutover);
-        }
-
-        {
-            long cutover = gregorian.weekyear().roundCeiling(iCutoverInstant);
-            iWeekOfWeekyearField = new CutoverField
-                (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover, true);
-        }
-
-        // These fields are special because they have imprecise durations. The
-        // family of addition methods need special attention. Override affected
-        // duration fields as well.
-        {
-            iYearField = new ImpreciseCutoverField(julian.year(), gregorian.year());
-            iYearsField = iYearField.getDurationField();
-            iYearOfEraField = new ImpreciseCutoverField
-                (julian.yearOfEra(), gregorian.yearOfEra(), iYearsField);
-            iYearOfCenturyField = new ImpreciseCutoverField
-                (julian.yearOfCentury(), gregorian.yearOfCentury(), iYearsField);
-            
-            iCenturyOfEraField = new ImpreciseCutoverField(julian.centuryOfEra(), gregorian.centuryOfEra());
-            iCenturiesField = iCenturyOfEraField.getDurationField();
-            
-            iMonthOfYearField = new ImpreciseCutoverField(julian.monthOfYear(), gregorian.monthOfYear());
-            iMonthsField = iMonthOfYearField.getDurationField();
-            
-            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear(), true);
-            iWeekyearsField = iWeekyearField.getDurationField();
-        }
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        // Time fields are same for Julian and Gregorian.
-        return iGregorianChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        // Assume date is Gregorian.
-        long instant = iGregorianChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth, millisOfDay);
-        if (instant < iCutoverInstant) {
-            // Maybe it's Julian.
-            instant = iJulianChronology.getDateTimeMillis
-                (year, monthOfYear, dayOfMonth, millisOfDay);
-            if (instant >= iCutoverInstant) {
-                // Okay, it's in the illegal cutover gap.
-                throw new IllegalArgumentException("Specified date does not exist");
-            }
-        }
-        return instant;
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return getDateOnlyMillis(instant)
-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)
-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iCutoverInstant;
-    }
-
-    public boolean isCenturyISO() {
-        return iGregorianChronology.isCenturyISO();
-    }
-
-    public final int getMinimumDaysInFirstWeek() {
-        return iGregorianChronology.getMinimumDaysInFirstWeek();
-    }
-
-    long julianToGregorianByYear(long instant) {
-        return convertByYear(instant, iJulianChronology, iGregorianChronology);
-    }
-
-    long gregorianToJulianByYear(long instant) {
-        return convertByYear(instant, iGregorianChronology, iJulianChronology);
-    }
-
-    long julianToGregorianByWeekyear(long instant) {
-        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);
-    }
-
-    long gregorianToJulianByWeekyear(long instant) {
-        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);
-    }
-
-    /**
-     * This basic cutover field adjusts calls to 'get' and 'set' methods, and
-     * assumes that calls to add and addWrapped are unaffected by the cutover.
-     */
-    private class CutoverField extends AbstractDateTimeField {
-        static final long serialVersionUID = 3528501219481026402L;
-
-        final DateTimeField iJulianField;
-        final DateTimeField iGregorianField;
-        final long iCutover;
-        final boolean iConvertByWeekyear;
-
-        protected DurationField iDurationField;
-
-        /**
-         * @param julianField field from the chronology used before the cutover instant
-         * @param gregorianField field from the chronology used at and after the cutover
-         */
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            this(julianField, gregorianField, iCutoverInstant, false);
-        }
-
-        /**
-         * @param julianField field from the chronology used before the cutover instant
-         * @param gregorianField field from the chronology used at and after the cutover
-         * @param convertByWeekyear
-         */
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField, boolean convertByWeekyear) {
-            this(julianField, gregorianField, iCutoverInstant, convertByWeekyear);
-        }
-
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverInstant) {
-            this(julianField, gregorianField, cutoverInstant, false);
-        }
-
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
-                     long cutoverInstant, boolean convertByWeekyear) {
-            super(gregorianField.getName());
-            iJulianField = julianField;
-            iGregorianField = gregorianField;
-            iCutover = cutoverInstant;
-            iConvertByWeekyear = convertByWeekyear;
-            // Although average length of Julian and Gregorian years differ,
-            // use the Gregorian duration field because it is more accurate.
-            iDurationField = gregorianField.getDurationField();
-        }
-
-        public boolean isLenient() {
-            return false;
-        }
-
-        public int get(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.get(instant);
-            } else {
-                return iJulianField.get(instant);
-            }
-        }
-
-        public String getAsText(long instant, Locale locale) {
-            if (instant >= iCutover) {
-                return iGregorianField.getAsText(instant, locale);
-            } else {
-                return iJulianField.getAsText(instant, locale);
-            }
-        }
-
-        public String getAsShortText(long instant, Locale locale) {
-            if (instant >= iCutover) {
-                return iGregorianField.getAsShortText(instant, locale);
-            } else {
-                return iJulianField.getAsShortText(instant, locale);
-            }
-        }
-
-        public long add(long instant, int value) {
-            return iGregorianField.add(instant, value);
-        }
-
-        public long add(long instant, long value) {
-            return iGregorianField.add(instant, value);
-        }
-
-        public int getDifference(long minuendInstant, long subtrahendInstant) {
-            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
-        }
-
-        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-        }
-
-        public long set(long instant, int value) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.set(instant, value);
-                if (instant < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant + iGapDuration < iCutover) {
-                        instant = gregorianToJulian(instant);
-                    }
-                    // Verify that new value stuck.
-                    if (get(instant) != value) {
-                        throw new IllegalArgumentException
-                            ("Illegal value for " + iGregorianField.getName() + ": " + value);
-                    }
-                }
-            } else {
-                instant = iJulianField.set(instant, value);
-                if (instant >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant - iGapDuration >= iCutover) {
-                        instant = julianToGregorian(instant);
-                    }
-                    // Verify that new value stuck.
-                    if (get(instant) != value) {
-                        throw new IllegalArgumentException
-                            ("Illegal value for " + iJulianField.getName() + ": " + value);
-                    }
-                }
-            }
-            return instant;
-        }
-
-        public long set(long instant, String text, Locale locale) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.set(instant, text, locale);
-                if (instant < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant + iGapDuration < iCutover) {
-                        instant = gregorianToJulian(instant);
-                    }
-                    // Cannot verify that new value stuck because set may be lenient.
-                }
-            } else {
-                instant = iJulianField.set(instant, text, locale);
-                if (instant >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant - iGapDuration >= iCutover) {
-                        instant = julianToGregorian(instant);
-                    }
-                    // Cannot verify that new value stuck because set may be lenient.
-                }
-            }
-            return instant;
-        }
-
-        public DurationField getDurationField() {
-            return iDurationField;
-        }
-
-        public DurationField getRangeDurationField() {
-            DurationField rangeField = iGregorianField.getRangeDurationField();
-            if (rangeField == null) {
-                rangeField = iJulianField.getRangeDurationField();
-            }
-            return rangeField;
-        }
-
-        public boolean isLeap(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.isLeap(instant);
-            } else {
-                return iJulianField.isLeap(instant);
-            }
-        }
-
-        public int getLeapAmount(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.getLeapAmount(instant);
-            } else {
-                return iJulianField.getLeapAmount(instant);
-            }
-        }
-
-        public DurationField getLeapDurationField() {
-            return iGregorianField.getLeapDurationField();
-        }
-
-
-        public int getMinimumValue() {
-            // For all precise fields, the Julian and Gregorian limits are
-            // identical. Choose Julian to tighten up the year limits.
-            return iJulianField.getMinimumValue();
-        }
-        
-        public int getMinimumValue(long instant) {
-            if (instant < iCutover) {
-                return iJulianField.getMinimumValue(instant);
-            }
-
-            int min = iGregorianField.getMinimumValue(instant);
-
-            // Because the cutover may reduce the length of this field, verify
-            // the minimum by setting it.
-            instant = iGregorianField.set(instant, min);
-            if (instant < iCutover) {
-                min = iGregorianField.get(iCutover);
-            }
-
-            return min;
-        }
-
-        public int getMaximumValue() {
-            // For all precise fields, the Julian and Gregorian limits are
-            // identical.
-            return iGregorianField.getMaximumValue();
-        }
-
-        public int getMaximumValue(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.getMaximumValue(instant);
-            }
-
-            int max = iJulianField.getMaximumValue(instant);
-
-            // Because the cutover may reduce the length of this field, verify
-            // the maximum by setting it.
-            instant = iJulianField.set(instant, max);
-            if (instant >= iCutover) {
-                max = iJulianField.get(iJulianField.add(iCutover, -1));
-            }
-
-            return max;
-        }
-
-        public long roundFloor(long instant) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.roundFloor(instant);
-                if (instant < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant + iGapDuration < iCutover) {
-                        instant = gregorianToJulian(instant);
-                    }
-                }
-            } else {
-                instant = iJulianField.roundFloor(instant);
-            }
-            return instant;
-        }
-
-        public long roundCeiling(long instant) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.roundCeiling(instant);
-            } else {
-                instant = iJulianField.roundCeiling(instant);
-                if (instant >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant - iGapDuration >= iCutover) {
-                        instant = julianToGregorian(instant);
-                    }
-                }
-            }
-            return instant;
-        }
-
-        public int getMaximumTextLength(Locale locale) {
-            return Math.max(iJulianField.getMaximumTextLength(locale),
-                            iGregorianField.getMaximumTextLength(locale));
-        }
-
-        public int getMaximumShortTextLength(Locale locale) {
-            return Math.max(iJulianField.getMaximumShortTextLength(locale),
-                            iGregorianField.getMaximumShortTextLength(locale));
-        }
-
-        protected long julianToGregorian(long instant) {
-            if (iConvertByWeekyear) {
-                return julianToGregorianByWeekyear(instant);
-            } else {
-                return julianToGregorianByYear(instant);
-            }
-        }
-
-        protected long gregorianToJulian(long instant) {
-            if (iConvertByWeekyear) {
-                return gregorianToJulianByWeekyear(instant);
-            } else {
-                return gregorianToJulianByYear(instant);
-            }
-        }
-    }
-
-    /**
-     * Cutover field for variable length fields. These fields internally call
-     * set whenever add is called. As a result, the same correction applied to
-     * set must be applied to add and addWrapped. Knowing when to use this
-     * field requires specific knowledge of how the GJ fields are implemented.
-     */
-    private final class ImpreciseCutoverField extends CutoverField {
-        static final long serialVersionUID = 3410248757173576441L;
-
-        /**
-         * Creates a duration field that links back to this.
-         */
-        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            this(julianField, gregorianField, null, false);
-        }
-
-        /**
-         * Creates a duration field that links back to this.
-         */
-        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
-                              boolean convertByWeekyear) {
-            this(julianField, gregorianField, null, convertByWeekyear);
-        }
-
-        /**
-         * Uses a shared duration field rather than creating a new one.
-         *
-         * @param durationField shared duration field
-         */
-        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
-                              DurationField durationField)
-        {
-            this(julianField, gregorianField, durationField, false);
-        }
-
-        /**
-         * Uses a shared duration field rather than creating a new one.
-         *
-         * @param durationField shared duration field
-         */
-        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
-                              DurationField durationField, boolean convertByWeekyear)
-        {
-            super(julianField, gregorianField, convertByWeekyear);
-            if (durationField == null) {
-                durationField = new LinkedDurationField(iDurationField, this);
-            }
-            iDurationField = durationField;
-        }
-
-        public long add(long instant, int value) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.add(instant, value);
-                if (instant < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant + iGapDuration < iCutover) {
-                        instant = gregorianToJulian(instant);
-                    }
-                }
-            } else {
-                instant = iJulianField.add(instant, value);
-                if (instant >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant - iGapDuration >= iCutover) {
-                        instant = julianToGregorian(instant);
-                    }
-                }
-            }
-            return instant;
-        }
-        
-        public long add(long instant, long value) {
-            if (instant >= iCutover) {
-                instant = iGregorianField.add(instant, value);
-                if (instant < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant + iGapDuration < iCutover) {
-                        instant = gregorianToJulian(instant);
-                    }
-                }
-            } else {
-                instant = iJulianField.add(instant, value);
-                if (instant >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (instant - iGapDuration >= iCutover) {
-                        instant = julianToGregorian(instant);
-                    }
-                }
-            }
-            return instant;
-        }
-
-        public int getDifference(long minuendInstant, long subtrahendInstant) {
-            if (minuendInstant >= iCutover) {
-                if (subtrahendInstant >= iCutover) {
-                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
-                }
-                // Remember, the add is being reversed. Since subtrahend is
-                // Julian, convert minuend to Julian to match.
-                minuendInstant = gregorianToJulian(minuendInstant);
-                return iJulianField.getDifference(minuendInstant, subtrahendInstant);
-            } else {
-                if (subtrahendInstant < iCutover) {
-                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);
-                }
-                // Remember, the add is being reversed. Since subtrahend is
-                // Gregorian, convert minuend to Gregorian to match.
-                minuendInstant = julianToGregorian(minuendInstant);
-                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
-            }
-        }
-
-        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-            if (minuendInstant >= iCutover) {
-                if (subtrahendInstant >= iCutover) {
-                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-                }
-                // Remember, the add is being reversed. Since subtrahend is
-                // Julian, convert minuend to Julian to match.
-                minuendInstant = gregorianToJulian(minuendInstant);
-                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-            } else {
-                if (subtrahendInstant < iCutover) {
-                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-                }
-                // Remember, the add is being reversed. Since subtrahend is
-                // Gregorian, convert minuend to Gregorian to match.
-                minuendInstant = julianToGregorian(minuendInstant);
-                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-            }
-        }
-
-        // Since the imprecise fields have durations longer than the gap
-        // duration, keep these methods simple. The inherited implementations
-        // produce incorrect results.
-        //
-        // Degenerate case: If this field is a month, and the cutover is set
-        // far into the future, then the gap duration may be so large as to
-        // reduce the number of months in a year. If the missing month(s) are
-        // at the beginning or end of the year, then the minimum and maximum
-        // values are not 1 and 12. I don't expect this case to ever occur.
-
-        public int getMinimumValue(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.getMinimumValue(instant);
-            } else {
-                return iJulianField.getMinimumValue(instant);
-            }
-        }
-
-        public int getMaximumValue(long instant) {
-            if (instant >= iCutover) {
-                return iGregorianField.getMaximumValue(instant);
-            } else {
-                return iJulianField.getMaximumValue(instant);
-            }
-        }
-    }
-
-    /**
-     * Links the duration back to a ImpreciseCutoverField.
-     */
-    private static class LinkedDurationField extends DecoratedDurationField {
-        static final long serialVersionUID = 4097975388007713084L;
-
-        private final ImpreciseCutoverField iField;
-
-        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {
-            super(durationField, durationField.getName());
-            iField = dateTimeField;
-        }
-
-        public long add(long instant, int value) {
-            return iField.add(instant, value);
-        }
-
-        public long add(long instant, long value) {
-            return iField.add(instant, value);
-        }
-
-        public int getDifference(long minuendInstant, long subtrahendInstant) {
-            return iField.getDifference(minuendInstant, subtrahendInstant);
-        }
-
-        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
deleted file mode 100644
index 4ea4d46..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.OffsetDateTimeField;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-
-/**
- * Chronology for supporting GJ style centuries. Century 1 begin on year 1, and
- * year of century ranges from 1 to 100.
- *
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-class GJCenturyChronology extends GJChronology {
-
-    static final long serialVersionUID = -8572000567534692411L;
-
-    private final GJChronology iChronology;
-
-    /**
-     * @param chrono wrapped chronology
-     */
-    public GJCenturyChronology(GJChronology chrono) {
-        if (chrono.getDateTimeZone() != null &&
-            chrono.getDateTimeZone() != DateTimeZone.UTC) {
-            throw new IllegalArgumentException();
-        }
-        if (!chrono.isCenturyISO()) {
-            throw new IllegalArgumentException();
-        }
-
-        iChronology = chrono;
-        copyFields(chrono);
-
-        DateTimeField tempField = new OffsetDateTimeField(iYearOfEraField, "", 99);
-        iCenturyOfEraField = new DividedDateTimeField
-            (tempField, "centuryOfEra", "centuries", 100);
-
-        tempField = new RemainderDateTimeField
-            ((DividedDateTimeField)iCenturyOfEraField, "");
-        iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-    
-    public boolean isCenturyISO() {
-        return false;
-    }
-
-    public final int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
deleted file mode 100644
index 35aba91..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
+++ /dev/null
@@ -1,714 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.lang.ref.SoftReference;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import org.joda.time.Chronology;
-// Import for @link support
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-import org.joda.time.Instant;
-import org.joda.time.ReadableInstant;
-import org.joda.time.format.DateTimePrinter;
-import org.joda.time.format.ISODateTimeFormat;
-
-/**
- * GJChronology provides access to the individual date time fields 
- * for the Gregorian/Julian defined chronological calendar system.
- * <p>
- * The Gregorian calendar replaced the Julian calendar, and the point in time
- * when this chronology switches can be controlled using the second parameter
- * of the getInstance method. By default this cutover is set to the date the
- * Gregorian calendar was first instituted, October 15, 1582.
- * <p>
- * Before this date, this chronology uses the proleptic Julian calendar
- * (proleptic means extending indefinitely). The Julian calendar has leap 
- * years every four years, whereas the Gregorian has special rules for 100 
- * and 400 years. A meaningful result will thus be obtained for all input 
- * values. However before March 1, 4 CE, Julian leap years were irregular,
- * and before 45 BCE there was no Julian calendar.
- * <p>
- * This chronology differs from {@link java.util.GregorianCalendar
- * java.util.GregorianCalendar} in that years in BCE are returned
- * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra
- * field produces results compatible with GregorianCalendar.
- * <p>
- * The Julian calendar does not have a year zero, and so year -1 is followed by
- * year 1. If the Gregorian cutover date is specified at or before year -1
- * (Julian), year zero is defined. In other words, the proleptic Gregorian
- * chronology implemented by this class has a year zero.
- * <p>
- * A pure proleptic Gregorian chronology is obtained by specifying a cutover of
- * Long.MIN_VALUE. Likewise, a pure Julian chronology is obtained with a
- * cutover of Long.MAX_VALUE.
- * <p>
- * GJChronology is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public abstract class GJChronology extends Chronology {
-
-    static final long serialVersionUID = 3258844765135550418L;
-
-    /**
-     * The default GregorianJulian cutover point
-     */
-    static final long DEFAULT_CUTOVER = -12219292800000L;
-
-    // Cache that maps DateTimeZones to Factory instances.
-    private static HashMap cZonesToFactories = new HashMap();
-
-    transient DurationField iYearsField;
-    transient DurationField iCenturiesField;
-    transient DurationField iMonthsField;
-    transient DurationField iWeekyearsField;
-
-    transient DurationField iMillisField;
-    transient DurationField iSecondsField;
-    transient DurationField iMinutesField;
-    transient DurationField iHoursField;
-    transient DurationField iDaysField;
-    transient DurationField iWeeksField;
-
-    transient DateTimeField iYearField;
-    transient DateTimeField iYearOfEraField;
-    transient DateTimeField iYearOfCenturyField;
-    transient DateTimeField iCenturyOfEraField;
-    transient DateTimeField iEraField;
-    transient DateTimeField iDayOfWeekField;
-    transient DateTimeField iDayOfMonthField;
-    transient DateTimeField iDayOfYearField;
-    transient DateTimeField iMonthOfYearField;
-    transient DateTimeField iWeekOfWeekyearField;
-    transient DateTimeField iWeekyearField;
-
-    transient DateTimeField iMillisOfSecondField;
-    transient DateTimeField iMillisOfDayField;
-    transient DateTimeField iSecondOfMinuteField;
-    transient DateTimeField iSecondOfDayField;
-    transient DateTimeField iMinuteOfHourField;
-    transient DateTimeField iMinuteOfDayField;
-    transient DateTimeField iHourOfDayField;
-    transient DateTimeField iHourOfHalfdayField;
-    transient DateTimeField iClockhourOfDayField;
-    transient DateTimeField iClockhourOfHalfdayField;
-    transient DateTimeField iHalfdayOfDayField;
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * <p>The time zone of the returned instance is UTC.
-     */
-    public static GJChronology getInstanceUTC() {
-        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * <p>The returned chronology is in the default time zone.
-     */
-    public static GJChronology getInstance() {
-        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     */
-    public static GJChronology getInstance(DateTimeZone zone) {
-        return getInstance(zone, DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set. If the cutover millis is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover millis is Long.MAX_VALUE,
-     * a proleptic Julian calendar is returned.
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as a ReadableInstant, null means default
-     * @param centuryISO  when true, century related fields follow ISO rules
-     */
-    public static GJChronology getInstance(DateTimeZone zone,
-                                           ReadableInstant gregorianCutover,
-                                           boolean centuryISO)
-    {
-        return getInstance(zone, gregorianCutover, centuryISO, 4);
-    }
-    
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z
-     * @param centuryISO  when true, century related fields follow ISO rules
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        long gregorianCutover,
-                                                        boolean centuryISO)
-    {
-        return getInstance(zone, gregorianCutover, centuryISO, 4);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as a ReadableInstant, null means default
-     * @param centuryISO  when true, century related fields follow ISO rules
-     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        ReadableInstant gregorianCutover,
-                                                        boolean centuryISO,
-                                                        int minDaysInFirstWeek)
-    {
-        long cutover;
-        if (gregorianCutover != null) {
-            cutover = gregorianCutover.getMillis();
-        } else {
-            cutover = DEFAULT_CUTOVER;
-        }
-        return getInstance(zone, cutover, centuryISO, minDaysInFirstWeek);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z
-     * @param centuryISO  when true, century related fields follow ISO rules
-     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        long gregorianCutover,
-                                                        boolean centuryISO,
-                                                        int minDaysInFirstWeek)
-    {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-
-        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {
-            throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek);
-        }
-
-        Factory factory;
-        getFactory: {
-            SoftReference ref = (SoftReference)cZonesToFactories.get(zone);
-            if (ref != null) {
-                factory = (Factory)ref.get();
-                if (factory != null) {
-                    break getFactory;
-                }
-            }
-            factory = new Factory(zone);
-            cZonesToFactories.put(zone, new SoftReference(factory));
-        }
-
-        return factory.getInstance(gregorianCutover, centuryISO, minDaysInFirstWeek);
-    }
-
-    GJChronology() {
-        super();
-    }
-
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == getDateTimeZone()) {
-            return this;
-        }
-        if (zone == DateTimeZone.UTC) {
-            return withUTC();
-        }
-        return getInstance(zone, getGregorianJulianCutoverMillis(),
-                           isCenturyISO(), getMinimumDaysInFirstWeek());
-    }
-
-    // This method is overridden by GJZonedChronology.
-    public DateTimeZone getDateTimeZone() {
-        return DateTimeZone.UTC;
-    }
-
-    /**
-     * Gets the cutover instant between Gregorian and Julian chronologies.
-     * @return the cutover instant
-     */
-    public Instant getGregorianJulianCutover() {
-        return new Instant(getGregorianJulianCutoverMillis());
-    }
-    
-    /**
-     * Gets the cutover millis between Gregorian and Julian chronologies.
-     * @return the cutover millis
-     */
-    public abstract long getGregorianJulianCutoverMillis();
-    
-    /**
-     * Returns true when century fields follow ISO rules. In ISO rules, the
-     * century is simply the year divided by 100, and the year of century is
-     * the remainder.
-     * <p>
-     * When false is returned, the first century is defined to start on year
-     * one, and the year of century can range from 1 to 100.
-     */
-    public abstract boolean isCenturyISO();
-
-    public abstract int getMinimumDaysInFirstWeek();
-    
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DurationField millis() {
-        return iMillisField;
-    }
-
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-    
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-    
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-    
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-    
-    public DurationField years() {
-        return iYearsField;
-    }
-
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
-
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
-    }
-
-    public DateTimeField era() {
-        return iEraField;
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a debugging toString.
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer(50);
-        sb.append("GJChronology");
-        sb.append('[');
-        sb.append(getDateTimeZone().getID());
-        sb.append(", ");
-
-        long cutover = getGregorianJulianCutoverMillis();
-        if (cutover == Long.MAX_VALUE) {
-            sb.append("julian");
-        } else if (cutover == Long.MIN_VALUE) {
-            sb.append("gregorian");
-        } else {
-            sb.append("cutover=");
-            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());
-            DateTimePrinter printer;
-            if (withUTC().getTimeOnlyMillis(cutover) == 0) {
-                printer = format.date();
-            } else {
-                printer = format.dateTime();
-            }
-            printer.printTo(sb, cutover);
-        }
-
-        sb.append(", century=");
-        sb.append(isCenturyISO() ? "iso" : "gj");
-
-        sb.append(", mdfw=");
-        sb.append(getMinimumDaysInFirstWeek());
-        sb.append(']');
-
-        return sb.toString();
-    }
-
-    /**
-     * Serialize GJChronology instances using a small stub. This reduces the
-     * serialized size, and deserialized instances come from the cache.
-     *
-     * <p>This method is intentionally package-private in order for sub-classes
-     * to inherit this method.
-     */
-    Object writeReplace() {
-        return new Stub(getDateTimeZone(),
-                        getGregorianJulianCutoverMillis(),
-                        isCenturyISO(),
-                        getMinimumDaysInFirstWeek());
-    }
-
-    /**
-     * Used by subclass constructors to copy all the fields of another
-     * chronology into this one.
-     */
-    void copyFields(Chronology chrono) {
-        iYearsField = chrono.years();
-        iCenturiesField = chrono.centuries();
-        iMonthsField = chrono.months();
-        iWeekyearsField = chrono.weekyears();
-
-        iMillisField = chrono.millis();
-        iSecondsField = chrono.seconds();
-        iMinutesField = chrono.minutes();
-        iHoursField = chrono.hours();
-        iDaysField = chrono.days();
-        iWeeksField = chrono.weeks();
-
-        iYearField = chrono.year();
-        iYearOfEraField = chrono.yearOfEra();
-        iYearOfCenturyField = chrono.yearOfCentury();
-        iCenturyOfEraField = chrono.centuryOfEra();
-        iEraField = chrono.era();
-        iDayOfWeekField = chrono.dayOfWeek();
-        iDayOfMonthField = chrono.dayOfMonth();
-        iDayOfYearField = chrono.dayOfYear();
-        iMonthOfYearField = chrono.monthOfYear();
-        iWeekOfWeekyearField = chrono.weekOfWeekyear();
-        iWeekyearField = chrono.weekyear();
-
-        iMillisOfSecondField = chrono.millisOfSecond();
-        iMillisOfDayField = chrono.millisOfDay();
-        iSecondOfMinuteField = chrono.secondOfMinute();
-        iSecondOfDayField = chrono.secondOfDay();
-        iMinuteOfHourField = chrono.minuteOfHour();
-        iMinuteOfDayField = chrono.minuteOfDay();
-        iHourOfDayField = chrono.hourOfDay();
-        iHourOfHalfdayField = chrono.hourOfHalfday();
-        iClockhourOfDayField = chrono.clockhourOfDay();
-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();
-        iHalfdayOfDayField = chrono.halfdayOfDay();
-    }
-
-    private static final class Stub implements Serializable {
-        static final long serialVersionUID = -1220272966668670015L;
-
-        private transient DateTimeZone iZone;
-        private transient long iCutover;
-        private transient boolean iCenturyISO;
-        private transient byte iMinDaysInFirstWeek;
-
-        Stub(DateTimeZone zone, long gregorianCutover,
-             boolean centuryISO, int minDaysInFirstWeek)
-        {
-            iZone = zone;
-            iCutover = gregorianCutover;
-            iCenturyISO = centuryISO;
-            iMinDaysInFirstWeek = (byte)minDaysInFirstWeek;
-        }
-
-        Object readResolve() {
-            return GJChronology.getInstance(iZone,
-                                            iCutover,
-                                            iCenturyISO,
-                                            iMinDaysInFirstWeek);
-        }
-
-        private void writeObject(ObjectOutputStream out) throws IOException {
-            out.writeBoolean(iCenturyISO);
-            out.writeObject(iZone);
-            out.writeLong(iCutover);
-            out.writeByte(iMinDaysInFirstWeek);
-        }
-
-        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-            iCenturyISO = in.readBoolean();
-            iZone = (DateTimeZone)in.readObject();
-            iCutover = in.readLong();
-            iMinDaysInFirstWeek = in.readByte();
-        }
-    }
-
-    /**
-     * Creates instances for a specific time zone.
-     */
-    private static final class Factory {
-        private final DateTimeZone iZone;
-
-        // A simple cache that performs in O(n) time.
-        private ArrayList iCache;
-
-        Factory(DateTimeZone zone) {
-            iZone = zone;
-            iCache = new ArrayList();
-        }
-
-        public synchronized GJChronology getInstance(long gregorianCutover,
-                                                     boolean centuryISO,
-                                                     int minDaysInFirstWeek)
-        {
-            GJChronology chrono;
-            ArrayList cache = iCache;
-            
-            for (int i=cache.size(); --i>=0; ) {
-                chrono = (GJChronology)((SoftReference)cache.get(i)).get();
-                if (chrono == null) {
-                    cache.remove(i);
-                    continue;
-                }
-                
-                if (chrono.getGregorianJulianCutoverMillis() == gregorianCutover &&
-                    chrono.isCenturyISO() == centuryISO &&
-                    chrono.getMinimumDaysInFirstWeek() == minDaysInFirstWeek) {
-                    
-                    return chrono;
-                }
-            }
-
-            if (iZone != DateTimeZone.UTC) {
-                chrono = GJChronology.getInstance
-                    (DateTimeZone.UTC, gregorianCutover, centuryISO, minDaysInFirstWeek);
-                chrono = new GJZonedChronology(chrono, iZone);
-            } else {
-                if (gregorianCutover == Long.MAX_VALUE) {
-                    chrono = new JulianChronology(minDaysInFirstWeek);
-                } else if (gregorianCutover == Long.MIN_VALUE) {
-                    chrono = new GregorianChronology(minDaysInFirstWeek);
-                } else {
-                    JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance
-                        (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);
-                    GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance
-                        (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);
-                    
-                    chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);
-                }
-
-                if (!centuryISO) {
-                    chrono = new GJCenturyChronology(chrono);
-                }
-            }
-            
-            cache.add(new SoftReference(chrono));
-            return chrono;
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
deleted file mode 100644
index d43be2f..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the day of the month component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
-
-    static final long serialVersionUID = -4677223814028011723L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor.
-     */
-    GJDayOfMonthDateTimeField(ProlepticChronology chronology, DurationField days) {
-        super("dayOfMonth", days);
-        iChronology = chronology;
-    }
-
-    /**
-     * Get the day of the month component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the day of the month extracted from the input.
-     */
-    public int get(long instant) {
-        return iChronology.getDayOfMonth(instant);
-    }
-
-    public DurationField getRangeDurationField() {
-        return iChronology.months();
-    }
-
-    public int getMinimumValue() {
-        return 1;
-    }
-
-    public int getMaximumValue() {
-        return 31;
-    }
-
-    public int getMaximumValue(long instant) {
-        int thisYear = iChronology.year().get(instant);
-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
-        return iChronology.getDaysInYearMonth(thisYear, thisMonth);
-    }
-
-    protected int getMaximumValueForSet(long instant, int value) {
-        return value > 28 ? getMaximumValue(instant) : 28;
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.dayOfMonth();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
deleted file mode 100644
index d3b05f0..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * GJDayOfWeekDateTimeField provides time calculations for the
- * day of the week component of time.
- *
- * @since 1.0
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- */
-final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {
-    
-    static final long serialVersionUID = -3857947176719041436L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor.
-     */
-    GJDayOfWeekDateTimeField(ProlepticChronology chronology, DurationField days) {
-        super("dayOfWeek", days);
-        iChronology = chronology;
-    }
-
-    /**
-     * Get the value of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query
-     * @return the day of the week extracted from the input
-     */
-    public int get(long instant) {
-        // 1970-01-01 is day of week 4, Thursday.
-
-        long daysSince19700101;
-        if (instant >= 0) {
-            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))
-                / DateTimeConstants.MILLIS_PER_DAY;
-            if (daysSince19700101 < -3) {
-                return 7 + (int) ((daysSince19700101 + 4) % 7);
-            }
-        }
-
-        return 1 + (int) ((daysSince19700101 + 3) % 7);
-    }
-
-    /**
-     * Get the textual value of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query
-     * @param locale  the locale to use
-     * @return the day of the week, such as 'Monday'
-     */
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));
-    }
-
-    /**
-     * Get the abbreviated textual value of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query
-     * @param locale  the locale to use
-     * @return the day of the week, such as 'Mon'
-     */
-    public String getAsShortText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));
-    }
-
-    /**
-     * Set the value of the specified time instant from text.
-     * 
-     * @param instant  the time instant in millis to update
-     * @param text  the text to set from
-     * @param locale  the locale to use
-     * @return the updated millis
-     */
-    public long set(long instant, String text, Locale locale) {
-        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));
-    }
-
-    public DurationField getRangeDurationField() {
-        return iChronology.weeks();
-    }
-
-    /**
-     * Get the minimum value that this field can have.
-     * 
-     * @return the field's minimum value
-     */
-    public int getMinimumValue() {
-        return DateTimeConstants.MONDAY;
-    }
-
-    /**
-     * Get the maximum value that this field can have.
-     * 
-     * @return the field's maximum value
-     */
-    public int getMaximumValue() {
-        return DateTimeConstants.SUNDAY;
-    }
-
-    /**
-     * Get the maximum length of the text returned by this field.
-     * 
-     * @param locale  the locale to use
-     * @return the maximum textual length
-     */
-    public int getMaximumTextLength(Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();
-    }
-
-    /**
-     * Get the maximum length of the abbreviated text returned by this field.
-     * 
-     * @param locale  the locale to use
-     * @return the maximum abbreviated textual length
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.dayOfWeek();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
deleted file mode 100644
index 92271e5..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the day of the year component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {
-
-    static final long serialVersionUID = -6821236822336841037L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJDayOfYearDateTimeField(ProlepticChronology chronology, DurationField days) {
-        super("dayOfYear", days);
-        iChronology = chronology;
-    }
-
-    /**
-     * Get the day of the year component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the day of the year extracted from the input.
-     */
-    public int get(long instant) {
-        long dateInstant = iChronology.year().roundFloor(instant);
-        return (int) ((instant - dateInstant) / DateTimeConstants.MILLIS_PER_DAY) + 1;
-    }
-
-    public DurationField getRangeDurationField() {
-        return iChronology.years();
-    }
-
-    public int getMinimumValue() {
-        return 1;
-    }
-
-    public int getMaximumValue() {
-        return 366;
-    }
-
-    public int getMaximumValue(long instant) {
-        int thisYear = iChronology.year().get(instant);
-        return iChronology.getDaysInYear(thisYear);
-    }
-
-    protected int getMaximumValueForSet(long instant, int value) {
-        return value > 365 ? getMaximumValue(instant) : 365;
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.dayOfYear();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
deleted file mode 100644
index 4d9c234..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the era component of time.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @version 1.0
- * @since 1.0
- */
-final class GJEraDateTimeField extends AbstractDateTimeField {
-    
-    static final long serialVersionUID = 4240986525305515528L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJEraDateTimeField(ProlepticChronology chronology) {
-        super("era");
-        iChronology = chronology;
-    }
-
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Get the Era component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     */
-    public int get(long instant) {
-        if (iChronology.year().get(instant) <= 0) {
-            return DateTimeConstants.BCE;
-        } else {
-            return DateTimeConstants.CE;
-        }
-    }
-
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));
-    }
-
-    /**
-     * Set the Era component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param era  the era to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if era is invalid.
-     */
-    public long set(long instant, int era) {
-        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);
-            
-        int oldEra = get(instant);
-        if (oldEra != era) {
-            int year = iChronology.year().get(instant);
-            return iChronology.year().set(instant, -year);
-        } else {
-            return instant;
-        }
-    }
-
-    public long set(long instant, String text, Locale locale) {
-        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));
-    }
-
-    public long roundFloor(long instant) {
-        if (get(instant) == DateTimeConstants.CE) {
-            return iChronology.year().set(0, 1);
-        } else {
-            return Long.MIN_VALUE;
-        }
-    }
-
-    public long roundCeiling(long instant) {
-        if (get(instant) == DateTimeConstants.BCE) {
-            return iChronology.year().set(0, 1);
-        } else {
-            return Long.MAX_VALUE;
-        }
-    }
-
-    public long roundHalfFloor(long instant) {
-        // In reality, the era is infinite, so there is no halfway point.
-        return roundFloor(instant);
-    }
-
-    public long roundHalfCeiling(long instant) {
-        // In reality, the era is infinite, so there is no halfway point.
-        return roundFloor(instant);
-    }
-
-    public long roundHalfEven(long instant) {
-        // In reality, the era is infinite, so there is no halfway point.
-        return roundFloor(instant);
-    }
-
-    public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
-    }
-
-    public DurationField getRangeDurationField() {
-        return null;
-    }
-
-    public int getMinimumValue() {
-        return DateTimeConstants.BCE;
-    }
-
-    public int getMaximumValue() {
-        return DateTimeConstants.CE;
-    }
-
-    public int getMaximumTextLength(Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.era();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
deleted file mode 100644
index d8230d6..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.lang.ref.WeakReference;
-import java.text.DateFormatSymbols;
-import java.util.WeakHashMap;
-import java.util.Locale;
-
-/**
- * Utility class used by a few of the DateTimeFields.
- *
- * @author Brian S O'Neill
- */
-class GJLocaleSymbols {
-    private static final int FAST_CACHE_SIZE = 64;
-
-    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
-
-    private static WeakHashMap cCache = new WeakHashMap();
-
-    public static GJLocaleSymbols forLocale(Locale locale) {
-        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
-        GJLocaleSymbols symbols = cFastCache[index];
-        if (symbols != null && symbols.iLocale.get() == locale) {
-            return symbols;
-        }
-        synchronized (cCache) {
-            symbols = (GJLocaleSymbols) cCache.get(locale);
-            if (symbols == null) {
-                symbols = new GJLocaleSymbols(locale);
-                cCache.put(locale, symbols);
-            }
-        }
-        cFastCache[index] = symbols;
-        return symbols;
-    }
-
-    private static String[] realignMonths(String[] months) {
-        String[] a = new String[13];
-        for (int i=1; i<13; i++) {
-            a[i] = months[i - 1];
-        }
-        return a;
-    }
-
-    private static String[] realignDaysOfWeek(String[] daysOfWeek) {
-        String[] a = new String[8];
-        for (int i=1; i<8; i++) {
-            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];
-        }
-        return a;
-    }
-
-    private static int maxLength(String[] a) {
-        int max = 0;
-        for (int i=a.length; --i>=0; ) {
-            String s = a[i];
-            if (s != null) {
-                int len = s.length();
-                if (len > max) {
-                    max = len;
-                }
-            }
-        }
-        return max;
-    }
-
-    private final WeakReference iLocale;
-
-    private final String[] iEras;
-    private final String[] iDaysOfWeek;
-    private final String[] iShortDaysOfWeek;
-    private final String[] iMonths;
-    private final String[] iShortMonths;
-    private final String[] iHalfday;
-
-    private final int iMaxEraLength;
-    private final int iMaxDayOfWeekLength;
-    private final int iMaxShortDayOfWeekLength;
-    private final int iMaxMonthLength;
-    private final int iMaxShortMonthLength;
-    private final int iMaxHalfdayLength;
-
-    private GJLocaleSymbols(Locale locale) {
-        if (locale == null) {
-            locale = Locale.getDefault();
-        }
-
-        iLocale = new WeakReference(locale);
-
-        DateFormatSymbols dfs = new DateFormatSymbols(locale);
-
-        iEras = dfs.getEras();
-        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());
-        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());
-        iMonths = realignMonths(dfs.getMonths());
-        iShortMonths = realignMonths(dfs.getShortMonths());
-        iHalfday = dfs.getAmPmStrings();
-
-        iMaxEraLength = maxLength(iEras);
-        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);
-        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);
-        iMaxMonthLength = maxLength(iMonths);
-        iMaxShortMonthLength = maxLength(iShortMonths);
-        iMaxHalfdayLength = maxLength(iHalfday);
-    }
-
-    public String eraValueToText(int value) {
-        return iEras[value];
-    }
-
-    public int eraTextToValue(String text) {
-        String[] eras = iEras;
-        for (int i=eras.length; --i>=0; ) {
-            if (eras[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        throw new IllegalArgumentException("Illegal era text: " + text);
-    }
-
-    public int getEraMaxTextLength() {
-        return iMaxEraLength;
-    }
-
-    public String monthOfYearValueToText(int value) {
-        return iMonths[value];
-    }
-
-    public String monthOfYearValueToShortText(int value) {
-        return iShortMonths[value];
-    }
-
-    public int monthOfYearTextToValue(String text) {
-        String[] months = iMonths;
-        for (int i=months.length; --i>=1; ) {
-            if (months[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        months = iShortMonths;
-        for (int i=months.length; --i>=1; ) {
-            if (months[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        throw new IllegalArgumentException("Illegal monthOfYear text: " + text);
-    }
-
-    public int getMonthMaxTextLength() {
-        return iMaxMonthLength;
-    }
-
-    public int getMonthMaxShortTextLength() {
-        return iMaxShortMonthLength;
-    }
-
-    public String dayOfWeekValueToText(int value) {
-        return iDaysOfWeek[value];
-    }
-
-    public String dayOfWeekValueToShortText(int value) {
-        return iShortDaysOfWeek[value];
-    }
-
-    public int dayOfWeekTextToValue(String text) {
-        String[] daysOfWeek = iDaysOfWeek;
-        for (int i=daysOfWeek.length; --i>=1; ) {
-            if (daysOfWeek[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        daysOfWeek = iShortDaysOfWeek;
-        for (int i=daysOfWeek.length; --i>=1; ) {
-            if (daysOfWeek[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        throw new IllegalArgumentException("Illegal dayOfWeek text: " + text);
-    }
-
-    public int getDayOfWeekMaxTextLength() {
-        return iMaxDayOfWeekLength;
-    }
-
-    public int getDayOfWeekMaxShortTextLength() {
-        return iMaxShortDayOfWeekLength;
-    }
-
-    public String halfdayValueToText(int value) {
-        return iHalfday[value];
-    }
-
-    public int halfdayTextToValue(String text) {
-        String[] halfday = iHalfday;
-        for (int i = halfday.length; --i>=0; ) {
-            if (halfday[i].equalsIgnoreCase(text)) {
-                return i;
-            }
-        }
-        throw new IllegalArgumentException("Illegal halfday text: " + text);
-    }
-
-    public int getHalfdayMaxTextLength() {
-        return iMaxHalfdayLength;
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
deleted file mode 100644
index 7e1c245..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
+++ /dev/null
@@ -1,380 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the month of the year component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @version 1.0
- * @since 1.0
- */
-final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
-
-    static final long serialVersionUID = -4748157875845286249L;
-
-    private static final int MIN = DateTimeConstants.JANUARY;
-    private static final int MAX = DateTimeConstants.DECEMBER;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJMonthOfYearDateTimeField(ProlepticChronology chronology) {
-        super("monthOfYear", "months", chronology.getRoughMillisPerMonth());
-        iChronology = chronology;
-    }
-
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Get the Month component of the specified time instant.
-     *
-     * @see org.joda.time.DateTimeField#get(long)
-     * @see org.joda.time.ReadableDateTime#getMonthOfYear()
-     * @param instant  the time instant in millis to query.
-     * @return the month extracted from the input.
-     */
-    public int get(long instant) {
-        return iChronology.getMonthOfYear(instant);
-    }
-
-    public String getAsText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));
-    }
-
-    public String getAsShortText(long instant, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));
-    }
-
-    /**
-     * Add the specified month to the specified time instant.
-     * The amount added may be negative.<p>
-     * If the new month has less total days than the specified
-     * day of the month, this value is coerced to the nearest
-     * sane value. e.g.<p>
-     * 07-31 - (1 month) = 06-30<p>
-     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>
-     * 
-     * @see org.joda.time.DateTimeField#add
-     * @see org.joda.time.ReadWritableDateTime#addMonths(int)
-     * @param instant  the time instant in millis to update.
-     * @param months  the months to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int months) {
-        if (months == 0) {
-            return instant; // the easy case
-        }
-        //
-        // Save time part first.
-        //
-        long timePart = iChronology.millisOfDay().get(instant);
-        //
-        //
-        // Get this year and month.
-        //
-        int thisYear = iChronology.year().get(instant);
-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
-        // ----------------------------------------------------------
-        //
-        // Do not refactor without careful consideration.
-        // Order of calculation is important.
-        //
-        int yearToUse;
-        // Initially, monthToUse is zero-based
-        int monthToUse = thisMonth - 1 + months;
-        if (monthToUse >= 0) {
-            yearToUse = thisYear + (monthToUse / MAX);
-            monthToUse = (monthToUse % MAX) + 1;
-        } else {
-            yearToUse = thisYear + (monthToUse / MAX) - 1;
-            monthToUse = Math.abs(monthToUse);
-            int remMonthToUse = monthToUse % MAX;
-            // Take care of the boundary condition
-            if (remMonthToUse == 0) {
-                remMonthToUse = MAX;
-            }
-            monthToUse = MAX - remMonthToUse + 1;
-            // Take care of the boundary condition
-            if (monthToUse == 1) {
-                yearToUse += 1;
-            }
-        }
-        // End of do not refactor.
-        // ----------------------------------------------------------
-
-        //
-        // Quietly force DOM to nearest sane value.
-        //
-        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
-        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
-        if (dayToUse > maxDay) {
-            dayToUse = maxDay;
-        }
-        //
-        // get proper date part, and return result
-        //
-        long datePart =
-            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);
-        return datePart + timePart;
-    }
-
-    public long add(long instant, long months) {
-        int i_months = (int)months;
-        if (i_months == months) {
-            return add(instant, i_months);
-        }
-
-        // Copied from add(long, int) and modified slightly:
-
-        long timePart = iChronology.millisOfDay().get(instant);
-
-        int thisYear = iChronology.year().get(instant);
-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
-
-        long yearToUse;
-        long monthToUse = thisMonth - 1 + months;
-        if (monthToUse >= 0) {
-            yearToUse = thisYear + (monthToUse / MAX);
-            monthToUse = (monthToUse % MAX) + 1;
-        } else {
-            yearToUse = thisYear + (monthToUse / MAX) - 1;
-            monthToUse = Math.abs(monthToUse);
-            int remMonthToUse = (int)(monthToUse % MAX);
-            if (remMonthToUse == 0) {
-                remMonthToUse = MAX;
-            }
-            monthToUse = MAX - remMonthToUse + 1;
-            if (monthToUse == 1) {
-                yearToUse += 1;
-            }
-        }
-
-        if (yearToUse < iChronology.getMinYear() ||
-            yearToUse > iChronology.getMaxYear()) {
-
-            throw new IllegalArgumentException
-                ("Magnitude of add amount is too large: " + months);
-        }
-
-        int i_yearToUse = (int)yearToUse;
-        int i_monthToUse = (int)monthToUse;
-
-        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
-        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);
-        if (dayToUse > maxDay) {
-            dayToUse = maxDay;
-        }
-
-        long datePart =
-            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);
-        return datePart + timePart;
-    }
-
-    /**
-     * Add to the Month component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @see org.joda.time.DateTimeField#addWrapped
-     * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)
-     * @param instant  the time instant in millis to update.
-     * @param months  the months to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int months) {
-        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        if (minuendInstant < subtrahendInstant) {
-            return -getDifference(subtrahendInstant, minuendInstant);
-        }
-
-        DateTimeField yearField = iChronology.year();
-        int minuendYear = yearField.get(minuendInstant);
-        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);
-        int subtrahendYear = yearField.get(subtrahendInstant);
-        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);
-
-        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;
-
-        // Before adjusting for remainder, account for special case of add
-        // where the day-of-month is forced to the nearest sane value.
-        int minuendDom = iChronology.getDayOfMonth
-            (minuendInstant, minuendYear, minuendMonth);
-        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {
-            // Last day of the minuend month...
-            int subtrahendDom = iChronology.getDayOfMonth
-                (subtrahendInstant, subtrahendYear, subtrahendMonth);
-            if (subtrahendDom > minuendDom) {
-                // ...and day of subtrahend month is larger.
-                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);
-            }
-        }
-
-        // Inlined remainder method to avoid duplicate calls.
-        long minuendRem = minuendInstant
-            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);
-        long subtrahendRem = subtrahendInstant
-            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);
-
-        if (minuendRem < subtrahendRem) {
-            difference--;
-        }
-
-        return difference;
-    }
-
-    /**
-     * Set the Month component of the specified time instant.<p>
-     * If the new month has less total days than the specified
-     * day of the month, this value is coerced to the nearest
-     * sane value. e.g.<p>
-     * 07-31 to month 6 = 06-30<p>
-     * 03-31 to month 2 = 02-28 or 02-29 depending<p>
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param month  the month (1,12) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if month is invalid
-     */
-    public long set(long instant, int month) {
-        Utils.verifyValueBounds(this, month, MIN, MAX);
-        //
-        int thisYear = iChronology.year().get(instant);
-        //
-        int thisDom = iChronology.getDayOfMonth(instant, thisYear);
-        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);
-        if (thisDom > maxDom) {
-            // Quietly force DOM to nearest sane value.
-            thisDom = maxDom;
-        }
-        // Return newly calculated millis value
-        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +
-            iChronology.millisOfDay().get(instant);
-    }
-
-    public long set(long instant, String text, Locale locale) {
-        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));
-    }
-
-    public DurationField getRangeDurationField() {
-        return iChronology.years();
-    }
-
-    public boolean isLeap(long instant) {
-        int thisYear = iChronology.year().get(instant);
-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
-        if (thisMonth != 2) {
-            return false;
-        } else {
-            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);
-        }
-    }
-
-    public int getLeapAmount(long instant) {
-        return isLeap(instant) ? 1 : 0;
-    }
-
-    public DurationField getLeapDurationField() {
-        return iChronology.days();
-    }
-
-    public int getMinimumValue() {
-        return MIN;
-    }
-
-    public int getMaximumValue() {
-        return MAX;
-    }
-
-    public int getMaximumTextLength(Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();
-    }
-
-    public int getMaximumShortTextLength(Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();
-    }
-
-    public long roundFloor(long instant) {
-        int year = iChronology.year().get(instant);
-        int month = iChronology.getMonthOfYear(instant, year);
-        return iChronology.getYearMonthMillis(year, month);
-    }
-
-    public long remainder(long instant) {
-        return instant - roundFloor(instant);
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.monthOfYear();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
deleted file mode 100644
index 0b17a87..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the week of a week based year component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @version 1.0
- * @since 1.0
- */
-final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {
-
-    static final long serialVersionUID = -1587436826395135328L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology, DurationField weeks) {
-        super("weekOfWeekyear", weeks);
-        iChronology = chronology;
-    }
-
-    /**
-     * Get the week of a week based year component of the specified time instant.
-     * 
-     * @see org.joda.time.DateTimeField#get(long)
-     * @param instant  the time instant in millis to query.
-     * @return the week of the year extracted from the input.
-     */
-    public int get(long instant) {
-        int year = iChronology.year().get(instant);
-        //
-        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);
-        if (instant < firstWeekMillis1) {
-            return iChronology.getWeeksInYear(year - 1);
-        }
-        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);
-        if (instant >= firstWeekMillis2) {
-            return 1;
-        }
-        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
-    }
-
-    public DurationField getRangeDurationField() {
-        return iChronology.weekyears();
-    }
-
-    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to
-    // apply a corrective alignment since weeks begin on day of week 1, Monday.
-
-    public long roundFloor(long instant) {
-        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
-            - 3 * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long roundCeiling(long instant) {
-        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
-            - 3 * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long remainder(long instant) {
-        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);
-    }
-
-    public int getMinimumValue() {
-        return 1;
-    }
-
-    public int getMaximumValue() {
-        return 53;
-    }
-
-    public int getMaximumValue(long instant) {
-        int thisYear = iChronology.weekyear().get(instant);
-        return iChronology.getWeeksInYear(thisYear);
-    }
-
-    protected int getMaximumValueForSet(long instant, int value) {
-        return value > 52 ? getMaximumValue(instant) : 52;
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.weekOfWeekyear();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
deleted file mode 100644
index e906320..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the week of the weekyear component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @version 1.0
- * @since 1.0
- * @see org.joda.time.DateTimeField
- */
-final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {
-    
-    static final long serialVersionUID = 6215066916806820644L;
-
-    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJWeekyearDateTimeField(ProlepticChronology chronology) {
-        super("weekyear", "weekyears", chronology.getRoughMillisPerYear());
-        iChronology = chronology;
-    }
-
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Get the Year of a week based year component of the specified time instant.
-     * 
-     * @see org.joda.time.DateTimeField#get
-     * @param instant  the time instant in millis to query.
-     * @return the year extracted from the input.
-     */
-    public int get(long instant) {
-        int week = iChronology.weekOfWeekyear().get(instant);
-        if (week == 1) {
-            return iChronology.year().get(instant + DateTimeConstants.MILLIS_PER_WEEK);
-        } else if (week > 51) {
-            return iChronology.year().get(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));
-        } else {
-            return iChronology.year().get(instant);
-        }
-    }
-
-    /**
-     * Add the specified years to the specified time instant.
-     * 
-     * @see org.joda.time.DateTimeField#add
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int years) {
-        if (years == 0) {
-            return instant;
-        }
-        return set(instant, get(instant) + years);
-    }
-
-    public long add(long instant, long value) {
-        return add(instant, Utils.safeToInt(value));
-    }
-
-    /**
-     * Add to the year component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @see org.joda.time.DateTimeField#addWrapped
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int years) {
-        return add(instant, years);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        if (minuendInstant < subtrahendInstant) {
-            return -getDifference(subtrahendInstant, minuendInstant);
-        }
-
-        int minuendWeekyear = get(minuendInstant);
-        int subtrahendWeekyear = get(subtrahendInstant);
-
-        long minuendRem = remainder(minuendInstant);
-        long subtrahendRem = remainder(subtrahendInstant);
-
-        // Balance leap weekyear differences on remainders.
-        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {
-            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;
-        }
-
-        int difference = minuendWeekyear - subtrahendWeekyear;
-        if (minuendRem < subtrahendRem) {
-            difference--;
-        }
-        return difference;
-    }
-
-    /**
-     * Set the Year of a week based year component of the specified time instant.
-     *
-     * @see org.joda.time.DateTimeField#set
-     * @param instant  the time instant in millis to update.
-     * @param year  the year (-9999,9999) to set the date to.
-     * @return the updated DateTime.
-     * @throws IllegalArgumentException  if year is invalid.
-     */
-    public long set(long instant, int year) {
-        Utils.verifyValueBounds(this, Math.abs(year),
-                                iChronology.getMinYear(), iChronology.getMaxYear());
-        //
-        // Do nothing if no real change is requested.
-        //
-        int thisWeekyear = get( instant );
-        if ( thisWeekyear == year ) {
-            return instant;
-        }
-        //
-        // Calculate the DayOfWeek (to be preserved).
-        //
-        int thisDow = iChronology.dayOfWeek().get( instant );
-        //
-        // Calculate the maximum weeks in the target year.
-        //
-        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );
-        int weeksInToYear = iChronology.getWeeksInYear( year );
-        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?
-            weeksInToYear : weeksInFromYear;
-        //
-        // Get the current week of the year. This will be preserved in
-        // the output unless it is greater than the maximum possible
-        // for the target weekyear.  In that case it is adjusted
-        // to the maximum possible.
-        //
-        int setToWeek = iChronology.weekOfWeekyear().get( instant );
-        if ( setToWeek > maxOutWeeks ) {
-            setToWeek = maxOutWeeks;
-        }
-        //
-        // Get a wroking copy of the current date-time.
-        // This can be a convenience for debugging.
-        //
-        long workInstant = instant; // Get a copy
-        //
-        // Attempt to get close to the proper weekyear.
-        // Note - we cannot currently call ourself, so we just call
-        // set for the year.  This at least gets us close.
-        //
-        workInstant = iChronology.year().set( workInstant, year );
-        //
-        // Calculate the weekyear number for the get close to value
-        // (which might not be equal to the year just set).
-        //
-        int workWoyYear = iChronology.weekyear().get( workInstant );
-
-        //
-        // At most we are off by one year, which can be "fixed" by
-        // adding/subtracting a week.
-        //
-        if ( workWoyYear < year ) {
-            workInstant += DateTimeConstants.MILLIS_PER_WEEK;
-        } else if ( workWoyYear > year ) {
-            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;
-        }
-        //
-        // Set the proper week in the current weekyear.
-        //
-
-        // BEGIN: possible set WeekOfWeekyear logic.
-        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );
-        // No range check required (we already know it is OK).
-        workInstant = workInstant + (setToWeek - currentWoyWeek)
-            * (long)DateTimeConstants.MILLIS_PER_WEEK;
-        // END: possible set WeekOfWeekyear logic.
-
-        //
-        // Reset DayOfWeek to previous value.
-        //
-        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );
-        //
-        // Return result.
-        //
-        return workInstant;
-    }
-
-    public DurationField getRangeDurationField() {
-        return null;
-    }
-
-    public boolean isLeap(long instant) {
-        return iChronology.weekOfWeekyear().getMaximumValue(instant) > 52;
-    }
-
-    public int getLeapAmount(long instant) {
-        return iChronology.weekOfWeekyear().getMaximumValue(instant) - 52;
-    }
-
-    public DurationField getLeapDurationField() {
-        return iChronology.weeks();
-    }
-
-    public int getMinimumValue() {
-        return iChronology.getMinYear();
-    }
-
-    public int getMaximumValue() {
-        return iChronology.getMaxYear();
-    }
-
-    public long roundFloor(long instant) {
-        DateTimeField wowField = iChronology.weekOfWeekyear();
-        instant = wowField.roundFloor(instant);
-        int wow = wowField.get(instant);
-        if (wow > 1) {
-            instant = wowField.add(instant, 1 - wow);
-        }
-        return instant;
-    }
-
-    public long remainder(long instant) {
-        return instant - roundFloor(instant);
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.weekyear();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
deleted file mode 100644
index db32b46..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the year component of time.
- *
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-final class GJYearDateTimeField extends ImpreciseDateTimeField {
-
-    static final long serialVersionUID = -679076949530018869L;
-
-    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor
-     */
-    GJYearDateTimeField(ProlepticChronology chronology) {
-        super("year", "years", chronology.getRoughMillisPerYear());
-        iChronology = chronology;
-    }
-
-    public boolean isLenient() {
-        return false;
-    }
-
-    /**
-     * Get the Year component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the year extracted from the input.
-     */
-    public int get(long instant) {
-        // Get an initial estimate of the year, and the millis value that
-        // represents the start of that year. Then verify estimate and fix if
-        // necessary.
-
-        int year;
-
-        long unitMillis = getDurationUnitMillis();
-        if (instant >= 0) {
-            year = 1970 + (int) (instant / unitMillis);
-        } else {
-            year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis);
-        }
-
-        long yearStart = iChronology.getYearMillis(year);
-        if ((yearStart ^ instant) < 0) {
-            // Sign mismatch, operation overflowed.
-            return getOverflow(instant);
-        }
-
-        long diff = instant - yearStart;
-
-        if (diff < 0) {
-            // Subtract one year to fix estimate.
-            year--;
-        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {
-            // One year may need to be added to fix estimate.
-            long oneYear;
-            if (iChronology.isLeapYear(year)) {
-                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;
-            } else {
-                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;
-            }
-
-            yearStart += oneYear;
-            if ((yearStart ^ instant) < 0) {
-                // Sign mismatch, operation overflowed.
-                return getOverflow(instant);
-            }
-
-            if (yearStart <= instant) {
-                // Didn't go too far, so actually add one year.
-                year++;
-            }
-        }
-
-        return year;
-    }
-
-    private int getOverflow(long instant) {
-        if (instant > 0) {
-            int year = iChronology.getMaxYear();
-            long yearStartMillis = iChronology.getYearMillis(year);
-            if (iChronology.isLeapYear(year)) {
-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
-            } else {
-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
-            }
-            long yearEndMillis = yearStartMillis - 1;
-
-            if (instant <= yearEndMillis) {
-                return year;
-            }
-
-            throw new IllegalArgumentException
-                ("Instant too large: " + instant + " > " + yearEndMillis);
-        } else {
-            int year = iChronology.getMinYear();
-            long yearStartMillis = iChronology.getYearMillis(year);
-            if (instant >= yearStartMillis) {
-                return year;
-            }
-
-            throw new IllegalArgumentException
-                ("Instant too small: " + instant + " < " + yearStartMillis);
-        }
-    }
-
-    /**
-     * Add the specified year to the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int years) {
-        if (years == 0) {
-            return instant;
-        }
-        int thisYear = get(instant);
-        int newYear = thisYear + years;
-        return set(instant, newYear);
-    }
-
-    public long add(long instant, long years) {
-        return add(instant, Utils.safeToInt(years));
-    }
-
-    /**
-     * Add to the Year component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int years) {
-        if (years == 0) {
-            return instant;
-        }
-        // Return newly calculated millis value
-        int thisYear = iChronology.year().get(instant);
-        int wrappedYear = Utils.getWrappedValue
-            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());
-        return set(instant, wrappedYear);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        if (minuendInstant < subtrahendInstant) {
-            return -getDifference(subtrahendInstant, minuendInstant);
-        }
-
-        int minuendYear = get(minuendInstant);
-        int subtrahendYear = get(subtrahendInstant);
-
-        // Inlined remainder method to avoid duplicate calls to get.
-        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);
-        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);
-
-        // Balance leap year differences on remainders.
-        if (subtrahendRem >= FEB_29) {
-            if (iChronology.isLeapYear(subtrahendYear)) {
-                if (!iChronology.isLeapYear(minuendYear)) {
-                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;
-                }
-            } else if (minuendRem >= FEB_29 && iChronology.isLeapYear(minuendYear)) {
-                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;
-            }
-        }
-
-        int difference = minuendYear - subtrahendYear;
-        if (minuendRem < subtrahendRem) {
-            difference--;
-        }
-        return difference;
-    }
-
-    /**
-     * Set the Year component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param year  the year (-292269055,292278994) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if year is invalid.
-     */
-    public long set(long instant, int year) {
-        Utils.verifyValueBounds
-            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());
-
-        int dayOfYear = iChronology.dayOfYear().get(instant);
-        int millisOfDay = iChronology.millisOfDay().get(instant);
-
-        if (dayOfYear > (31 + 28)) { // after Feb 28
-            if (isLeap(instant)) {
-                // Old date is Feb 29 or later.
-                if (!iChronology.isLeapYear(year)) {
-                    // Moving to a non-leap year, Feb 29 does not exist.
-                    dayOfYear--;
-                }
-            } else {
-                // Old date is Mar 01 or later.
-                if (iChronology.isLeapYear(year)) {
-                    // Moving to a leap year, account for Feb 29.
-                    dayOfYear++;
-                }
-            }
-        }
-
-        instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);
-        instant += millisOfDay;
-
-        return instant;
-    }
-
-    public DurationField getRangeDurationField() {
-        return null;
-    }
-
-    public boolean isLeap(long instant) {
-        return iChronology.isLeapYear(get(instant));
-    }
-
-    public int getLeapAmount(long instant) {
-        if (iChronology.isLeapYear(get(instant))) {
-            return 1;
-        } else {
-            return 0;
-        }
-    }
-
-    public DurationField getLeapDurationField() {
-        return iChronology.days();
-    }
-
-    public int getMinimumValue() {
-        return iChronology.getMinYear();
-    }
-
-    public int getMaximumValue() {
-        return iChronology.getMaxYear();
-    }
-
-    public long roundFloor(long instant) {
-        return iChronology.getYearMillis(get(instant));
-    }
-
-    public long roundCeiling(long instant) {
-        int year = get(instant);
-        long yearStartMillis = iChronology.getYearMillis(year);
-        if (instant != yearStartMillis) {
-            // Bump up to start of next year.
-            instant = iChronology.getYearMillis(year + 1);
-        }
-        return instant;
-    }
-
-    public long remainder(long instant) {
-        return instant - roundFloor(instant);
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.year();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
deleted file mode 100644
index 245df78..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.chrono.DecoratedDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Provides time calculations for the year of era component of time.
- * 
- * @author Brian S O'Neill
- */
-final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {
-
-    static final long serialVersionUID = -5961050944769862059L;
-
-    private final ProlepticChronology iChronology;
-
-    /**
-     * Restricted constructor.
-     */
-    GJYearOfEraDateTimeField(DateTimeField yearField, ProlepticChronology chronology) {
-        super(yearField, "yearOfEra");
-        iChronology = chronology;
-    }
-
-    /**
-     * Get the year of era component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the year of era extracted from the input.
-     */
-    public int get(long instant) {
-        int year = getWrappedField().get(instant);
-        if (year <= 0) {
-            year = 1 - year;
-        }
-        return year;
-    }
-
-    /**
-     * Add the specified year to the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int years) {
-        return getWrappedField().add(instant, years);
-    }
-
-    public long add(long instant, long years) {
-        return getWrappedField().add(instant, years);
-    }
-
-    /**
-     * Add to the year component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int years) {
-        return getWrappedField().addWrapped(instant, years);
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Set the year component of the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param year  the year (0,292278994) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if year is invalid.
-     */
-    public long set(long instant, int year) {
-        Utils.verifyValueBounds(this, year, 1, getMaximumValue());
-        if (iChronology.era().get(instant) == DateTimeConstants.BCE) {
-            return super.set(instant, 1 - year);
-        } else {
-            return super.set(instant, year);
-        }
-    }
-
-    public int getMinimumValue() {
-        return 1;
-    }
-
-    public int getMaximumValue() {
-        return getWrappedField().getMaximumValue();
-    }
-
-    public long roundFloor(long instant) {
-        return getWrappedField().roundFloor(instant);
-    }
-
-    public long roundCeiling(long instant) {
-        return getWrappedField().roundCeiling(instant);
-    }
-
-    public long remainder(long instant) {
-        return getWrappedField().remainder(instant);
-    }
-
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return iChronology.yearOfEra();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
deleted file mode 100644
index 36ff452..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.ZonedChronology;
-
-/**
- * A special zoned chronology for the GJ chronology.
- * 
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-final class GJZonedChronology extends GJChronology {
-
-    static final long serialVersionUID = -4148749408058922172L;
-
-    private final GJChronology iChronology;
-    private final DateTimeZone iZone;
-    private final ZonedChronology iZonedChronology;
-
-    GJZonedChronology(GJChronology chrono, DateTimeZone zone) {
-        iChronology = chrono;
-        iZone = zone;
-        copyFields(iZonedChronology = new ZonedChronology(chrono, zone));
-    }
-
-    public DateTimeZone getDateTimeZone() {
-        return iZone;
-    }
-
-    public Chronology withUTC() {
-        return iChronology;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                        int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-
-    public boolean isCenturyISO() {
-        return iChronology.isCenturyISO();
-    }
-
-    public int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
deleted file mode 100644
index 314afcf..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-
-/**
- * 
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- */
-final class GregorianChronology extends ProlepticChronology {
-
-    static final long serialVersionUID = 3691407383323710523L;
-
-    GregorianChronology(int minDaysInFirstWeek) {
-        super(minDaysInFirstWeek);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return Long.MIN_VALUE;
-    }
-    
-    public boolean isLeapYear(int year) {
-        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);
-    }
-
-    protected long calculateFirstDayOfYearMillis(int year) {
-        // Calculate relative to 2000 as that is on a 400 year boundary
-        // and that makes the sum easier
-        int relativeYear = year - 2000;
-        // Initial value is just temporary.
-        int leapYears = relativeYear / 100;
-        if (relativeYear <= 0) {
-            // Add 3 before shifting right since /4 and >>2 behave differently
-            // on negative numbers. When the expression is written as
-            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),
-            // it works for both positive and negative values, except this optimization
-            // eliminates two divisions.
-            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);
-        } else {
-            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);
-            // For post 2000 an adjustment is needed as jan1st is before leap day
-            if (!isLeapYear(year)) {
-                leapYears++;
-            }
-        }
-        
-        long millis = (relativeYear * 365L + leapYears)
-            * (long)DateTimeConstants.MILLIS_PER_DAY;
-        
-        // Previous line was reduced from this to eliminate a multiplication.
-        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;
-        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y
-        
-        return millis + MILLIS_1970_TO_2000;
-    }
-
-    protected int getMinYear() {
-        // The lowest year that can be fully supported.
-        return -292275054;
-    }
-
-    protected int getMaxYear() {
-        // The highest year that can be fully supported.
-        return 292278993;
-    }
-
-    protected long getRoughMillisPerYear() {
-        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);
-    }
-
-    protected long getRoughMillisPerMonth() {
-        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
deleted file mode 100644
index df4c568..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.chrono.DelegatedDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Year zero is dropped from the year and weekyear fields.
- *
- * @author Brian S O'Neill
- */
-final class JulianChronology extends GJChronology {
-
-    static final long serialVersionUID = -8731039522547897247L;
-
-    private final JulianWithYearZeroChronology iChronology;
-
-    /**
-     * @param chrono wrapped chronology
-     */
-    JulianChronology(int minDaysInFirstWeek) {
-        JulianWithYearZeroChronology chrono =
-            new JulianWithYearZeroChronology(minDaysInFirstWeek);
-        iChronology = chrono;
-        copyFields(chrono);
-
-        // Override only the fields that differ.
-
-        iYearField = new NoYearZeroField(chrono.year());
-        iWeekyearField = new NoWeekyearZeroField(chrono.weekyear());
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-
-    public boolean isCenturyISO() {
-        return iChronology.isCenturyISO();
-    }
-
-    public int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-
-    int adjustYearForSet(int year) {
-        if (year <= 0) {
-            if (year == 0) {
-                throw new IllegalArgumentException("Invalid year: " + year);
-            }
-            year++;
-        }
-        return year;
-    }
-
-    private class NoYearZeroField extends DelegatedDateTimeField {
-        static final long serialVersionUID = -8869148464118507846L;
-
-        private transient int iMinYear;
-
-        NoYearZeroField(DateTimeField field) {
-            super(field);
-            iMinYear = super.getMinimumValue() - 1;
-        }
-        
-        public int get(long millis) {
-            int year = super.get(millis);
-            if (year <= 0) {
-                year--;
-            }
-            return year;
-        }
-
-        public long set(long millis, int year) {
-            Utils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
-            return super.set(millis, adjustYearForSet(year));
-        }
-
-        public int getMinimumValue() {
-            return iMinYear;
-        }
-
-        private Object readResolve() {
-            return JulianChronology.this.year();
-        }
-    }
-
-    private final class NoWeekyearZeroField extends NoYearZeroField {
-        static final long serialVersionUID = -5013429014495501104L;
-
-        NoWeekyearZeroField(DateTimeField field) {
-            super(field);
-        }
-        
-        private Object readResolve() {
-            return JulianChronology.this.weekyear();
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
deleted file mode 100644
index 56c3d40..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-
-/**
- * JulianWithZeroChronology includes year zero to simplify implementation.
- * 
- * @author Guy Allard
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- */
-final class JulianWithYearZeroChronology extends ProlepticChronology {
-
-    static final long serialVersionUID = 9044685826106463217L;
-
-    JulianWithYearZeroChronology(int minDaysInFirstWeek) {
-        super(minDaysInFirstWeek);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return Long.MAX_VALUE;
-    }
-
-    public boolean isLeapYear(int year) {
-        return (year & 3) == 0;
-    }
-
-    protected long calculateFirstDayOfYearMillis(int year) {
-        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.
-        // Calculate relative to the nearest leap year and account for the
-        // difference later.
-
-        int relativeYear = year - 1968;
-        int leapYears;
-        if (relativeYear <= 0) {
-            // Add 3 before shifting right since /4 and >>2 behave differently
-            // on negative numbers.
-            leapYears = (relativeYear + 3) >> 2;
-        } else {
-            leapYears = relativeYear >> 2;
-            // For post 1968 an adjustment is needed as jan1st is before leap day
-            if (!isLeapYear(year)) {
-                leapYears++;
-            }
-        }
-        
-        long millis = (relativeYear * 365L + leapYears)
-            * (long)DateTimeConstants.MILLIS_PER_DAY;
-
-        // Adjust to account for difference between 1968-01-01 and 1969-12-19.
-
-        return millis - (366L + 365 - 13) * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    protected int getMinYear() {
-        // The lowest year that can be fully supported.
-        return -292269053;
-    }
-
-    protected int getMaxYear() {
-        // The highest year that can be fully supported.
-        return 292272992;
-    }
-
-    protected long getRoughMillisPerYear() {
-        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
-    }
-
-    protected long getRoughMillisPerMonth() {
-        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
deleted file mode 100644
index 486737a..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
+++ /dev/null
@@ -1,595 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.util.Locale;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.NonZeroDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.PreciseDateTimeField;
-import org.joda.time.chrono.PreciseDurationField;
-import org.joda.time.chrono.Utils;
-
-/**
- * ProlepticChronology uses a consistent set of rules for all dates and
- * times. Year zero is included.
- *
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-abstract class ProlepticChronology extends GJChronology {
-
-    static final long serialVersionUID = 541866437970475456L;
-
-    static final long MILLIS_1970_TO_2000 = 946684800000L;
-
-    // These arrays are NOT public. We trust ourselves not to alter the array.
-    // They use zero-based array indexes so the that valid range of months is
-    // automatically checked.
-
-    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {
-        31,28,31,30,31,30,31,31,30,31,30,31
-    };
-
-    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {
-        31,29,31,30,31,30,31,31,30,31,30,31
-    };
-
-    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;
-    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;
-
-    private static final DurationField cMillisField;
-    private static final DurationField cSecondsField;
-    private static final DurationField cMinutesField;
-    private static final DurationField cHoursField;
-    private static final DurationField cHalfdaysField;
-    private static final DurationField cDaysField;
-    private static final DurationField cWeeksField;
-
-    private static final DateTimeField cMillisOfSecondField;
-    private static final DateTimeField cMillisOfDayField;
-    private static final DateTimeField cSecondOfMinuteField;
-    private static final DateTimeField cSecondOfDayField;
-    private static final DateTimeField cMinuteOfHourField;
-    private static final DateTimeField cMinuteOfDayField;
-    private static final DateTimeField cHourOfDayField;
-    private static final DateTimeField cHourOfHalfdayField;
-    private static final DateTimeField cClockhourOfDayField;
-    private static final DateTimeField cClockhourOfHalfdayField;
-    private static final DateTimeField cHalfdayOfDayField;
-
-    static {
-        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];
-        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];
-
-        long minSum = 0;
-        long maxSum = 0;
-        for (int i=0; i<12; i++) {
-            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]
-                * (long)DateTimeConstants.MILLIS_PER_DAY;
-            minSum += millis;
-            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;
-
-            millis = MAX_DAYS_PER_MONTH_ARRAY[i]
-                * (long)DateTimeConstants.MILLIS_PER_DAY;
-            maxSum += millis;
-            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;
-        }
-
-        cMillisField = MillisDurationField.INSTANCE;
-        cSecondsField = new PreciseDurationField
-            ("seconds", DateTimeConstants.MILLIS_PER_SECOND);
-        cMinutesField = new PreciseDurationField
-            ("minutes", DateTimeConstants.MILLIS_PER_MINUTE);
-        cHoursField = new PreciseDurationField
-            ("hours", DateTimeConstants.MILLIS_PER_HOUR);
-        cHalfdaysField = new PreciseDurationField
-            ("halfdays", DateTimeConstants.MILLIS_PER_DAY / 2);
-        cDaysField = new PreciseDurationField
-            ("days", DateTimeConstants.MILLIS_PER_DAY);
-        cWeeksField = new PreciseDurationField
-            ("weeks", DateTimeConstants.MILLIS_PER_WEEK);
-
-        cMillisOfSecondField = new PreciseDateTimeField
-            ("millisOfSecond", cMillisField, cSecondsField);
-
-        cMillisOfDayField = new PreciseDateTimeField
-            ("millisOfDay", cMillisField, cDaysField);
-             
-        cSecondOfMinuteField = new PreciseDateTimeField
-            ("secondOfMinute", cSecondsField, cMinutesField);
-
-        cSecondOfDayField = new PreciseDateTimeField
-            ("secondOfDay", cSecondsField, cDaysField);
-
-        cMinuteOfHourField = new PreciseDateTimeField
-            ("minuteOfHour", cMinutesField, cHoursField);
-
-        cMinuteOfDayField = new PreciseDateTimeField
-            ("minuteOfDay", cMinutesField, cDaysField);
-
-        cHourOfDayField = new PreciseDateTimeField
-            ("hourOfDay", cHoursField, cDaysField);
-
-        cHourOfHalfdayField = new PreciseDateTimeField
-            ("hourOfHalfday", cHoursField, cHalfdaysField);
-
-        cClockhourOfDayField = new NonZeroDateTimeField
-            (cHourOfDayField, "clockhourOfDay");
-
-        cClockhourOfHalfdayField = new NonZeroDateTimeField
-            (cHourOfHalfdayField, "clockhourOfHalfday");
-
-        cHalfdayOfDayField = new HalfdayField();
-    }
-
-    private transient YearInfo[] iYearInfoCache;
-    private transient int iYearInfoCacheMask;
-
-    private final int iMinDaysInFirstWeek;
-
-    ProlepticChronology(int minDaysInFirstWeek) {
-        super();
-        iMinDaysInFirstWeek = minDaysInFirstWeek;
-
-        Integer i;
-        try {
-            i = Integer.getInteger("org.joda.time.gj.ProlepticChronology.yearInfoCacheSize");
-        } catch (SecurityException e) {
-            i = null;
-        }
-
-        int cacheSize;
-        if (i == null) {
-            cacheSize = 1024; // (1 << 10)
-        } else {
-            cacheSize = i.intValue();
-            // Ensure cache size is even power of 2.
-            cacheSize--;
-            int shift = 0;
-            while (cacheSize > 0) {
-                shift++;
-                cacheSize >>= 1;
-            }
-            cacheSize = 1 << shift;
-        }
-
-        iYearInfoCache = new YearInfo[cacheSize];
-        iYearInfoCacheMask = cacheSize - 1;
-
-        // First copy fields that are the same for all Gregorian and Julian
-        // chronologies.
-
-        iMillisField = cMillisField;
-        iSecondsField = cSecondsField;
-        iMinutesField = cMinutesField;
-        iHoursField = cHoursField;
-        //iHalfdaysField = cHalfdaysField;  Doesn't exist in public interface
-        iDaysField = cDaysField;
-        iWeeksField = cWeeksField;
-
-        iMillisOfSecondField = cMillisOfSecondField;
-        iMillisOfDayField = cMillisOfDayField;
-        iSecondOfMinuteField = cSecondOfMinuteField;
-        iSecondOfDayField = cSecondOfDayField;
-        iMinuteOfHourField = cMinuteOfHourField;
-        iMinuteOfDayField = cMinuteOfDayField;
-        iHourOfDayField = cHourOfDayField;
-        iHourOfHalfdayField = cHourOfHalfdayField;
-        iClockhourOfDayField = cClockhourOfDayField;
-        iClockhourOfHalfdayField = cClockhourOfHalfdayField;
-        iHalfdayOfDayField = cHalfdayOfDayField;
-
-        // Now create fields that have unique behavior for Gregorian and Julian
-        // chronologies.
-
-        iYearField = new GJYearDateTimeField(this);
-        iYearOfEraField = new GJYearOfEraDateTimeField(iYearField, this);
-
-        iCenturyOfEraField = new DividedDateTimeField
-            (iYearOfEraField, "centuryOfEra", "centuries", 100);
-        iYearOfCenturyField = new RemainderDateTimeField
-            ((DividedDateTimeField)iCenturyOfEraField, "yearOfCentury");
-
-        iEraField = new GJEraDateTimeField(this);
-        iDayOfWeekField = new GJDayOfWeekDateTimeField(this, iDaysField);
-        iDayOfMonthField = new GJDayOfMonthDateTimeField(this, iDaysField);
-        iDayOfYearField = new GJDayOfYearDateTimeField(this, iDaysField);
-        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);
-        iWeekyearField = new GJWeekyearDateTimeField(this);
-        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this, iWeeksField);
-
-        // The remaining (imprecise) durations are available from the newly
-        // created datetime fields.
-
-        iYearsField = iYearField.getDurationField();
-        iCenturiesField = iCenturyOfEraField.getDurationField();
-        iMonthsField = iMonthOfYearField.getDurationField();
-        iWeekyearsField = iWeekyearField.getDurationField();
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    /**
-     * Override the default implementation
-     */
-    public final long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        boolean isLeap = isLeapYear(year);
-
-        Utils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
-        Utils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
-                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)
-                                [monthOfYear - 1]);
-
-        long instant = getYearMillis(year);
-
-        if (monthOfYear > 1) {
-            instant += 
-                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)
-                [monthOfYear - 2];
-        }
-
-        if (dayOfMonth != 1) {
-            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
-        }
-
-        return instant;
-    }
-
-    /**
-     * Override the default implementation
-     */
-    public final long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-
-        Utils.verifyValueBounds("hourOfDay", hourOfDay, 0, 23);
-        Utils.verifyValueBounds("minuteOfHour", minuteOfHour, 0, 59);
-        Utils.verifyValueBounds("secondOfMinute", secondOfMinute, 0, 59);
-        Utils.verifyValueBounds("millisOfSecond", millisOfSecond, 0, 999);
-
-        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
-            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
-            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
-            + millisOfSecond;
-    }
-
-    /**
-     * Override the default implementation
-     */
-    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                        int millisOfDay)
-        throws IllegalArgumentException
-    {
-        Utils.verifyValueBounds("millisOfDay", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
-        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
-    }
-
-    /**
-     * Override the default implementation
-     */
-    public final long getDateTimeMillis(long instant,
-                                        int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return getDateOnlyMillis(instant)
-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    /**
-     * Override the default implementation
-     */
-    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                        int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)
-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public final boolean isCenturyISO() {
-        return true;
-    }
-
-    public final int getMinimumDaysInFirstWeek() {
-        return iMinDaysInFirstWeek;
-    }
-
-    /**
-     * Get the number of days in the year.
-     * @param year The year to use.
-     * @return 366 if a leap year, otherwise 365.
-     */
-    public final int getDaysInYear(int year) {
-        return isLeapYear(year) ? 366 : 365;
-    }
-
-    public final int getDaysInYearMonth(int year, int month) {
-        if (isLeapYear(year)) {
-            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];
-        } else {
-            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];
-        }
-    }
-
-    /**
-     * Returns the total number of milliseconds elapsed in the year, by the end
-     * of the month.
-     */
-    public final long getTotalMillisByYearMonth(int year, int month) {
-        if (isLeapYear(year)) {
-            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];
-        } else {
-            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];
-        }
-    }
-
-    /**
-     * Get the number of weeks in the year.
-     * @param year  the year to use.
-     * @return number of weeks in the year.
-     */
-    public final int getWeeksInYear(int year) {
-        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);
-        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);
-        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);
-    }
-
-    /**
-     * Get the millis for the first week of a year.
-     * @param year  the year to use.
-     * @return millis
-     */
-    public final long getFirstWeekOfYearMillis(int year) {
-        long jan1millis = getYearMillis(year);
-        int jan1dayOfWeek = dayOfWeek().get(jan1millis);
-        
-        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {
-            // First week is end of previous year because it doesn't have enough days.
-            return jan1millis + (8 - jan1dayOfWeek)
-                * (long)DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            // First week is start of this year because it has enough days.
-            return jan1millis - (jan1dayOfWeek - 1)
-                * (long)DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    /**
-     * Get the milliseconds for the start of a year.
-     *
-     * @param year The year to use.
-     * @return millis from 1970-01-01T00:00:00Z
-     */
-    public final long getYearMillis(int year) {
-        return getYearInfo(year).iFirstDayMillis;
-        //return calculateFirstDayOfYearMillis(year);
-    }
-
-    /**
-     * Get the milliseconds for the start of a month.
-     *
-     * @param year The year to use.
-     * @param month The month to use
-     * @return millis from 1970-01-01T00:00:00Z
-     */
-    public final long getYearMonthMillis(int year, int month) {
-        long millis = getYearMillis(year);
-        // month
-        if (month > 1) {
-            millis += getTotalMillisByYearMonth(year, month - 1);
-        }
-        return millis;
-    }
-
-    /**
-     * Get the milliseconds for a particular date.
-     *
-     * @param year The year to use.
-     * @param month The month to use
-     * @param dayOfMonth The day of the month to use
-     * @return millis from 1970-01-01T00:00:00Z
-     */
-    public final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {
-        long millis = getYearMillis(year);
-        // month
-        if (month > 1) {
-            millis += getTotalMillisByYearMonth(year, month - 1);
-        }
-        // day
-        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-    
-    /**
-     * @param millis from 1970-01-01T00:00:00Z
-     */
-    public final int getMonthOfYear(long millis) {
-        return getMonthOfYear(millis, year().get(millis));
-    }
-
-    /**
-     * @param millis from 1970-01-01T00:00:00Z
-     * @param year precalculated year of millis
-     */
-    public final int getMonthOfYear(long millis, int year) {
-        // Perform a binary search to get the month. To make it go even faster,
-        // compare using ints instead of longs. The number of milliseconds per
-        // year exceeds the limit of a 32-bit int's capacity, so divide by
-        // 1024. No precision is lost (except time of day) since the number of
-        // milliseconds per day contains 1024 as a factor. After the division,
-        // the instant isn't measured in milliseconds, but in units of
-        // (128/125)seconds.
-
-        int i = (int)((millis - getYearMillis(year)) >> 10);
-
-        // There are 86400000 milliseconds per day, but divided by 1024 is
-        // 84375. There are 84375 (128/125)seconds per day.
-
-        return
-            (isLeapYear(year))
-            ? ((i < 182 * 84375)
-               ? ((i < 91 * 84375)
-                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)
-                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))
-               : ((i < 274 * 84375)
-                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)
-                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))
-            : ((i < 181 * 84375)
-               ? ((i < 90 * 84375)
-                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)
-                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))
-               : ((i < 273 * 84375)
-                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)
-                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));
-    }
-
-    /**
-     * @param millis from 1970-01-01T00:00:00Z
-     */
-    public final int getDayOfMonth(long millis) {
-        int year = year().get(millis);
-        int month = getMonthOfYear(millis, year);
-        return getDayOfMonth(millis, year, month);
-    }
-
-    /**
-     * @param millis from 1970-01-01T00:00:00Z
-     * @param year precalculated year of millis
-     */
-    public final int getDayOfMonth(long millis, int year) {
-        int month = getMonthOfYear(millis, year);
-        return getDayOfMonth(millis, year, month);
-    }
-
-    /**
-     * @param millis from 1970-01-01T00:00:00Z
-     * @param year precalculated year of millis
-     * @param month precalculated month of millis
-     */
-    public final int getDayOfMonth(long millis, int year, int month) {
-        long dateMillis = getYearMillis(year);
-        if (month > 1) {
-            dateMillis += getTotalMillisByYearMonth(year, month - 1);
-        }
-        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;
-    }
-
-    public abstract boolean isLeapYear(int year);
-
-    protected abstract long calculateFirstDayOfYearMillis(int year);
-
-    protected abstract int getMinYear();
-
-    protected abstract int getMaxYear();
-
-    protected abstract long getRoughMillisPerYear();
-
-    protected abstract long getRoughMillisPerMonth();
-
-    // Although accessed by multiple threads, this method doesn't need to be synchronized.
-    private YearInfo getYearInfo(int year) {
-        YearInfo[] cache = iYearInfoCache;
-        int index = year & iYearInfoCacheMask;
-        YearInfo info = cache[index];
-        if (info == null || info.iYear != year) {
-            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));
-            cache[index] = info;
-        }
-        return info;
-    }
-
-    private static class HalfdayField extends PreciseDateTimeField {
-        static final long serialVersionUID = 581601443656929254L;
-
-        HalfdayField() {
-            super("halfdayOfDay", cHalfdaysField, cDaysField);
-        }
-
-        public String getAsText(long millis, Locale locale) {
-            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));
-        }
-
-        public long set(long millis, String text, Locale locale) {
-            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));
-        }
-
-        public int getMaximumTextLength(Locale locale) {
-            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();
-        }
-    }
-
-    private static class YearInfo {
-        public final int iYear;
-        public final long iFirstDayMillis;
-
-        YearInfo(int year, long firstDayMillis) {
-            iYear = year;
-            iFirstDayMillis = firstDayMillis;
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/package.html b/JodaTime/src/java/org/joda/time/chrono/gj/package.html
deleted file mode 100644
index 13ad62c..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/package.html
+++ /dev/null
@@ -1,74 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-<title>org.joda.time.chrono.gj package</title>
-<!--
-
-   Joda Software License, Version 1.0
-  
-  
-   Copyright (c) 2001-03 Stephen Colebourne.
-   All rights reserved.
-  
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-  
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-  
-   3. The end-user documentation included with the redistribution,
-      if any, must include the following acknowledgment:
-         "This product includes software developed by the
-          Joda project (http://www.joda.org/)."
-      Alternately, this acknowledgment may appear in the software itself,
-      if and wherever such third-party acknowledgments normally appear.
-  
-   4. The name "Joda" must not be used to endorse or promote products
-      derived from this software without prior written permission. For
-      written permission, please contact licence@joda.org.
-  
-   5. Products derived from this software may not be called "Joda",
-      nor may "Joda" appear in their name, without prior written
-      permission of the Joda project.
-  
-   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
-   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
-   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
-   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-   SUCH DAMAGE.
-   ====================================================================
-  
-   This software consists of voluntary contributions made by many
-   individuals on behalf of the Joda project and was originally
-   created by Stephen Colebourne <scolebourne@joda.org>. For more
-   information on the Joda project, please see <http://www.joda.org/>.
-
--->
-</head>
-<body>
-<p>
-Provides a Gregorian/Julian Chronology implementation. The Gregorian/Julian
-calendar system (shortened to GJ) is the most commonly used system on the
-planet. The Julian system defined a leap year once every 4 years, whereas the
-Gregorian calendar has additional special rules for every 100 and 400 years.
-</p>
-<p>
-This package provides the classes necessary to support the GJ calendar system,
-including different cutover dates, the presence or absence of a year zero, a
-pure Gregorian calendar, or a pure Julian calendar.
-</p>
-</body>
-</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
deleted file mode 100644
index 29878a0..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.iso;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.DelegatedChronology;
-import org.joda.time.chrono.gj.GJChronology;
-
-/**
- * ISOChronology provides access to the individual date time fields 
- * for the ISO8601 defined chronological calendar system. When ISO 
- * does not define a field, but it can be determined (such as AM/PM)
- * it is included.
- * <p>
- * ISOChronology is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public final class ISOChronology extends DelegatedChronology {
-    
-    static final long serialVersionUID = -6212696554273812441L;
-
-    /** Singleton instance of a UTC ISOChronology */
-    private static final ISOChronology INSTANCE_UTC =
-        new ISOChronology(GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true));
-        
-    private static final int FAST_CACHE_SIZE = 64;
-
-    /** Fast cache of zone to chronology */
-    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];
-
-    /** Cache of zone to chronology */
-    private static final Map cCache = new HashMap();
-    static {
-        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);
-    }
-
-    /**
-     * Gets an instance of the ISOChronology.
-     * The time zone of the returned instance is UTC.
-     * 
-     * @return a singleton UTC instance of the chronology
-     */
-    public static ISOChronology getInstanceUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Gets an instance of the ISOChronology in the default time zone.
-     * 
-     * @return a chronology in the default time zone
-     */
-    public static ISOChronology getInstance() {
-        return getInstance(DateTimeZone.getDefault());
-    }
-
-    /**
-     * Gets an instance of the ISOChronology in the given time zone.
-     * 
-     * @param zone  the time zone to get the chronology in, null is default
-     * @return a chronology in the specified time zone
-     */
-    public static ISOChronology getInstance(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);
-        ISOChronology chrono = cFastCache[index];
-        if (chrono != null && chrono.getDateTimeZone() == zone) {
-            return chrono;
-        }
-        synchronized (cCache) {
-            chrono = (ISOChronology) cCache.get(zone);
-            if (chrono == null) {
-                chrono = new ISOChronology
-                    (GJChronology.getInstance(zone, Long.MIN_VALUE, true));
-                cCache.put(zone, chrono);
-            }
-        }
-        cFastCache[index] = chrono;
-        return chrono;
-    }
-
-    // Constructors and instance variables
-    //-----------------------------------------------------------------------
-    /**
-     * Restricted constructor
-     */
-    private ISOChronology(GJChronology gjChronology) {
-        super(gjChronology);
-    }
-
-    /**
-     * Serialize ISOChronology instances using a small stub. This reduces the
-     * serialized size, and deserialized instances come from the cache.
-     */
-    private Object writeReplace() {
-        return new Stub(getDateTimeZone());
-    }
-
-    // Conversion
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the Chronology in the UTC time zone.
-     * 
-     * @return the chronology in UTC
-     */
-    public Chronology withUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Gets the Chronology in a specific time zone.
-     * 
-     * @param zone  the zone to get the chronology in, null is default
-     * @return the chronology
-     */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == getDateTimeZone()) {
-            return this;
-        }
-        return getInstance(zone);
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a debugging toString.
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        String str = "ISOChronology";
-        DateTimeZone zone = getDateTimeZone();
-        if (zone != null) {
-            str = str + '[' + zone.getID() + ']';
-        }
-        return str;
-    }
-
-    private static final class Stub implements Serializable {
-        static final long serialVersionUID = -6212696554273812441L;
-
-        private transient DateTimeZone iZone;
-
-        Stub(DateTimeZone zone) {
-            iZone = zone;
-        }
-
-        private Object readResolve() {
-            return ISOChronology.getInstance(iZone);
-        }
-
-        private void writeObject(ObjectOutputStream out) throws IOException {
-            out.writeObject(iZone);
-        }
-
-        private void readObject(ObjectInputStream in)
-            throws IOException, ClassNotFoundException
-        {
-            iZone = (DateTimeZone)in.readObject();
-        }
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/package.html b/JodaTime/src/java/org/joda/time/chrono/iso/package.html
deleted file mode 100644
index 03787f8..0000000
--- a/JodaTime/src/java/org/joda/time/chrono/iso/package.html
+++ /dev/null
@@ -1,70 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-<title>org.joda.time.chrono.iso package</title>
-<!--
-
-   Joda Software License, Version 1.0
-  
-  
-   Copyright (c) 2001-03 Stephen Colebourne.
-   All rights reserved.
-  
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-  
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-  
-   3. The end-user documentation included with the redistribution,
-      if any, must include the following acknowledgment:
-         "This product includes software developed by the
-          Joda project (http://www.joda.org/)."
-      Alternately, this acknowledgment may appear in the software itself,
-      if and wherever such third-party acknowledgments normally appear.
-  
-   4. The name "Joda" must not be used to endorse or promote products
-      derived from this software without prior written permission. For
-      written permission, please contact licence@joda.org.
-  
-   5. Products derived from this software may not be called "Joda",
-      nor may "Joda" appear in their name, without prior written
-      permission of the Joda project.
-  
-   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
-   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
-   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
-   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-   SUCH DAMAGE.
-   ====================================================================
-  
-   This software consists of voluntary contributions made by many
-   individuals on behalf of the Joda project and was originally
-   created by Stephen Colebourne <scolebourne@joda.org>. For more
-   information on the Joda project, please see <http://www.joda.org/>.
-
--->
-</head>
-<body>
-<p>
-Provides an ISO Chronology implementation. The ISO calendar system is defined
-by the ISO8601 standard, which is in fact a special case of the Gregorian
-calendar system. It is defined as Gregorian over all time (proleptic) and
-includes the year 0 (which never actually occurred). All XML date and time
-transfers are recommended to use the ISO8601 standard.
-</p>
-</body>
-</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/package.html b/JodaTime/src/java/org/joda/time/chrono/package.html
index 1d411cd..194471a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
@@ -60,9 +60,7 @@
 </head>
 <body>
 <p>
-Provides Chronology implementaions and support. The base package contains
-classes that aid in making new chronologies and fields, and the sub-packages
-contain complete implementations.
+Provides Chronology implementaions and support.
 </p>
 </body>
 </html>
diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
index d3b6084..a988194 100644
--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -55,7 +55,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AbstractConverter simplifies the process of implementing a converter.
diff --git a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
index 58695e0..0a9e442 100644
--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
@@ -58,9 +58,11 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.BuddhistChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.JulianChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * CalendarConverter converts a java util Calendar to milliseconds in the
@@ -126,11 +128,16 @@
     public Chronology getChronology(Object object, DateTimeZone zone) {
         if (object instanceof GregorianCalendar) {
             GregorianCalendar gc = (GregorianCalendar) object;
-            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);
-            
+            long cutover = gc.getGregorianChange().getTime();
+            if (cutover == Long.MIN_VALUE) {
+                return GregorianChronology.getInstance(zone);
+            } else if (cutover == Long.MAX_VALUE) {
+                return JulianChronology.getInstance(zone);
+            } else {
+                return GJChronology.getInstance(zone, cutover, 4);
+            }
         } else if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
             return BuddhistChronology.getInstance(zone);
-            
         } else {
             return ISOChronology.getInstance(zone);
         }
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
index 30b8c1d..aab0d26 100644
--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
@@ -56,7 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.PartialInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * PartialInstantConverter extracts milliseconds and chronology from a
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
index 9b5b680..6036bbd 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
@@ -56,7 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index dc468e8..0585ba0 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -59,7 +59,7 @@
 import org.joda.time.ReadWritableDuration;
 import org.joda.time.ReadWritableInterval;
 import org.joda.time.ReadableDuration;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.DurationParser;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
new file mode 100644
index 0000000..ae41151
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
@@ -0,0 +1,621 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * AbstractDateTimeField provides the common behaviour for DateTimeField
+ * implementations. 
+ * <p>
+ * This class should generally not be used directly by API users. The
+ * DateTimeField interface should be used when different kinds of DateTimeField
+ * objects are to be referenced.
+ * <p>
+ * AbstractDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DecoratedDateTimeField
+ */
+public abstract class AbstractDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -4388055220581798589L;
+
+    /** A desriptive name for the field */
+    private final String iName;
+
+    /**
+     * Constructor.
+     */
+    protected AbstractDateTimeField(String name) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("The name must not be null");
+        }
+        iName = name;
+    }
+    
+    public final String getName() {
+        return iName;
+    }
+
+    /**
+     * @return true always
+     */
+    public final boolean isSupported() {
+        return true;
+    }
+
+    // Main access API
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the value of the field, in the units of the field
+     */
+    public abstract int get(long instant);
+
+    /**
+     * Get the human-readable, text value of this field from the milliseconds.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns Integer.toString(get(instant)).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getMaximumTextLength.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the text value of the field
+     */
+    public String getAsText(long instant, Locale locale) {
+        return Integer.toString(get(instant));
+    }
+
+    /**
+     * Get the human-readable, text value of this field from the milliseconds.
+     * This implementation returns getAsText(instant, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the text value of the field
+     */
+    public final String getAsText(long instant) {
+        return getAsText(instant, null);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from the
+     * milliseconds.  If the specified locale is null, the default locale is
+     * used.
+     * <p>
+     * The default implementation returns getAsText(instant, locale).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getMaximumShortTextLength.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the short text value of the field
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return getAsText(instant, locale);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from the
+     * milliseconds.  This implementation returns getAsShortText(instant, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the short text value of the field
+     */
+    public final String getAsShortText(long instant) {
+        return getAsShortText(instant, null);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * overflowing into larger fields if necessary.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field, larger fields will increase as required.
+     * Smaller fields should be unaffected, except where the result would be
+     * an invalid value for a smaller field. In this case the smaller field is
+     * adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 add six months is 2001-02-20<br>
+     * 2000-08-20 add twenty months is 2002-04-20<br>
+     * 2000-08-20 add minus nine months is 1999-11-20<br>
+     * 2001-01-31 add one month  is 2001-02-28<br>
+     * 2001-01-31 add two months is 2001-03-31<br>
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long add(long instant, int value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * overflowing into larger fields if necessary.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the long value to add, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if value is too large
+     * @see #add(long,int)
+     */
+    public long add(long instant, long value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * wrapping within this field.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field then it wraps. Larger fields are always
+     * unaffected. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 addWrapped six months is 2000-02-20<br>
+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapped two months is 2001-03-31<br>
+     * <p>
+     * The default implementation internally calls set. Subclasses are
+     * encouraged to provide a more efficient implementation.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long addWrapped(long instant, int value) {
+        int current = get(instant);
+        int wrapped = FieldUtils.getWrappedValue
+            (current, value, getMinimumValue(instant), getMaximumValue(instant));
+        return set(instant, wrapped);
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * int v = ...
+     * int age = getDifference(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Sets a value in the milliseconds supplied.
+     * <p>
+     * The value of this field will be set. If the value is invalid, an
+     * exception if thrown. Other fields are always unaffected.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  the value to set, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public abstract long set(long instant, int value);
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text
+     * value. If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns set(instant,
+     * Integer.parseInt(instant)).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getAsText.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param text  the text value to set
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public long set(long instant, String text, Locale locale) {
+        try {
+            return set(instant, Integer.parseInt(text));
+        } catch (NumberFormatException ex) {
+            throw new IllegalArgumentException("Invalid " + getName() + " text: " + text);
+        }
+    }
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text
+     * value. This implementation returns set(instant, text, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param text  the text value to set
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public final long set(long instant, String text) {
+        return set(instant, text, null);
+    }
+
+    // Extra information API
+    //------------------------------------------------------------------------
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the unit duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField if field
+     * has no duration
+     */
+    public abstract DurationField getDurationField();
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public abstract DurationField getRangeDurationField();
+
+    /**
+     * Returns whether this field is 'leap' for the specified instant.
+     * <p>
+     * For example, a leap year would return true, a non leap year would return
+     * false.
+     * <p>
+     * This implementation returns false.
+     * 
+     * @return true if the field is 'leap'
+     */
+    public boolean isLeap(long instant) {
+        return false;
+    }
+
+    /**
+     * Gets the amount by which this field is 'leap' for the specified instant.
+     * <p>
+     * For example, a leap year would return one, a non leap year would return
+     * zero.
+     * <p>
+     * This implementation returns zero.
+     */
+    public int getLeapAmount(long instant) {
+        return 0;
+    }
+
+    /**
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
+     * <p>
+     * This implementation returns null.
+     */
+    public DurationField getLeapDurationField() {
+        return null;
+    }
+
+    /**
+     * Get the minimum allowable value for this field.
+     * 
+     * @return the minimum valid value for this field, in the units of the
+     * field
+     */
+    public abstract int getMinimumValue();
+
+    /**
+     * Get the minimum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMinimumValue()}.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the minimum value for this field, in the units of the field
+     */
+    public int getMinimumValue(long instant) {
+        return getMinimumValue();
+    }
+
+    /**
+     * Get the maximum allowable value for this field.
+     * 
+     * @return the maximum valid value for this field, in the units of the
+     * field
+     */
+    public abstract int getMaximumValue();
+
+    /**
+     * Get the maximum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMaximumValue()}.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the maximum value for this field, in the units of the field
+     */
+    public int getMaximumValue(long instant) {
+        return getMaximumValue();
+    }
+
+    /**
+     * Get the maximum text value for this field. The default implementation
+     * returns the equivalent of Integer.toString(getMaximumValue()).length().
+     * 
+     * @param locale  the locale to use for selecting a text symbol
+     * @return the maximum text length
+     */
+    public int getMaximumTextLength(Locale locale) {
+        int max = getMaximumValue();
+        if (max >= 0) {
+            if (max < 10) {
+                return 1;
+            } else if (max < 100) {
+                return 2;
+            } else if (max < 1000) {
+                return 3;
+            }
+        }
+        return Integer.toString(max).length();
+    }
+
+    /**
+     * Get the maximum short text value for this field. The default
+     * implementation returns getMaximumTextLength().
+     * 
+     * @param locale  the locale to use for selecting a text symbol
+     * @return the maximum short text length
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return getMaximumTextLength(locale);
+    }
+
+    // Calculation API
+    //------------------------------------------------------------------------
+    /**
+     * Round to the lowest whole unit of this field. After rounding, the value
+     * of this field and all fields of a higher magnitude are retained. The
+     * fractional millis that cannot be expressed in whole increments of this
+     * field are set to minimum.
+     * <p>
+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
+     * lowest whole hour is 2002-11-02T23:00:00.000.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public abstract long roundFloor(long instant);
+
+    /**
+     * Round to the highest whole unit of this field. The value of this field
+     * and all fields of a higher magnitude may be incremented in order to
+     * achieve this result. The fractional millis that cannot be expressed in
+     * whole increments of this field are set to minimum.
+     * <p>
+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
+     * highest whole hour is 2002-11-03T00:00:00.000.
+     * <p>
+     * The default implementation calls roundFloor, and if the instant is
+     * modified as a result, adds one field unit. Subclasses are encouraged to
+     * provide a more efficient implementation.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundCeiling(long instant) {
+        long newInstant = roundFloor(instant);
+        if (newInstant != instant) {
+            instant = add(newInstant, 1);
+        }
+        return instant;
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor or is exactly halfway, this function
+     * behaves like roundFloor. If the millisecond value is closer to the
+     * ceiling, this function behaves like roundCeiling.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfFloor(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffFromFloor <= diffToCeiling) {
+            // Closer to the floor, or halfway - round floor
+            return floor;
+        } else {
+            return ceiling;
+        }
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor, this function behaves like roundFloor. If
+     * the millisecond value is closer to the ceiling or is exactly halfway,
+     * this function behaves like roundCeiling.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfCeiling(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffToCeiling <= diffFromFloor) {
+            // Closer to the ceiling, or halfway - round ceiling
+            return ceiling;
+        } else {
+            return floor;
+        }
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor, this function behaves like roundFloor. If
+     * the millisecond value is closer to the ceiling, this function behaves
+     * like roundCeiling.
+     * <p>
+     * If the millisecond value is exactly halfway between the floor and
+     * ceiling, the ceiling is chosen over the floor only if it makes this
+     * field's value even.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfEven(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffFromFloor < diffToCeiling) {
+            // Closer to the floor - round floor
+            return floor;
+        } else if (diffToCeiling < diffFromFloor) {
+            // Closer to the ceiling - round ceiling
+            return ceiling;
+        } else {
+            // Round to the instant that makes this field even. If both values
+            // make this field even (unlikely), favor the ceiling.
+            if ((get(ceiling) & 1) == 0) {
+                return ceiling;
+            }
+            return floor;
+        }
+    }
+
+    /**
+     * Returns the fractional duration milliseconds of this field. In other
+     * words, calling remainder returns the duration that roundFloor would
+     * subtract.
+     * <p>
+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
+     * hour is 34 minutes and 56.789 seconds.
+     * <p>
+     * The default implementation computes
+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to
+     * provide a more efficient implementation.
+     *
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the
+     * remainder
+     * @return remainder duration, in milliseconds
+     */
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DateTimeField[" + getName() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
new file mode 100644
index 0000000..06e82bd
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
@@ -0,0 +1,199 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * AbstractDurationField provides the common behaviour for DurationField
+ * implementations.
+ * <p>
+ * This class should generally not be used directly by API users. The
+ * DurationField interface should be used when different kinds of DurationField
+ * objects are to be referenced.
+ * <p>
+ * AbstractDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DecoratedDurationField
+ */
+public abstract class AbstractDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -2554245107589433218L;
+
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected AbstractDurationField(String name) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("The name must not be null");
+        }
+        iName = name;
+    }
+
+    public final String getName() {
+        return iName;
+    }
+
+    /**
+     * @return true always
+     */
+    public final boolean isSupported() {
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public int getValue(long duration) {
+        return FieldUtils.safeToInt(getValueAsLong(duration));
+    }
+
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration) {
+        return duration / getUnitMillis();
+    }
+
+    /**
+     * Get the value of this field from the milliseconds relative to an
+     * instant.
+     *
+     * <p>If the milliseconds is positive, then the instant is treated as a
+     * "start instant". If negative, the instant is treated as an "end
+     * instant".
+     *
+     * <p>The default implementation returns
+     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  the start instant to calculate relative to
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public int getValue(long duration, long instant) {
+        return FieldUtils.safeToInt(getValueAsLong(duration, instant));
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value) {
+        return value * getUnitMillis();
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value) {
+        return value * getUnitMillis();
+    }
+
+    // Calculation API
+    //------------------------------------------------------------------------
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    //------------------------------------------------------------------------
+    public int compareTo(Object durationField) {
+        DurationField otherField = (DurationField) durationField;
+        long otherMillis = otherField.getUnitMillis();
+        long thisMillis = getUnitMillis();
+        // cannot do (thisMillis - otherMillis) as can overflow
+        if (thisMillis == otherMillis) {
+            return 0;
+        }
+        if (thisMillis < otherMillis) {
+            return -1;
+        } else {
+            return 1;
+        }
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DurationField[" + getName() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
new file mode 100644
index 0000000..c415876
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
@@ -0,0 +1,138 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},
+ * implementing only the minimum required set of methods. These implemented
+ * methods delegate to a wrapped field.
+ * <p>
+ * This design allows new DateTimeField types to be defined that piggyback on
+ * top of another, inheriting all the safe method implementations from
+ * AbstractDateTimeField. Should any method require pure delegation to the
+ * wrapped field, simply override and use the provided getWrappedField method.
+ * <p>
+ * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DelegatedDateTimeField
+ */
+public class DecoratedDateTimeField extends AbstractDateTimeField {
+
+    static final long serialVersionUID = 203115783733757597L;
+
+    /** The DateTimeField being wrapped */
+    private final DateTimeField iField;
+
+    /**
+     * @param name allow name to be overridden
+     */
+    public DecoratedDateTimeField(DateTimeField field, String name) {
+        super(name);
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        if (!field.isSupported()) {
+            throw new IllegalArgumentException("The field must be supported");
+        }
+        iField = field;
+    }
+
+    /**
+     * Gets the wrapped date time field.
+     * 
+     * @return the wrapped DateTimeField
+     */
+    public final DateTimeField getWrappedField() {
+        return iField;
+    }
+
+    public boolean isLenient() {
+        return iField.isLenient();
+    }
+
+    public int get(long instant) {
+        return iField.get(instant);
+    }
+
+    public long set(long instant, int value) {
+        return iField.set(instant, value);
+    }
+
+    public DurationField getDurationField() {
+        return iField.getDurationField();
+    }
+
+    public DurationField getRangeDurationField() {
+        return iField.getRangeDurationField();
+    }
+
+    public int getMinimumValue() {
+        return iField.getMinimumValue();
+    }
+
+    public int getMaximumValue() {
+        return iField.getMaximumValue();
+    }
+
+    public long roundFloor(long instant) {
+        return iField.roundFloor(instant);
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
new file mode 100644
index 0000000..be255e2
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
@@ -0,0 +1,136 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DurationField;
+
+/**
+ * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},
+ * implementing only the minimum required set of methods. These implemented
+ * methods delegate to a wrapped field.
+ * <p>
+ * This design allows new DurationField types to be defined that piggyback on
+ * top of another, inheriting all the safe method implementations from
+ * AbstractDurationField. Should any method require pure delegation to the
+ * wrapped field, simply override and use the provided getWrappedField method.
+ * <p>
+ * DecoratedDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DelegatedDurationField
+ */
+public class DecoratedDurationField extends AbstractDurationField {
+
+    static final long serialVersionUID = 8019982251647420015L;
+
+    /** The DurationField being wrapped */
+    private final DurationField iField;
+
+    /**
+     * @param name allow name to be overridden
+     */
+    public DecoratedDurationField(DurationField field, String name) {
+        super(name);
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        if (!field.isSupported()) {
+            throw new IllegalArgumentException("The field must be supported");
+        }
+        iField = field;
+    }
+
+    /**
+     * Gets the wrapped duration field.
+     * 
+     * @return the wrapped DurationField
+     */
+    public final DurationField getWrappedField() {
+        return iField;
+    }
+
+    public boolean isPrecise() {
+        return iField.isPrecise();
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return iField.getValueAsLong(duration, instant);
+    }
+
+    public long getMillis(int value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long getUnitMillis() {
+        return iField.getUnitMillis();
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
new file mode 100644
index 0000000..d7748ba
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -0,0 +1,240 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * <code>DelegatedDateTimeField</code> delegates each method call to the
+ * date time field it wraps.
+ * <p>
+ * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DecoratedDateTimeField
+ */
+public class DelegatedDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -4730164440214502503L;
+
+    /** The DateTimeField being wrapped */
+    private final DateTimeField iField;
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected DelegatedDateTimeField(DateTimeField field) {
+        this(field, null);
+    }
+
+    protected DelegatedDateTimeField(DateTimeField field, String name) {
+        super();
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        iField = field;
+        iName = name;
+    }
+
+    /**
+     * Gets the wrapped date time field.
+     * 
+     * @return the wrapped DateTimeField
+     */
+    public final DateTimeField getWrappedField() {
+        return iField;
+    }
+
+    public String getName() {
+        return (iName == null) ? iField.getName() : iName;
+    }
+
+    public boolean isSupported() {
+        return iField.isSupported();
+    }
+
+    public boolean isLenient() {
+        return iField.isLenient();
+    }
+
+    public int get(long instant) {
+        return iField.get(instant);
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        return iField.getAsText(instant, locale);
+    }
+
+    public String getAsText(long instant) {
+        return iField.getAsText(instant);
+    }
+
+    public String getAsShortText(long instant, Locale locale) {
+        return iField.getAsShortText(instant, locale);
+    }
+
+    public String getAsShortText(long instant) {
+        return iField.getAsShortText(instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public long addWrapped(long instant, int value) {
+        return iField.addWrapped(instant, value);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long set(long instant, int value) {
+        return iField.set(instant, value);
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        return iField.set(instant, text, locale);
+    }
+
+    public long set(long instant, String text) {
+        return iField.set(instant, text);
+    }
+
+    public DurationField getDurationField() {
+        return iField.getDurationField();
+    }
+
+    public DurationField getRangeDurationField() {
+        return iField.getRangeDurationField();
+    }
+
+    public boolean isLeap(long instant) {
+        return iField.isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return iField.getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return iField.getLeapDurationField();
+    }
+
+    public int getMinimumValue() {
+        return iField.getMinimumValue();
+    }
+
+    public int getMinimumValue(long instant) {
+        return iField.getMinimumValue(instant);
+    }
+
+    public int getMaximumValue() {
+        return iField.getMaximumValue();
+    }
+
+    public int getMaximumValue(long instant) {
+        return iField.getMaximumValue(instant);
+    }
+
+    public int getMaximumTextLength(Locale locale) {
+        return iField.getMaximumTextLength(locale);
+    }
+
+    public int getMaximumShortTextLength(Locale locale) {
+        return iField.getMaximumShortTextLength(locale);
+    }
+
+    public long roundFloor(long instant) {
+        return iField.roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return iField.roundCeiling(instant);
+    }
+
+    public long roundHalfFloor(long instant) {
+        return iField.roundHalfFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return iField.roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return iField.roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return iField.remainder(instant);
+    }
+
+    public String toString() {
+        return (iName == null) ? iField.toString() :
+            ("DateTimeField[" + iName + ']');
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
new file mode 100644
index 0000000..21d9c6d
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
@@ -0,0 +1,178 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * <code>DelegatedDurationField</code> delegates each method call to the
+ * duration field it wraps.
+ * <p>
+ * DelegatedDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DecoratedDurationField
+ */
+public class DelegatedDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -5576443481242007829L;
+
+    /** The DurationField being wrapped */
+    private final DurationField iField;
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected DelegatedDurationField(DurationField field) {
+        this(field, null);
+    }
+
+    /**
+     * @param name allow name to be overridden
+     */
+    protected DelegatedDurationField(DurationField field, String name) {
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        iField = field;
+        iName = name;
+    }
+
+    /**
+     * Gets the wrapped duration field.
+     * 
+     * @return the wrapped DurationField
+     */
+    public final DurationField getWrappedField() {
+        return iField;
+    }
+
+    public String getName() {
+        return (iName == null) ? iField.getName() : iName;
+    }
+
+    /**
+     * Returns true if this field is supported.
+     */
+    public boolean isSupported() {
+        return iField.isSupported();
+    }
+
+    public boolean isPrecise() {
+        return iField.isPrecise();
+    }
+    
+    public int getValue(long duration) {
+        return iField.getValue(duration);
+    }
+
+    public long getValueAsLong(long duration) {
+        return iField.getValueAsLong(duration);
+    }
+
+    public int getValue(long duration, long instant) {
+        return iField.getValue(duration, instant);
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return iField.getValueAsLong(duration, instant);
+    }
+
+    public long getMillis(int value) {
+        return iField.getMillis(value);
+    }
+
+    public long getMillis(long value) {
+        return iField.getMillis(value);
+    }
+
+    public long getMillis(int value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long getUnitMillis() {
+        return iField.getUnitMillis();
+    }
+
+    public int compareTo(Object durationField) {
+        return iField.compareTo(durationField);
+    }
+
+    public String toString() {
+        return (iName == null) ? iField.toString() :
+            ("DurationField[" + iName + ']');
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
new file mode 100644
index 0000000..81e5cd8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
@@ -0,0 +1,266 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Divides a DateTimeField such that the retrieved values are reduced by a
+ * fixed divisor. The field's unit duration is scaled accordingly, but the
+ * range duration is unchanged.
+ * <p>
+ * DividedDateTimeField is thread-safe and immutable.
+ *
+ * @see RemainderDateTimeField
+ * 
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class DividedDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 8318475124230605365L;
+
+    // Shared with RemainderDateTimeField.
+    final int iDivisor;
+    final DurationField iDurationField;
+
+    private final int iMin;
+    private final int iMax;
+
+    /**
+     * Constructor.
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "century".
+     * @param durationName  short, descriptive name, like "centuries".
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
+     */
+    public DividedDateTimeField(DateTimeField field,
+                                String name, String durationName, int divisor) {
+        super(field, name);
+                
+        if (divisor < 2) {
+            throw new IllegalArgumentException("The divisor must be at least 2");
+        }
+
+        DurationField unitField = field.getDurationField();
+        if (unitField == null) {
+            iDurationField = null;
+        } else {
+            iDurationField = new ScaledDurationField(unitField, durationName, divisor);
+        }
+
+        iDivisor = divisor;
+
+        int i = field.getMinimumValue();
+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
+
+        int j = field.getMaximumValue();
+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
+
+        iMin = min;
+        iMax = max;
+    }
+
+    /**
+     * Construct a DividedDateTimeField that compliments the given
+     * RemainderDateTimeField.
+     *
+     * @param remainderField  complimentary remainder field, like "yearOfCentury()".
+     * @param name  short, descriptive name, like "century".
+     */
+    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {
+        super(remainderField.getWrappedField(), name);
+        int divisor = iDivisor = remainderField.iDivisor;
+        iDurationField = remainderField.iRangeField;
+
+        DateTimeField field = getWrappedField();
+        int i = field.getMinimumValue();
+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
+
+        int j = field.getMaximumValue();
+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
+
+        iMin = min;
+        iMax = max;
+    }
+
+    /**
+     * Get the amount of scaled units from the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the amount of scaled units extracted from the input.
+     */
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
+        if (value >= 0) {
+            return value / iDivisor;
+        } else {
+            return ((value + 1) / iDivisor) - 1;
+        }
+    }
+
+    /**
+     * Add the specified amount of scaled units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        return getWrappedField().add(instant, amount * iDivisor);
+    }
+
+    /**
+     * Add the specified amount of scaled units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        return getWrappedField().add(instant, amount * iDivisor);
+    }
+
+    /**
+     * Add to the scaled component of the specified time instant,
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;
+    }
+
+    /**
+     * Set the specified amount of scaled units to the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param value  value of scaled units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);
+        int remainder = getRemainder(getWrappedField().get(instant));
+        return getWrappedField().set(instant, value * iDivisor + remainder);
+    }
+
+    /**
+     * Returns a scaled version of the wrapped field's unit duration field.
+     */
+    public DurationField getDurationField() {
+        return iDurationField;
+    }
+
+    /**
+     * Get the minimum value for the field.
+     * 
+     * @return the minimum value
+     */
+    public int getMinimumValue() {
+        return iMin;
+    }
+
+    /**
+     * Get the maximum value for the field.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return iMax;
+    }
+
+    public long roundFloor(long instant) {
+        DateTimeField field = getWrappedField();
+        return field.roundFloor(field.set(instant, get(instant) * iDivisor));
+    }
+
+    public long remainder(long instant) {
+        return set(instant, get(getWrappedField().remainder(instant)));
+    }
+
+    /**
+     * Returns the divisor applied, in the field's units.
+     * 
+     * @return the divisor
+     */
+    public int getDivisor() {
+        return iDivisor;
+    }
+
+    private int getRemainder(int value) {
+        if (value >= 0) {
+            return value % iDivisor;
+        } else {
+            return (iDivisor - 1) + ((value + 1) % iDivisor);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/FieldUtils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
new file mode 100644
index 0000000..da3bdc7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
@@ -0,0 +1,225 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * General utilities that don't fit elsewhere.
+ * <p>
+ * Utils is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public class FieldUtils {
+
+    /**
+     * Restricted constructor.
+     */
+    private FieldUtils() {
+        super();
+    }
+    
+    //------------------------------------------------------------------------
+    /**
+     * Add two values throwing an exception if overflow occurs.
+     * 
+     * @param val1  the first value
+     * @param val2  the second value
+     * @return the new total
+     */
+    public static long safeAdd(long val1, long val2) {
+        long total = val1 + val2;
+        if (val1 > 0 && val2 > 0 && total < 0) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
+        }
+        if (val1 < 0 && val2 < 0 && total > 0) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
+        }
+        return total;
+    }
+    
+    /**
+     * Multiply two values throwing an exception if overflow occurs.
+     * 
+     * @param val1  the first value
+     * @param val2  the second value
+     * @return the new total
+     */
+    public static long safeMultiply(long val1, long val2) {
+        if (val1 == 0  || val2 == 0) {
+            return 0L;
+        }
+        long total = val1 * val2;
+        if (total / val2 != val1) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" * " + val2);
+        }
+        return total;
+    }
+    
+    /**
+     * Casts to an int throwing an exception if overflow occurs.
+     * 
+     * @param value  the value
+     * @return the value as an int
+     */
+    public static int safeToInt(long value) {
+        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
+            return (int) value;
+        }
+        throw new ArithmeticException("Value cannot fit in an int: " + value);
+    }
+
+    /**
+     * Verify that input values are within specified bounds.
+     * 
+     * @param value  the value to check
+     * @param lowerBound  the lower bound allowed for value
+     * @param upperBound  the upper bound allowed for value
+     * @throws IllegalArgumentException if value is not in the specified bounds
+     */
+    public static void verifyValueBounds(DateTimeField field, 
+                                         int value, int lowerBound, int upperBound) {
+        if ((value < lowerBound) || (value > upperBound)) {
+            throw new IllegalArgumentException(
+                "Value "
+                    + value
+                    + " for "
+                    + field.getName()
+                    + " must be in the range ["
+                    + lowerBound
+                    + ','
+                    + upperBound
+                    + ']');
+        }
+    }
+
+    /**
+     * Verify that input values are within specified bounds.
+     * 
+     * @param value  the value to check
+     * @param lowerBound  the lower bound allowed for value
+     * @param upperBound  the upper bound allowed for value
+     * @throws IllegalArgumentException if value is not in the specified bounds
+     */
+    public static void verifyValueBounds(String fieldName,
+                                         int value, int lowerBound, int upperBound) {
+        if ((value < lowerBound) || (value > upperBound)) {
+            throw new IllegalArgumentException(
+                "Value "
+                    + value
+                    + " for "
+                    + fieldName
+                    + " must be in the range ["
+                    + lowerBound
+                    + ','
+                    + upperBound
+                    + ']');
+        }
+    }
+
+    /**
+     * Utility method used by addWrapped implementations to ensure the new
+     * value lies within the field's legal value range.
+     *
+     * @param currentValue the current value of the data, which may lie outside
+     * the wrapped value range
+     * @param wrapValue  the value to add to current value before
+     *  wrapping.  This may be negative.
+     * @param minValue the wrap range minimum value.
+     * @param maxValue the wrap range maximum value.  This must be
+     *  greater than minValue (checked by the method).
+     * @return the wrapped value
+     * @throws IllegalArgumentException if minValue is greater
+     *  than or equal to maxValue
+     */
+    public static int getWrappedValue(int currentValue, int wrapValue,
+                                      int minValue, int maxValue) {
+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
+    }
+
+    /**
+     * Utility method that ensures the given value lies within the field's
+     * legal value range.
+     * 
+     * @param value  the value to fit into the wrapped value range
+     * @param minValue the wrap range minimum value.
+     * @param maxValue the wrap range maximum value.  This must be
+     *  greater than minValue (checked by the method).
+     * @return the wrapped value
+     * @throws IllegalArgumentException if minValue is greater
+     *  than or equal to maxValue
+     */
+    public static int getWrappedValue(int value, int minValue, int maxValue) {
+        if (minValue >= maxValue) {
+            throw new IllegalArgumentException("MIN > MAX");
+        }
+
+        int wrapRange = maxValue - minValue + 1;
+        value -= minValue;
+
+        if (value >= 0) {
+            return (value % wrapRange) + minValue;
+        }
+
+        int remByRange = (-value) % wrapRange;
+
+        if (remByRange == 0) {
+            return 0 + minValue;
+        }
+        return (wrapRange - remByRange) + minValue;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
new file mode 100644
index 0000000..d57c312
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
@@ -0,0 +1,236 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DurationField;
+
+/**
+ * Abstract datetime field class that defines its own DurationField, which
+ * delegates back into this ImpreciseDateTimeField.
+ * <p>
+ * This DateTimeField is useful for defining DateTimeFields that are composed
+ * of imprecise durations. If both duration fields are precise, then a
+ * {@link PreciseDateTimeField} should be used instead.
+ * <p>
+ * When defining imprecise DateTimeFields where a matching DurationField is
+ * already available, just extend AbstractDateTimeField directly so as not to
+ * create redundant DurationField instances.
+ * <p>
+ * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see PreciseDateTimeField
+ */
+public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {
+
+    static final long serialVersionUID = 7190739608550251860L;
+
+    final long iUnitMillis;
+    private final DurationField iDurationField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "monthOfYear".
+     * @param durationName  short, descriptive name, like "months".
+     * @param unitMillis  the average duration unit milliseconds
+     */
+    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {
+        super(name);
+        iUnitMillis = unitMillis;
+        iDurationField = new LinkedDurationField(durationName);
+    }
+
+    public abstract int get(long instant);
+
+    public abstract long set(long instant, int value);
+
+    public abstract long add(long instant, int value);
+
+    public abstract long add(long instant, long value);
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * int v = ...
+     * int age = getDifference(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     * <p>
+     * The default implementation call getDifferenceAsLong and converts the
+     * return value to an int.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     * <p>
+     * The default implementation performs a guess-and-check algorithm using
+     * getDurationField().getUnitMillis() and the add() method. Subclasses are
+     * encouraged to provide a more efficient implementation.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);
+        }
+        
+        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;
+        if (add(subtrahendInstant, difference) < minuendInstant) {
+            do {
+                difference++;
+            } while (add(subtrahendInstant, difference) <= minuendInstant);
+            difference--;
+        } else if (add(subtrahendInstant, difference) > minuendInstant) {
+            do {
+                difference--;
+            } while (add(subtrahendInstant, difference) > minuendInstant);
+        }
+        return difference;
+    }
+
+    public final DurationField getDurationField() {
+        return iDurationField;
+    }
+
+    public abstract DurationField getRangeDurationField();
+
+    public abstract long roundFloor(long instant);
+
+    protected final long getDurationUnitMillis() {
+        return iUnitMillis;
+    }
+
+    private final class LinkedDurationField extends AbstractDurationField {
+        static final long serialVersionUID = -203813474600094134L;
+
+        LinkedDurationField(String name) {
+            super(name);
+        }
+    
+        public boolean isPrecise() {
+            return false;
+        }
+    
+        public long getUnitMillis() {
+            return iUnitMillis;
+        }
+
+        public int getValue(long duration, long instant) {
+            return ImpreciseDateTimeField.this
+                .getDifference(instant + duration, instant);
+        }
+
+        public long getValueAsLong(long duration, long instant) {
+            return ImpreciseDateTimeField.this
+                .getDifferenceAsLong(instant + duration, instant);
+        }
+        
+        public long getMillis(int value, long instant) {
+            return ImpreciseDateTimeField.this.add(instant, value) - instant;
+        }
+
+        public long getMillis(long value, long instant) {
+            return ImpreciseDateTimeField.this.add(instant, value) - instant;
+        }
+
+        public long add(long instant, int value) {
+            return ImpreciseDateTimeField.this.add(instant, value);
+        }
+        
+        public long add(long instant, long value) {
+            return ImpreciseDateTimeField.this.add(instant, value);
+        }
+        
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return ImpreciseDateTimeField.this
+                .getDifference(minuendInstant, subtrahendInstant);
+        }
+        
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return ImpreciseDateTimeField.this
+                .getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
new file mode 100644
index 0000000..9a9275e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
@@ -0,0 +1,110 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * Converts a strict DateTimeField into a lenient one. By being lenient, the
+ * set method accepts out of bounds values, performing an addition instead.
+ * <p>
+ * LenientDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see org.joda.time.chrono.LenientChronology
+ * @see StrictDateTimeField
+ */
+public class LenientDateTimeField extends DelegatedDateTimeField {
+
+    static final long serialVersionUID = 8714085824173290599L;
+
+    /**
+     * Returns a lenient version of the given field. If it is already lenient,
+     * then it is returned as-is. Otherwise, a new LenientDateTimeField is
+     * returned.
+     */
+    public static DateTimeField getInstance(DateTimeField field) {
+        if (field == null) {
+            return null;
+        }
+        if (field instanceof StrictDateTimeField) {
+            field = ((StrictDateTimeField)field).getWrappedField();
+        }
+        if (field.isLenient()) {
+            return field;
+        }
+        return new LenientDateTimeField(field);
+    }
+
+    protected LenientDateTimeField(DateTimeField field) {
+        super(field);
+    }
+
+    public final boolean isLenient() {
+        return true;
+    }
+
+    /**
+     * Set values which may be out of bounds. If the value is out of bounds,
+     * the instant is first set to the minimum allowed value, and then the
+     * difference is added.
+     */
+    public long set(long instant, int value) {
+        int min = getMinimumValue(instant);
+        if (value >= min && value < getMaximumValue(instant)) {
+            return super.set(instant, value);
+        }
+        return add(super.set(instant, min), value - min);
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j b/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
new file mode 100644
index 0000000..7f5828d
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
@@ -0,0 +1,332 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Generic limiting datetime field.
+ * <p>
+ * This DateTimeField allows specific millisecond boundaries to be applied 
+ * to DateTimeFields.
+ * <p>
+ * LimitDateTimeField is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+// TODO: Move delete this
+// TODO: Also consider ShiftedChronology, for supporting Coptic.
+public class LimitDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = -4969295623151287856L;
+
+    /** The lower boundary in millis */
+    private final long iLowerBound;
+    /** The upper boundary in millis */
+    private final long iUpperBound;
+
+    /**
+     * Constructor
+     * 
+     * @param lowerBound  milliseconds to form the lower boundary inclusive
+     * @param upperBound  milliseconds to form the upper boundary inclusive
+     * @throws IllegalArgumentException if field is null or boundary is invalid
+     */
+    public LimitDateTimeField(DateTimeField field,
+                              long lowerBound, long upperBound) {
+        this(field, field.getName(), lowerBound, upperBound);
+    }
+
+    /**
+     * Constructor
+     * 
+     * @param name  short, descriptive name, like "secondOfMinute".
+     * @param lowerBound  milliseconds to form the lower boundary inclusive
+     * @param upperBound  milliseconds to form the upper boundary inclusive
+     * @throws IllegalArgumentException if field is null or boundary is invalid
+     */
+    public LimitDateTimeField(DateTimeField field, String name,
+                              long lowerBound, long upperBound) {
+        super(field, name);
+                
+        if (lowerBound >= upperBound) {
+            throw new IllegalArgumentException("The lowerBound must be less than the upperBound");
+        }
+        iLowerBound = lowerBound;
+        iUpperBound = upperBound;
+    }
+
+    /**
+     * Get the amount of fractional units from the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the amount of fractional units extracted from the input.
+     */
+    public int get(long instant) {
+        checkBounds(instant, null);
+        return getWrappedField().get(instant);
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        checkBounds(instant, null);
+        return getWrappedField().getAsText(instant, locale);
+    }
+
+    public String getAsShortText(long instant, Locale locale) {
+        checkBounds(instant, null);
+        return getWrappedField().getAsShortText(instant, locale);
+    }
+
+    /**
+     * Add the specified amount of fractional units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().add(instant, amount);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Add the specified amount of fractional units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().add(instant, amount);
+        System.out.println(result);
+        System.out.println(iLowerBound);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Add to the fractional component of the specified time instant,
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().addWrapped(instant, amount);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        checkBounds(minuendInstant, "minuend");
+        checkBounds(subtrahendInstant, "subtrahend");
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        checkBounds(minuendInstant, "minuend");
+        checkBounds(subtrahendInstant, "subtrahend");
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Set the specified amount of fractional units to the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param value  value of fractional units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        checkBounds(instant, null);
+        long result = getWrappedField().set(instant, value);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        checkBounds(instant, null);
+        long result = getWrappedField().set(instant, text, locale);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
+    }
+
+    public long roundFloor(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundFloor(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundCeiling(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundCeiling(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfFloor(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfFloor(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfCeiling(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfCeiling(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfEven(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfEven(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long remainder(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().remainder(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Returns the milliseconds lower bound.
+     * 
+     * @return lower bound
+     */
+    public long getLowerBound() {
+        return iLowerBound;
+    }
+
+    /**
+     * Returns the milliseconds upper bound.
+     * 
+     * @return upper bound
+     */
+    public long getUpperBound() {
+        return iUpperBound;
+    }
+
+    private void checkBounds(long instant, String desc) {
+        if (instant < iLowerBound) {
+            throw new BoundsException(desc, true);
+        } else if (instant > iUpperBound) {
+            throw new BoundsException(desc, false);
+        }
+    }
+
+    /**
+     * Extends IllegalArgumentException such that the exception message is not
+     * generated unless it is actually requested.
+     */
+    private static class BoundsException extends IllegalArgumentException {
+        private final boolean iIsLow;
+
+        BoundsException(String desc, boolean isLow) {
+            super(desc);
+            iIsLow = isLow;
+        }
+
+        public String getMessage() {
+            StringBuffer buf = new StringBuffer(85);
+            buf.append("The");
+            String desc = super.getMessage();
+            if (desc != null) {
+                buf.append(' ');
+                buf.append(desc);
+            }
+            buf.append(" instant is ");
+            if (iIsLow) {
+                buf.append("below the supported minimum of ");
+            } else {
+                buf.append("above the supported maximum of ");
+            }
+            buf.append("TODO");
+            return buf.toString();
+        }
+
+        public String toString() {
+            return "IllegalArgumentException: " + getMessage();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
new file mode 100644
index 0000000..851af28
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
@@ -0,0 +1,187 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * Duration field class representing a field with a fixed unit length of one
+ * millisecond.
+ * <p>
+ * MillisDurationField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class MillisDurationField implements DurationField, Serializable {
+    
+    static final long serialVersionUID = 2656707858124633367L;
+
+    public static final DurationField INSTANCE = new MillisDurationField();
+
+    private MillisDurationField() {
+    }
+    
+    //------------------------------------------------------------------------
+    public String getName() {
+        return "millis";
+    }
+
+    /**
+     * @return true always
+     */
+    public boolean isSupported() {
+        return true;
+    }
+
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public final boolean isPrecise() {
+        return true;
+    }
+    
+    /**
+     * Returns the amount of milliseconds per unit value of this field.
+     *
+     * @return one always
+     */
+    public final long getUnitMillis() {
+        return 1;
+    }
+
+    //------------------------------------------------------------------------
+    public int getValue(long duration) {
+        return FieldUtils.safeToInt(duration);
+    }
+
+    public long getValueAsLong(long duration) {
+        return duration;
+    }
+
+    public int getValue(long duration, long instant) {
+        return FieldUtils.safeToInt(duration);
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return duration;
+    }
+
+    public long getMillis(int value) {
+        return value;
+    }
+
+    public long getMillis(long value) {
+        return value;
+    }
+
+    public long getMillis(int value, long instant) {
+        return value;
+    }
+
+    public long getMillis(long value, long instant) {
+        return value;
+    }
+
+    public long add(long instant, int value) {
+        return instant + value;
+    }
+
+    public long add(long instant, long value) {
+        return instant + value;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return FieldUtils.safeToInt(minuendInstant - subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return minuendInstant - subtrahendInstant;
+    }
+
+    //------------------------------------------------------------------------
+    public int compareTo(Object durationField) {
+        DurationField otherField = (DurationField) durationField;
+        long otherMillis = otherField.getUnitMillis();
+        long thisMillis = getUnitMillis();
+        // cannot do (thisMillis - otherMillis) as can overflow
+        if (thisMillis == otherMillis) {
+            return 0;
+        }
+        if (thisMillis < otherMillis) {
+            return -1;
+        } else {
+            return 1;
+        }
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DurationField[" + getName() + ']';
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
new file mode 100644
index 0000000..fdf4d6f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -0,0 +1,195 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Wraps another field such that zero values are replaced with one more than
+ * it's maximum. This is particularly useful for implementing an clockhourOfDay
+ * field, where the midnight value of 0 is replaced with 24.
+ * <p>
+ * NonZeroDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class NonZeroDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 961749798233026866L;
+
+    /**
+     * @param name  short, descriptive name, like "clockhourOfDay".
+     * @throws IllegalArgumentException if wrapped field's minimum value is not zero
+     */
+    public NonZeroDateTimeField(DateTimeField field, String name) {
+        super(field, name);
+        if (field.getMinimumValue() != 0) {
+            throw new IllegalArgumentException("Wrapped field's minumum value must be zero");
+        }
+    }
+
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
+        if (value == 0) {
+            value = getMaximumValue();
+        }
+        return value;
+    }
+
+    public long add(long instant, int value) {
+        return getWrappedField().add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return getWrappedField().add(instant, value);
+    }
+
+    public long addWrapped(long instant, int value) {
+        return getWrappedField().addWrapped(instant, value);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long set(long instant, int value) {
+        int max = getMaximumValue();
+        FieldUtils.verifyValueBounds(this, value, 1, max);
+        if (value == max) {
+            value = 0;
+        }
+        return getWrappedField().set(instant, value);
+    }
+
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
+    }
+
+    /**
+     * Always returns 1.
+     * 
+     * @return the minimum value of 1
+     */
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    /**
+     * Always returns 1.
+     * 
+     * @return the minimum value of 1
+     */
+    public int getMinimumValue(long instant) {
+        return 1;
+    }
+
+    /**
+     * Get the maximum value for the field, which is one more than the wrapped
+     * field's maximum value.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return getWrappedField().getMaximumValue() + 1;
+    }
+
+    /**
+     * Get the maximum value for the field, which is one more than the wrapped
+     * field's maximum value.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue(long instant) {
+        return getWrappedField().getMaximumValue(instant) + 1;
+    }
+
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
+    }
+
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
new file mode 100644
index 0000000..9b997fd
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
@@ -0,0 +1,244 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Generic offset adjusting datetime field.
+ * <p>
+ * OffsetDateTimeField is thread-safe and immutable.
+ * 
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class OffsetDateTimeField extends DecoratedDateTimeField {
+    static final long serialVersionUID = 3145790132623583142L;
+
+    private final int iOffset;
+
+    private final int iMin;
+    private final int iMax;
+
+    /**
+     * Constructor
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "offsetYear".
+     * @param offset  offset to add to field values
+     * @throws IllegalArgumentException if offset is zero
+     */
+    public OffsetDateTimeField(DateTimeField field, String name, int offset) {
+        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Constructor
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "offsetYear".
+     * @param offset  offset to add to field values
+     * @param minValue  minimum allowed value
+     * @param maxValue  maximum allowed value
+     * @throws IllegalArgumentException if offset is zero
+     */
+    public OffsetDateTimeField(DateTimeField field, String name, int offset,
+                               int minValue, int maxValue) {
+        super(field, name);
+                
+        if (offset == 0) {
+            throw new IllegalArgumentException("The offset cannot be zero");
+        }
+
+        iOffset = offset;
+
+        if (minValue < (field.getMinimumValue() + offset)) {
+            iMin = field.getMinimumValue() + offset;
+        } else {
+            iMin = minValue;
+        }
+        if (maxValue > (field.getMaximumValue() + offset)) {
+            iMax = field.getMaximumValue() + offset;
+        } else {
+            iMax = maxValue;
+        }
+    }
+
+    /**
+     * Get the amount of offset units from the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the amount of units extracted from the input.
+     */
+    public int get(long instant) {
+        return super.get(instant) + iOffset;
+    }
+
+    /**
+     * Add the specified amount of offset units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        instant = super.add(instant, amount);
+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);
+        return instant;
+    }
+
+    /**
+     * Add the specified amount of offset units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        instant = super.add(instant, amount);
+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);
+        return instant;
+    }
+
+    /**
+     * Add to the offset component of the specified time instant,
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
+    }
+
+    /**
+     * Set the specified amount of offset units to the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param value  value of units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);
+        return super.set(instant, value - iOffset);
+    }
+
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
+    }
+
+    /**
+     * Get the minimum value for the field.
+     * 
+     * @return the minimum value
+     */
+    public int getMinimumValue() {
+        return iMin;
+    }
+
+    /**
+     * Get the maximum value for the field.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return iMax;
+    }
+    
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
+    }
+
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
+    /**
+     * Returns the offset added to the field values.
+     * 
+     * @return the offset
+     */
+    public int getOffset() {
+        return iOffset;
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
new file mode 100644
index 0000000..31ae302
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
@@ -0,0 +1,183 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DurationField;
+
+/**
+ * Precise datetime field, composed of two precise duration fields.
+ * <p>
+ * This DateTimeField is useful for defining DateTimeFields that are composed
+ * of precise durations, like time of day fields. If either duration field is
+ * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.
+ * <p>
+ * PreciseDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ * @see ImpreciseDateTimeField
+ */
+public class PreciseDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -5586801265774496376L;
+
+    /** The maximum range in the correct units */
+    private final int iRange;
+
+    private final DurationField iRangeField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "secondOfMinute".
+     * @param unit  precise unit duration, like "seconds()".
+     * @param range precise range duration, preferably a multiple of the unit,
+     * like "minutes()".
+     * @throws IllegalArgumentException if either duration field is imprecise
+     * @throws IllegalArgumentException if unit milliseconds is less than one
+     * or effective value range is less than two.
+     */
+    public PreciseDateTimeField(String name,
+                                DurationField unit, DurationField range) {
+        super(name, unit);
+
+        if (!range.isPrecise()) {
+            throw new IllegalArgumentException("Range duration field must be precise");
+        }
+
+        long rangeMillis = range.getUnitMillis();
+        iRange = (int)(rangeMillis / getUnitMillis());
+        if (iRange < 2) {
+            throw new IllegalArgumentException("The effective range must be at least 2");
+        }
+
+        iRangeField = range;
+    }
+
+    /**
+     * Get the amount of fractional units from the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the amount of fractional units extracted from the input.
+     */
+    public int get(long instant) {
+        if (instant >= 0) {
+            return (int) ((instant / getUnitMillis()) % iRange);
+        } else {
+            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);
+        }
+    }
+
+    /**
+     * Add to the component of the specified time instant, wrapping around
+     * within that component if necessary.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        int thisValue = get(instant);
+        int wrappedValue = FieldUtils.getWrappedValue
+            (thisValue, amount, getMinimumValue(), getMaximumValue());
+        // copy code from set() to avoid repeat call to get()
+        return instant + (wrappedValue - thisValue) * getUnitMillis();
+    }
+
+    /**
+     * Set the specified amount of units to the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  value of units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        return instant + (value - get(instant)) * iUnitMillis;
+    }
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "minute of hour", then the range duration field is an hours.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField() {
+        return iRangeField;
+    }
+
+    /**
+     * Get the maximum value for the field.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return iRange - 1;
+    }
+    
+    /**
+     * Returns the range of the field in the field's units.
+     * <p>
+     * For example, 60 for seconds per minute. The field is allowed values
+     * from 0 to range - 1.
+     * 
+     * @return unit range
+     */
+    public int getRange() {
+        return iRange;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
new file mode 100644
index 0000000..fa804a7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
@@ -0,0 +1,234 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DurationField;
+
+/**
+ * Precise datetime field, which has a precise unit duration field.
+ * <p>
+ * PreciseDurationDateTimeField is thread-safe and immutable, and its
+ * subclasses must be as well.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {
+
+    static final long serialVersionUID = 5004523158306266035L;
+
+    /** The fractional unit in millis */
+    final long iUnitMillis;
+
+    private final DurationField iUnitField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "dayOfMonth".
+     * @param unit  precise unit duration, like "days()".
+     * @throws IllegalArgumentException if duration field is imprecise
+     * @throws IllegalArgumentException if unit milliseconds is less than one
+     */
+    public PreciseDurationDateTimeField(String name, DurationField unit) {
+        super(name);
+
+        if (!unit.isPrecise()) {
+            throw new IllegalArgumentException("Unit duration field must be precise");
+        }
+
+        iUnitMillis = unit.getUnitMillis();
+        if (iUnitMillis < 1) {
+            throw new IllegalArgumentException("The unit milliseconds must be at least 1");
+        }
+
+        iUnitField = unit;
+    }
+
+    /**
+     * Returns false by default.
+     */
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Add the specified amount of units to the specified time instant. The
+     * amount added may be negative.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        return instant + amount * iUnitMillis;
+    }
+
+    /**
+     * Add the specified amount of units to the specified time instant. The
+     * amount added may be negative.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        return instant + amount * iUnitMillis;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return (minuendInstant - subtrahendInstant) / iUnitMillis;
+    }
+
+    /**
+     * Set the specified amount of units to the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  value of units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),
+                                     getMaximumValueForSet(instant, value));
+        return instant + (value - get(instant)) * iUnitMillis;
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
+     * </pre>
+     */
+    public long roundFloor(long instant) {
+        if (instant >= 0) {
+            return instant - instant % iUnitMillis;
+        } else {
+            instant += 1;
+            return instant - instant % iUnitMillis - iUnitMillis;
+        }
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
+     * </pre>
+     */
+    public long roundCeiling(long instant) {
+        if (instant >= 0) {
+            instant -= 1;
+            return instant - instant % iUnitMillis + iUnitMillis;
+        } else {
+            return instant - instant % iUnitMillis;
+        }
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.remainder(instant + ALIGNMENT_MILLIS);
+     * </pre>
+     */
+    public long remainder(long instant) {
+        if (instant >= 0) {
+            return instant % iUnitMillis;
+        } else {
+            return (instant + 1) % iUnitMillis + iUnitMillis - 1;
+        }
+    }
+
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "minute of hour", then the duration field is minutes.
+     *
+     * @return the duration of this field, or UnsupportedDurationField if field
+     * has no duration
+     */
+    public DurationField getDurationField() {
+        return iUnitField;
+    }
+
+    /**
+     * Get the minimum value for the field.
+     * 
+     * @return the minimum value
+     */
+    public int getMinimumValue() {
+        return 0;
+    }
+
+    public final long getUnitMillis() {
+        return iUnitMillis;
+    }
+
+    /**
+     * Called by the set method to get the maximum allowed value. By default,
+     * returns getMaximumValue(instant). Override to provide a faster
+     * implementation.
+     */
+    protected int getMaximumValueForSet(long instant, int value) {
+        return getMaximumValue(instant);
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
new file mode 100644
index 0000000..7e736f3
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
@@ -0,0 +1,151 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+/**
+ * Duration field class representing a field with a fixed unit length.
+ * <p>
+ * PreciseDurationField is thread-safe and immutable.
+ * 
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class PreciseDurationField extends AbstractDurationField {
+    
+    static final long serialVersionUID = -8346152187724495365L;
+
+    /** The size of the unit */
+    private final long iUnitMillis;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  the name of the field, like "seconds"
+     * @param unitMillis  the unit milliseconds
+     */    
+    public PreciseDurationField(String name, long unitMillis) {
+        super(name);
+        iUnitMillis = unitMillis;
+    }
+    
+    //------------------------------------------------------------------------
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public final boolean isPrecise() {
+        return true;
+    }
+    
+    /**
+     * Returns the amount of milliseconds per unit value of this field.
+     *
+     * @return the unit size of this field, in milliseconds
+     */
+    public final long getUnitMillis() {
+        return iUnitMillis;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds.
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  ignored
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration, long instant) {
+        return duration / iUnitMillis;
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @param instant  ignored
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value, long instant) {
+        return value * iUnitMillis;
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @param instant  ignored
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value, long instant) {
+        return value * iUnitMillis;
+    }
+
+    public long add(long instant, int value) {
+        return instant + value * iUnitMillis;
+    }
+
+    public long add(long instant, long value) {
+        return instant + value * iUnitMillis;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return (minuendInstant - subtrahendInstant) / iUnitMillis;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
new file mode 100644
index 0000000..efee8d7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
@@ -0,0 +1,228 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Counterpart remainder datetime field to {@link DividedDateTimeField}. The
+ * field's unit duration is unchanged, but the range duration is scaled
+ * accordingly.
+ * <p>
+ * RemainderDateTimeField is thread-safe and immutable.
+ *
+ * @see DividedDateTimeField
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class RemainderDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 5708241235177666790L;
+
+    // Shared with DividedDateTimeField.
+    final int iDivisor;
+    final DurationField iRangeField;
+
+    /**
+     * Constructor.
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "yearOfCentury".
+     * @param rangeName  short, descriptive name, like "centuries".
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
+     */
+    public RemainderDateTimeField(DateTimeField field,
+                                  String name, String rangeName, int divisor) {
+        super(field, name);
+
+        if (divisor < 2) {
+            throw new IllegalArgumentException("The divisor must be at least 2");
+        }
+
+        DurationField rangeField = field.getDurationField();
+        if (rangeField == null) {
+            iRangeField = null;
+        } else {
+            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);
+        }
+
+        iDivisor = divisor;
+    }
+
+    /**
+     * Construct a RemainderDateTimeField that compliments the given
+     * DividedDateTimeField.
+     *
+     * @param dividedField  complimentary divided field, like "century()".
+     * @param name  short, descriptive name, like "yearOfCentury".
+     */
+    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {
+        super(dividedField.getWrappedField(), name);
+        iDivisor = dividedField.iDivisor;
+        iRangeField = dividedField.iDurationField;
+    }
+
+    /**
+     * Get the remainder from the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the remainder extracted from the input.
+     */
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
+        if (value >= 0) {
+            return value % iDivisor;
+        } else {
+            return (iDivisor - 1) + ((value + 1) % iDivisor);
+        }
+    }
+
+    /**
+     * Add the specified amount to the specified time instant, wrapping around
+     * within the remainder range if necessary. The amount added may be
+     * negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
+    }
+
+    /**
+     * Set the specified amount of remainder units to the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param value  value of remainder units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);
+        int divided = getDivided(getWrappedField().get(instant));
+        return getWrappedField().set(instant, divided * iDivisor + value);
+    }
+
+    /**
+     * Returns a scaled version of the wrapped field's unit duration field.
+     */
+    public DurationField getRangeDurationField() {
+        return iRangeField;
+    }
+
+    /**
+     * Get the minimum value for the field, which is always zero.
+     * 
+     * @return the minimum value of zero.
+     */
+    public int getMinimumValue() {
+        return 0;
+    }
+
+    /**
+     * Get the maximum value for the field, which is always one less than the
+     * divisor.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return iDivisor - 1;
+    }
+
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
+    }
+
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
+    /**
+     * Returns the divisor applied, in the field's units.
+     * 
+     * @return the divisor
+     */
+    public int getDivisor() {
+        return iDivisor;
+    }
+
+    private int getDivided(int value) {
+        if (value >= 0) {
+            return value / iDivisor;
+        } else {
+            return ((value + 1) / iDivisor) - 1;
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java b/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java
new file mode 100644
index 0000000..db52dc1
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java
@@ -0,0 +1,150 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DurationField;
+
+/**
+ * Scales a DurationField such that it's unit millis becomes larger in
+ * magnitude.
+ * <p>
+ * ScaledDurationField is thread-safe and immutable.
+ *
+ * @see PreciseDurationField
+ *
+ * @author Brian S O'Neill
+ */
+public class ScaledDurationField extends DecoratedDurationField {
+
+    static final long serialVersionUID = -3205227092378684157L;
+
+    private final int iScalar;
+
+    /**
+     * Constructor
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "centuries".
+     * @param scalar  scalar, such as 100 years in a century
+     * @throws IllegalArgumentException if scalar is zero or one.
+     */
+    public ScaledDurationField(DurationField field, String name, int scalar) {
+        super(field, name);
+        if (scalar == 0 || scalar == 1) {
+            throw new IllegalArgumentException("The scalar must not be 0 or 1");
+        }
+        iScalar = scalar;
+    }
+
+    public int getValue(long duration) {
+        return getWrappedField().getValue(duration) / iScalar;
+    }
+
+    public long getValueAsLong(long duration) {
+        return getWrappedField().getValueAsLong(duration) / iScalar;
+    }
+
+    public int getValue(long duration, long instant) {
+        return getWrappedField().getValue(duration, instant) / iScalar;
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return getWrappedField().getValueAsLong(duration, instant) / iScalar;
+    }
+
+    public long getMillis(int value) {
+        return getWrappedField().getMillis(value * iScalar);
+    }
+
+    public long getMillis(long value) {
+        return getWrappedField().getMillis(value * iScalar);
+    }
+
+    public long getMillis(int value, long instant) {
+        return getWrappedField().getMillis(value * iScalar, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return getWrappedField().getMillis(value * iScalar, instant);
+    }
+
+    public long add(long instant, int value) {
+        return getWrappedField().add(instant, value * iScalar);
+    }
+
+    public long add(long instant, long value) {
+        return getWrappedField().add(instant, value * iScalar);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;
+    }
+
+    public long getUnitMillis() {
+        return getWrappedField().getUnitMillis() * iScalar;
+    }
+
+    /**
+     * Returns the scalar applied, in the field's units.
+     * 
+     * @return the scalar
+     */
+    public int getScalar() {
+        return iScalar;
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java b/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java
new file mode 100644
index 0000000..15e50ea
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java
@@ -0,0 +1,108 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * Converts a lenient DateTimeField into a strict one. By being strict, the set
+ * throws an IllegalArgumentException if the value is out of bounds.
+ * <p>
+ * StrictDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see org.joda.time.chrono.StrictChronology
+ * @see LenientDateTimeField
+ */
+public class StrictDateTimeField extends DelegatedDateTimeField {
+
+    static final long serialVersionUID = 3154803964207950910L;
+
+    /**
+     * Returns a strict version of the given field. If it is already strict,
+     * then it is returned as-is. Otherwise, a new StrictDateTimeField is
+     * returned.
+     */
+    public static DateTimeField getInstance(DateTimeField field) {
+        if (field == null) {
+            return null;
+        }
+        if (field instanceof LenientDateTimeField) {
+            field = ((LenientDateTimeField)field).getWrappedField();
+        }
+        if (!field.isLenient()) {
+            return field;
+        }
+        return new StrictDateTimeField(field);
+    }
+
+    protected StrictDateTimeField(DateTimeField field) {
+        super(field);
+    }
+
+    public final boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Does a bounds check before setting the value.
+     *
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public long set(long instant, int value) {
+        FieldUtils.verifyValueBounds
+            (this, value, getMinimumValue(instant), getMaximumValue(instant));
+        return super.set(instant, value);
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
new file mode 100644
index 0000000..d00055b
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -0,0 +1,432 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * A placeholder implementation to use when a datetime field is not supported.
+ * <p>
+ * UnsupportedDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class UnsupportedDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -1934618396111902255L;
+
+    /**
+     * Instance with the name "unsupported".
+     */
+    public static final UnsupportedDateTimeField INSTANCE =
+        getInstance("unsupported", UnsupportedDurationField.INSTANCE);
+
+    private static HashMap cCache;
+
+    /**
+     * @throws IllegalArgumentException if durationField is null
+     */
+    public static synchronized UnsupportedDateTimeField getInstance
+        (String name, DurationField durationField) {
+
+        UnsupportedDateTimeField field;
+        if (cCache == null) {
+            cCache = new HashMap(7);
+            field = null;
+        } else {
+            field = (UnsupportedDateTimeField)cCache.get(name);
+            if (field != null && field.getDurationField() != durationField) {
+                field = null;
+            }
+        }
+        if (field == null) {
+            field = new UnsupportedDateTimeField(name, durationField);
+            cCache.put(name, field);
+        }
+        return field;
+    }
+
+    private final String iName;
+    private final DurationField iDurationField;
+
+    private UnsupportedDateTimeField(String name, DurationField durationField) {
+        if (durationField == null) {
+            throw new IllegalArgumentException();
+        }
+        iName = name;
+        iDurationField = durationField;
+    }
+
+    // Design note: Simple accessors return a suitable value, but methods
+    // intended to perform calculations throw an UnsupportedOperationException.
+
+    public String getName() {
+        return iName;
+    }
+
+    /**
+     * This field is not supported.
+     *
+     * @return false always
+     */
+    public boolean isSupported() {
+        return false;
+    }
+
+    /**
+     * This field is not lenient.
+     *
+     * @return false always
+     */
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int get(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsText(long instant, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsText(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsShortText(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long add(long instant, int value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long add(long instant, long value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long addWrapped(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, String text, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, String text) {
+        throw unsupported();
+    }
+
+    /**
+     * Even though this DateTimeField is unsupported, the duration field might
+     * be supported.
+     *
+     * @return a possibly supported DurationField
+     */
+    public DurationField getDurationField() {
+        return iDurationField;
+    }
+
+    /**
+     * Always returns null.
+     *
+     * @return null always
+     */
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public boolean isLeap(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getLeapAmount(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always returns null.
+     *
+     * @return null always
+     */
+    public DurationField getLeapDurationField() {
+        return null;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue() {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue() {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumTextLength(Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundFloor(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundCeiling(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfFloor(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfCeiling(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfEven(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long remainder(long instant) {
+        throw unsupported();
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "UnsupportedDateTimeField";
+    }
+
+    /**
+     * Ensure proper singleton serialization
+     */
+    private Object readResolve() {
+        return getInstance(iName, iDurationField);
+    }
+
+    private UnsupportedOperationException unsupported() {
+        return new UnsupportedOperationException(iName + " field is unsupported");
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
new file mode 100644
index 0000000..88f66b7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
@@ -0,0 +1,271 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.field;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import org.joda.time.DurationField;
+
+/**
+ * A placeholder implementation to use when a duration field is not supported.
+ * <p>
+ * UnsupportedDurationField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class UnsupportedDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -6390301302770925357L;
+
+    /**
+     * Instance with the name "unsupported".
+     */
+    public static final UnsupportedDurationField INSTANCE = getInstance("unsupported");
+
+    private static HashMap cCache;
+
+    public static synchronized UnsupportedDurationField getInstance(String name) {
+        UnsupportedDurationField field;
+        if (cCache == null) {
+            cCache = new HashMap(7);
+            field = null;
+        } else {
+            field = (UnsupportedDurationField)cCache.get(name);
+        }
+        if (field == null) {
+            field = new UnsupportedDurationField(name);
+            cCache.put(name, field);
+        }
+        return field;
+    }
+
+    private final String iName;
+
+    private UnsupportedDurationField(String name) {
+        iName = name;
+    }
+
+    // Design note: Simple Accessors return a suitable value, but methods
+    // intended to perform calculations throw an UnsupportedOperationException.
+
+    public String getName() {
+        return iName;
+    }
+
+    /**
+     * This field is not supported.
+     *
+     * @return false always
+     */
+    public boolean isSupported() {
+        return false;
+    }
+
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public boolean isPrecise() {
+        return true;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getValue(long duration) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getValueAsLong(long duration) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getValue(long duration, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getValueAsLong(long duration, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(long value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(int value, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(long value, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long add(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long add(long instant, long value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always returns zero.
+     *
+     * @return zero always
+     */
+    public long getUnitMillis() {
+        return 0;
+    }
+
+    /**
+     * Always returns zero, indicating that sort order is not relevent.
+     *
+     * @return zero always
+     */
+    public int compareTo(Object durationField) {
+        return 0;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "UnsupportedDurationField";
+    }
+
+    /**
+     * Ensure proper singleton serialization
+     */
+    private Object readResolve() {
+        return getInstance(iName);
+    }
+
+    private UnsupportedOperationException unsupported() {
+        return new UnsupportedOperationException(iName + " field is unsupported");
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/field/package.html b/JodaTime/src/java/org/joda/time/field/package.html
new file mode 100644
index 0000000..39a43bd
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/package.html
@@ -0,0 +1,66 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.field package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-2004 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
+<body>
+<p>
+Provides DateTimeField and DurationField implementaions and support.
+</p>
+</body>
+</html>
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index 7757777..6baac60 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -68,8 +68,8 @@
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.RemainderDateTimeField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeFormat provides localized printing and parsing capabilities for all
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index c087757..3fea8b2 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -62,9 +62,9 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.PreciseDateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.PreciseDateTimeField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.
diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index d4ffffd..140f0f9 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -58,7 +58,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * ISODateTimeFormat provides factory methods for the ISO8601 standard.
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index ec8cd1a..98d653b 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -68,7 +68,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index d824d90..b6cfbef 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -80,7 +80,7 @@
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.chrono.LenientChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * Compiles Olson ZoneInfo database files into binary files for each time zone
@@ -98,7 +98,9 @@
  * @author Brian S O'Neill
  */
 public class ZoneInfoCompiler {
-    static final DateTimeOfYear START_OF_YEAR = new DateTimeOfYear();
+    static DateTimeOfYear cStartOfYear;
+
+    static Chronology cLenientISO;
 
     /**
      * Launches the ZoneInfoCompiler tool.
@@ -159,6 +161,20 @@
         System.out.println("  -dst <directory>    Specify where to write generated files");
     }
 
+    static DateTimeOfYear getStartOfYear() {
+        if (cStartOfYear == null) {
+            cStartOfYear = new DateTimeOfYear();
+        }
+        return cStartOfYear;
+    }
+
+    static Chronology getLenientISOChronology() {
+        if (cLenientISO == null) {
+            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());
+        }
+        return cLenientISO;
+    }
+
     /**
      * @param zimap maps string ids to DateTimeZone objects.
      */
@@ -259,11 +275,10 @@
     }
 
     static int parseTime(String str) {
-        Chronology chrono = new LenientChronology(ISOChronology.getInstanceUTC());
         DateTimeParser p = ISODateTimeFormat
-            .getInstance(chrono)
+            .getInstance(getLenientISOChronology())
             .hourMinuteSecondFraction();
-        MutableDateTime mdt = new MutableDateTime(0, chrono);
+        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
         int pos = 0;
         if (str.startsWith("-")) {
             pos = 1;
@@ -768,7 +783,7 @@
             iFormat = st.nextToken().intern();
 
             int year = Integer.MAX_VALUE;
-            DateTimeOfYear dtOfYear = START_OF_YEAR;
+            DateTimeOfYear dtOfYear = getStartOfYear();
 
             if (st.hasMoreTokens()) {
                 year = Integer.parseInt(st.nextToken());
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
index 69c81e7..a3b6f5c 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
@@ -61,8 +61,8 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test base class for
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
index 7b7e4b2..e02abdd 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
@@ -67,7 +67,7 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test base class for
  * ReadableInstant implementations.
diff --git a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
index e3959aa..e18e33c 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
@@ -60,7 +60,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.*;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/BulkTest.java b/JodaTime/src/test/org/joda/test/time/BulkTest.java
index 0cdc56d..72320da 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java
@@ -67,7 +67,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  *  A {@link TestCase} that can define both simple and bulk test methods.<P>
  *
diff --git a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
index 6be12fb..b9fc0e3 100644
--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
@@ -57,7 +57,7 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
+import org.joda.time.chrono.BuddhistChronology;
 
 import junit.framework.TestSuite;
 /**
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
index 937c35d..c615597 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
@@ -67,7 +67,7 @@
 import org.joda.time.DateTimeComparator;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.DateTimeComparator class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
index efac6a5..bf752af 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
@@ -58,8 +58,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the CTORs of the
  * DateTime date time class.  The DateTime class is passed
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
index 850c50b..0dd0552 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
@@ -66,7 +66,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
index 694016c..2289880 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
@@ -66,7 +66,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
index 8fe430b..c63c4da 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
@@ -65,7 +65,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
index a987356..7f48952 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
@@ -68,7 +68,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
index cf0baf4..15230ed 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
@@ -63,7 +63,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
index 57c1719..b4eec76 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
@@ -59,8 +59,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the CTORs of the
  * MutableDateTime date time class.  The MutableDateTime class is passed
diff --git a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
index f08d3fb..3006584 100644
--- a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
@@ -62,7 +62,7 @@
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.test.time.BulkTest;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
+import org.joda.time.chrono.BuddhistChronology;
 /**
  * This class is the Junit unit test for a DateTimeField.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
index 66b8017..8652a73 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
@@ -59,7 +59,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.JulianChronology;
 
 /**
  * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj
@@ -203,10 +204,10 @@
         iMode = mode;
         if (mode == GREGORIAN_MODE) {
             iTest = new TestGregorianChronology();
-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true);
+            iActual = GregorianChronology.getInstanceUTC();
         } else {
             iTest = new TestJulianChronology();
-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MAX_VALUE, true);
+            iActual = JulianChronology.getInstanceUTC();
         }
     }
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
index a31f219..eec544e 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
@@ -57,6 +57,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.chrono.AbstractChronology;
 
 /**
  * A reference Gregorian/Julian chronology implementation, intended for testing
@@ -81,7 +82,7 @@
  *
  * @author Brian S O'Neill
  */
-abstract class TestGJChronology extends Chronology {
+abstract class TestGJChronology extends AbstractChronology {
     static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
 
     /**
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
index a05509f..819e08a 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
@@ -53,8 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  * 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
index d7e7ecd..13361cb 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
@@ -53,7 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.FieldUtils;
 
 /**
  * 
@@ -66,14 +66,14 @@
 
     public long addWrapped(long millis, int value) {
         int weekyear = get(millis);
-        int wrapped = Utils.getWrappedValue
+        int wrapped = FieldUtils.getWrappedValue
             (weekyear, value, getMinimumValue(), getMaximumValue());
         return add(millis, (long) wrapped - weekyear);
     }
 
     public long add(long millis, long value) {
         int weekyear = get(millis);
-        int newWeekyear = weekyear + Utils.safeToInt(value);
+        int newWeekyear = weekyear + FieldUtils.safeToInt(value);
         if (weekyear < 0) {
             if (newWeekyear >= 0) {
                 newWeekyear++;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
index 4ce54b6..616a2fa 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
@@ -53,7 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.FieldUtils;
 
 /**
  * 
@@ -66,14 +66,14 @@
 
     public long addWrapped(long millis, int value) {
         int year = get(millis);
-        int wrapped = Utils.getWrappedValue
+        int wrapped = FieldUtils.getWrappedValue
             (year, value, getMinimumValue(), getMaximumValue());
         return add(millis, (long) wrapped - year);
     }
 
     public long add(long millis, long value) {
         int year = get(millis);
-        int newYear = year + Utils.safeToInt(value);
+        int newYear = year + FieldUtils.safeToInt(value);
         if (year < 0) {
             if (newYear >= 0) {
                 newYear++;
diff --git a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
index ed3ff04..aa679f6 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
@@ -54,7 +54,7 @@
 package org.joda.test.time.gj;
 
 import org.joda.test.time.AbstractTestDateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
@@ -68,7 +68,7 @@
     }
 
     static final int[] monthLengths = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
-    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianJulianCutoverMillis();
+    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianCutover().getMillis();
     
     protected int[] getDMYDS(long millis) {
         return getDMYDS(millis, GJ_CUTOVER_MILLIS, 1582, 10);
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
index 895fa4e..cf9b63d 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
index 2b09780..a0c57ff 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
index 8de9c01..f4c3c83 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
@@ -56,7 +56,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
index 6d7f634..c533071 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
@@ -62,7 +62,7 @@
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
index 7482d8f..2d72b6b 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
@@ -56,7 +56,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
index debc0fa..230a4bc 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
@@ -60,7 +60,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
index 21f2755..25620c1 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
index 81de07d..0501304 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
index b6a51a3..6f068a4 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
index c2f6e47..8bbe9d9 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
index 5d29af9..dada080 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
index da1b359..2731d15 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
index 9f9c5fb..005ceb9 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
@@ -59,7 +59,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
index ef19229..354e170 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
index c52dacc..56e82d3 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
index 57f8ec2..f6df1d4 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
@@ -61,7 +61,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.Instant;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
index 1ca954b..5e2a2da 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
@@ -59,7 +59,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
index dba4aa6..c9fcdb6 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
@@ -59,7 +59,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
index 90dea95..75a9586 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
index 29d3ac1..a9004c4 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
index 6a957da..f043ced 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
index d1b5c4b..3f45f83 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
index 2cc2cf8..83899df 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
index 2dc55c6..03252fb 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
index a24e09e..2312c99 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
index 4ef344b..346fe3b 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
index 3228f43..355fead 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
index 45dd4ab..fc13c25 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
index 7343ae8..0c31295 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
index 8ace198..fda43a2 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
index 000672d..af940d6 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
index 2088a68..1dfabac 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
index fc8a02e..d18acb1 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
